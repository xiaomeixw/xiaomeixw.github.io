<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
    

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.4"/>


    <meta name="description" content="重新发现、定义并创造这个世界..." />



  <meta name="keywords" content="Hexo,next" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.4" />


<meta name="description" content="重新发现、定义并创造这个世界...">
<meta property="og:type" content="website">
<meta property="og:title" content="sabria">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="sabria">
<meta property="og:description" content="重新发现、定义并创造这个世界...">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="sabria">
<meta name="twitter:description" content="重新发现、定义并创造这个世界...">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'hide'
  };
</script>

    <title> sabria </title>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->




<div class="container one-column 
   page-home 
">
    <div class="headband"></div>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">sabria</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-tags"></i> <br />
            标签
          </a>
        </li>
      
    </ul>
  

  
</nav>


        </div>
    </header>

    <main id="main" class="main">
        <div class="main-inner">
            <div id="content" class="content">
                
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/01/13/ZTN01_4/" itemprop="url">
                【杂谈1月】Android注解范式编程Part2
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-01-13T01:32:12+08:00" content="2016-01-13">
            2016-01-13
          </time>
        </span>

        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>Android注解范式编程Part2</p>
<p>如果你做过JavaEE开发,你应该知道一个概念，叫:DI(依赖注入),依赖注入是Spring的核心思想,它将对象的创建交给Spring来进行管理,在初始化整个Java-web时,初始化在Spring的配置文件中的一批对象,当代码中需要对象时,只要直接从Spring中获取,而不需要自己去new.同时ClassA中如果需要的是ClassB对象,spring配置文件中也是有相应的对象ref引用的。</p>
<p>如果单纯这个说Spring这个概念的话，因为很多Android同仁也没有做过JavaEE的开始，所以最终决定还是在<br>Part2中专门抽一个小节给点Spring的概念简述.</p>
<h2 id="一-Spring简述">一.Spring简述</h2><p>Spring是Interface21公司开源的轻量级的JavaEE开发框架。它主要是控制Web三层架构的Service层的操作,它的核心是控制反转（IoC）和面向切面（AOP）。</p>
<p>控制反转（IoC）：应用本身不负责依赖对象的创建及维护。也就是在应用本身不new对象。由Spring等IOC容器来处理对象的创建与维护。这个含义在某种程度上也就是DI(依赖注入)。具体的差异我会专门有文章讨论,这里不做过多描述。</p>
<p>面向切面编程（AOP）：通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP思想：在程序员编写代码时，随时动态的插入、删除这些系统服务性代码(如事务)。它的本质：动态代理。(spring使用的不是JDK的动态代理，而是使用个cglib第三方动态代理。)</p>
<p>Spring中最重要的是Bean对象的注入方案问题,理论上有三种解决方案:<br>比如：如何将到PersonDao对象注入PersonService中？</p>
<ul>
<li>通过属性+set方法(接口)</li>
<li>通过属性+构造器</li>
<li>使用字段Field注解的方法(注解的方式)</li>
</ul>
<p>这里我就以方案一来处理,其他如果描述过多了，还影响我们讨论Android有关的知识。</p>
<p>PersonServiceBean对象:将PersonDao对象注入PersonService中</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceBean</span> <span class="keyword">implements</span> <span class="title">PersonService</span> </span>{

    <span class="keyword">private</span> PersonDao personDao;

    <span class="function"><span class="keyword">public</span> PersonDao <span class="title">getPersonDao</span><span class="params">()</span></span>{
        <span class="keyword">return</span> personDao;
    }

    <span class="function">Public <span class="keyword">void</span> <span class="title">setPersonDao</span><span class="params">(PersonDao personDao)</span></span>{
        <span class="keyword">this</span>.personDao=personDao;
    }

}
</code></pre><p>Spring配置文件:ref</p>
<pre><code>&lt;bean id=<span class="string">"personDao"</span> class =<span class="string">"sabria.demo.annotationdemo.dao.impl.PersonDao"</span>&gt;&lt;/bean&gt;
&lt;bean id=<span class="string">"personService"</span> class =<span class="string">"sabria.demo.annotationdemo.service.impl.PersonServiceBean"</span>&gt;
    &lt;property name=<span class="string">"personDao"</span> <span class="keyword">ref</span>=<span class="string">"personDao"</span>&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>我们看到Spring.xml文件在配置personService时,指定了一个ref引用”personDao”，然后它指向”sabria.demo.annotationdemo.dao.impl.PersonDaoBean”,这样就完成通过属性+set方法的方案来完成引用对象的注入。</p>
<p>我们看到在Spring中极度简化了对象的创建以及“对象中对其他对象”的引用。而这种思想在Android中也大行其道,在Android端有3个非常成熟的方案在践行DI：Dagger、RoboGuice和ButterKnife.在这里我们不会去谈论这些成熟方案的范例使用或者是源代码解读,在Part2中我们要回归这些library的本质去探究“运行时注解和编译时注解”，而这才是这些DI框架的核心元素。</p>
<h2 id="二-运行时注解">二.运行时注解</h2><p>我们在使用ButterKnife时尝试简化findViewById操作,</p>
<h2 id="三-编译时注解">三.编译时注解</h2><pre><code><span class="at_rule">@<span class="keyword">Retention(RetentionPolicy.CLASS)</span>
@<span class="function">Target</span>(</span>{ <span class="tag">ElementType</span><span class="class">.FIELD</span>, <span class="tag">ElementType</span><span class="class">.TYPE</span> })
<span class="tag">public</span> <span class="at_rule">@<span class="keyword">interface</span> InjectView</span>{
    <span class="tag">int</span> <span class="tag">value</span>();
}
</code></pre><p>相对于类似<a href="https://github.com/wyouflf/xUtils/blob/192c2a886c2d467e50718c6e469de63696f5cded/library/src/com/lidroid/xutils/ViewUtils.java#L89" target="_blank" rel="external">xUtils</a>、<a href="https://github.com/yanchenko/droidparts/blob/4382976a54e7ccd5c2c3a25c7acbd7cae2c6030e/droidparts/src/org/droidparts/Injector.java#L100" target="_blank" rel="external">Droidparts</a>这样开源了多年的框架集成的运行时注解模块而言，编译时注解由于是直接将代码在编译时期就生成，所以它完全不存在性能损耗上的问题,在很大程度上，我们应该避免使用任何运行时注解框架。</p>
<p>我们还是来以解决findViewById来处理编译时注解。在这之后我会给一些API的总结,以方便去攥写更大型的编译时注解框架。</p>
<h3 id="3-1_编译时注解类的操作步骤：">3.1 编译时注解类的操作步骤：</h3><p>1.新建java工程：new module—&gt;Java Library,该library主要是做编译时注解解读工作。</p>
<p><img src="http://i.imgur.com/9CcBl33.png" alt=""></p>
<p>2.继承AbstractProcessor:</p>
<p>类上加上这两个注解：</p>
<ul>
<li>@SupportedAnnotationTypes的值为当前类支持的注解的完整类路径，支持通配符。</li>
<li>@SupportedSourceVersion 标识该处理器支持的源码版本</li>
</ul>
<pre><code><span class="annotation">@SupportedAnnotationTypes</span>(<span class="string">"com.sabria.noinject.InjectView"</span>)
<span class="annotation">@SupportedSourceVersion</span>(<span class="type">SourceVersion</span>.<span class="type">RELEASE_6</span>)
public <span class="class"><span class="keyword">class</span> <span class="title">NoKnifeProcessor</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AbstractProcessor</span> {</span>            
    <span class="annotation">@Override</span>
    public boolean process(<span class="type">Set</span>&lt;? <span class="keyword">extends</span> <span class="type">TypeElement</span>&gt; annotations, <span class="type">RoundEnvironment</span> roundEnv) {
        <span class="keyword">return</span> <span class="literal">false</span>;
    }                
}
</code></pre><p>注:Eclipse如果找不到AbstractProcessor，记得右键build-path add library把jdk加进来.<br>AS中： import javax.annotation.processing.AbstractProcessor;</p>
<p>3.创建resources,然后在里面创建META-INF/services/javax.annotation.processing.Processor文件.</p>
<p>里面填上自己自定义注解解析器的全路径包类名</p>
<p><img src="http://i.imgur.com/2W3JfOi.png" alt=""></p>
<p><img src="http://i.imgur.com/RzqXI3a.png" alt=""></p>
<p>4.Eclipse需要把导出为Jar,AS的话就直接引用</p>
<p><img src="http://i.imgur.com/cK9ZeNh.png" alt=""></p>
<h3 id="3-2_编译时注解的分包架构">3.2 编译时注解的分包架构</h3><p>我将采用3包机制来处理,如果你研习过Butterknife，它采用的是四包机制.</p>
<p><img src="http://i.imgur.com/6YkMUsr.png" alt=""></p>
<p>Butterknife的四包架构：</p>
<ul>
<li><p>butterknife-annotations  注解包,包中是所有的注解类对象</p>
<pre><code><span class="variable">@Retention</span>(CLASS)
<span class="variable">@Target</span>(FIELD)
public <span class="variable">@interface</span> Unbinder {
}
</code></pre></li>
<li><p>butterknife-compiler  解析包,也就是通过javac生成的编译class类.</p>
</li>
</ul>
<pre><code><span class="annotation">@AutoService</span>(<span class="type">Processor</span>.<span class="keyword">class</span>)
public <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ButterKnifeProcessor</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AbstractProcessor</span> {</span>
}
</code></pre><ul>
<li><p>butterknife 绑定包 与Activity等生命周期绑定,注入Activity(以及它里面的注解标识)到解析器中。</p>
<pre><code><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ButterKnife</span> </span>{        
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">bind</span><span class="params">(@NonNull Activity <span class="keyword">target</span>)</span> </span>{
        bind(<span class="keyword">target</span>, <span class="keyword">target</span>, Finder.ACTIVITY);
      }        
}
</code></pre></li>
<li><p>butterknife-sample 自然就是使用注解的Application应用</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">SimpleActivity</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Activity</span> {</span>

    <span class="annotation">@Bind</span>(<span class="type">R</span>.id.title) <span class="type">TextView</span> title;

     <span class="annotation">@Override</span> <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) {
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        setContentView(<span class="type">R</span>.layout.simple_activity);

        <span class="type">ButterKnife</span>.bind(<span class="keyword">this</span>);

        title.setText(<span class="string">"Butter Knife"</span>);

      }
}
</code></pre></li>
</ul>
<p>那所谓的三包机制，其实就是将注解包和绑定包放在一个包架构中，我这里实行三包相比较于四包是因为彼此的依赖关系更简单些，但没四包机制清晰。具体你在做自己框架时是启用四包还是三包，看个人喜好。</p>
<p><img src="http://i.imgur.com/Edp17GW.png" alt=""></p>
<ul>
<li><p>no-inject-api 包中含有注解来InjectView 和 绑定类 NoKnife</p>
</li>
<li><p>no-inject-process 包中含有NoKnifeProcessor解析类</p>
</li>
<li><p>app 包就是使用运行时注解应用</p>
</li>
</ul>
<h3 id="3-3_攥写注解类和绑定类">3.3 攥写注解类和绑定类</h3><p>在讲述part2章节重点的攥写编译时注解类Processor前，我们先完成no-inject-api包的工作:</p>
<p>创建在com.sabria.noinject包InjectView注解类:指定RetentionPolicy为CLASS级别.</p>
<pre><code><span class="annotation">@Retention</span>(RetentionPolicy.CLASS)
<span class="annotation">@Target</span>(ElementType.FIELD)
<span class="keyword">public</span> <span class="annotation">@interface</span> InjectView {
    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;
}
</code></pre><p>然后再main下创建一个包api的包，该包中再创建com.sabria.noinject，NoKnife类</p>
<pre><code>public class <span class="type">NoKnife</span> {   

    public <span class="keyword">static</span> <span class="type">void</span> inject(<span class="type">Activity</span> target) {
        <span class="type">Log</span>.e(<span class="type">NoKnife</span>.class.getCanonicalName(), <span class="string">"I AM ON INJECT"</span>);
        <span class="keyword">try</span> {
            final <span class="type">Class</span> clazz = <span class="type">Class</span>.forName(target.getClass().getCanonicalName() + <span class="string">"$$NoKnife"</span>);
            final <span class="type">Method</span> <span class="keyword">method</span> = clazz.getDeclaredMethod(<span class="string">"inject"</span>, target.getClass());
            <span class="keyword">method</span>.setAccessible(<span class="literal">true</span>);
            <span class="keyword">method</span>.invoke(clazz.newInstance(), target);
        } catch (<span class="type">ClassNotFoundException</span> e) {
            e.printStackTrace();
        } catch (<span class="type">NoSuchMethodException</span> e) {
            e.printStackTrace();
        } catch (<span class="type">InvocationTargetException</span> e) {
            e.printStackTrace();
        } catch (<span class="type">IllegalAccessException</span> e) {
            e.printStackTrace();
        } catch (<span class="type">InstantiationException</span> e) {
            e.printStackTrace();
        }
    }
}
</code></pre><p>它的工作很简单，就是拿到一个叫:MainActivity$$NoKnife.calss,然后破解形态的拿给类里面的一个叫inject()的方法，然后method.invoke(clazz.newInstance(), target)去执行这个inject()方法。</p>
<p>你会很奇怪,我怎么有个类叫MainActivity$$NoKnife.calss，然后我怎么知道这个类里面有个叫inject()的方法。保持住这个求知的疑问，我们在3.4中解读。</p>
<p>在实际开发中绑定类(包)一般是最后去完成的，这里放到最前面卖关子是为了更好的去理解3.4中的内容。</p>
<p>我们先来解决一个你在创建NoKnife时你会遇到的问题，因为AndroidStudio只是将在java包中创建的类为源代码类，非sources的包创建会直接无法被识别。所以将注解包和绑定包放在一个包结构中就需要指定绑定包的path路径为soruces：</p>
<pre><code><span class="name">sourceSets</span> {
    <span class="keyword">main</span>.java.srcDirs += [<span class="string">'src/main/api'</span>]
}
</code></pre><p><img src="http://i.imgur.com/jHtEqaw.png" alt=""></p>
<h3 id="3-4_攥写解析类Processor">3.4 攥写解析类Processor</h3><p>####3.4.1 基础解读</p>
<p><img src="http://i.imgur.com/ikidrvC.png" alt=""></p>
<p>3.1中已经描述了Processor类的创建过程，这里不再做说明,我们来详细解读下(Abstract)Processor类.</p>
<pre><code><span class="tag">public</span> <span class="tag">class</span> <span class="tag">MyProcessor</span> <span class="tag">extends</span> <span class="tag">AbstractProcessor</span> {

    <span class="variable">@Override</span>
    public synchronized void <span class="function">init</span>(ProcessingEnvironment env){ }

    <span class="variable">@Override</span>
    public boolean <span class="function">process</span>(Set&lt;? extends TypeElement&gt; annoations, RoundEnvironment env) { }

    <span class="variable">@Override</span>
    public Set&lt;String&gt; <span class="function">getSupportedAnnotationTypes</span>() { }

    <span class="variable">@Override</span>
    public SourceVersion <span class="function">getSupportedSourceVersion</span>() { }

}
</code></pre><p>讲解：<br>1.init(ProcessingEnvironment env): 每一个注解处理器类都必须有一个空的构造函数。ProcessingEnviroment提供很多有用的工具类Elements, Types和Filer。</p>
<p>2.process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env)：处理器的主函数main()，写你的扫描、评估和处理注解的代码，以及生成Java文件。输入参数RoundEnviroment，可以让你查询出包含特定注解的被注解元素。</p>
<p>3.getSupportedAnnotationTypes()：这个注解处理器是注册给哪个注解的。也就是自定义的那个注解类.</p>
<p>4.getSupportedSourceVersion()：用来指定你使用的Java版本。通常这里返回SourceVersion.latestSupported()。</p>
<p>继承于AbstractProcessor，然后会必需要求实现process()方法，其他的三个方法非必需实现，且在Java1.7上有更简单的实现方式(注解实现)。</p>
<p>Java1.7:getSupportedSourceVersion和getSupportedAnnotationTypes可以使用注解来解决</p>
<pre><code><span class="variable">@SupportedSourceVersion</span>(SourceVersion.<span class="function">latestSupported</span>())
<span class="variable">@SupportedAnnotationTypes</span>({
   <span class="comment">// 合法注解全名的集合</span>
 })
public class MyProcessor extends AbstractProcessor {

    <span class="variable">@Override</span>
    public synchronized void <span class="function">init</span>(ProcessingEnvironment env){ }

    <span class="variable">@Override</span>
    public boolean <span class="function">process</span>(Set&lt;? extends TypeElement&gt; annoations, RoundEnvironment env) { }
}
</code></pre><p>所以范例：</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">LittleKnifeProcessor</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AbstractProcessor</span> {</span>

    <span class="annotation">@Override</span>
    public <span class="type">SourceVersion</span> getSupportedSourceVersion() {
        <span class="keyword">return</span> <span class="type">SourceVersion</span>.latestSupported();
    }

    <span class="annotation">@Override</span>
    public <span class="type">Set</span>&lt;<span class="type">String</span>&gt; getSupportedAnnotationTypes() {
        <span class="type">LinkedHashSet</span>&lt;<span class="type">String</span>&gt; annotataions = <span class="keyword">new</span> <span class="type">LinkedHashSet</span>&lt;&gt;();
        annotataions.add(<span class="type">InjectView</span>.<span class="keyword">class</span>.getCanonicalName());
        <span class="keyword">return</span> annotataions;
    }

    <span class="annotation">@Override</span>
    public boolean process(<span class="type">Set</span>&lt;? <span class="keyword">extends</span> <span class="type">TypeElement</span>&gt; annoations, <span class="type">RoundEnvironment</span> env) { }

}
</code></pre><p>或者：</p>
<pre><code><span class="annotation">@SupportedAnnotationTypes</span>(<span class="string">"com.sabria.noinject.InjectView"</span>)
<span class="annotation">@SupportedSourceVersion</span>(<span class="type">SourceVersion</span>.<span class="type">RELEASE_6</span>)
public <span class="class"><span class="keyword">class</span> <span class="title">LittleKnifeProcessor</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AbstractProcessor</span> {</span>

    <span class="annotation">@Override</span>
    public boolean process(<span class="type">Set</span>&lt;? <span class="keyword">extends</span> <span class="type">TypeElement</span>&gt; annoations, <span class="type">RoundEnvironment</span> env) { }

}
</code></pre><p>这也就代表着我们只需要处理init()和process()方法，而init()方法则相对比较固定，它一般提供工具类Elements, Types和Filer。</p>
<pre><code> <span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnv)</span> </span>{
    <span class="keyword">super</span>.init(processingEnv);
    Types typeUtils = processingEnv.getTypeUtils();
    Elements elementUtils = processingEnv.getElementUtils();
    Filer filer = processingEnv.getFiler();
    Messager messager = processingEnv.getMessager();
}
</code></pre><p>首先我们对一个概念做解读:<a href="http://www.apihome.cn/api/java/Element.html" target="_blank" rel="external">Element</a>，在javax.lang.model.element包下：</p>
<blockquote>
<p>public interface Element<br>表示一个程序元素，比如包、类或者方法。每个元素都表示一个静态的语言级构造（不表示虚拟机的运行时构造）。</p>
</blockquote>
<p>这个概念很难理解，是的，因为我们很少去开发会用到类似API，所以你先浅显的理解为它是包，或者是类，又可以是方法就行了，它是一个一个的程序元素。</p>
<p>我们来一个一个看这四个帮助类:</p>
<ul>
<li><p>TypeUtils 处理<a href="http://www.766.com/doc/javax/lang/model/type/class-use/TypeMirror.html" target="_blank" rel="external">TypeMirror(表示 Java 编程语言中的类型。这些类型包括基本类型、声明类型（类和接口类型）、数组类型、类型变量和 null 类型。还可以表示通配符类型参数、executable 的签名和返回类型，以及对应于包和关键字 void 的伪类型。)</a>的帮助类，它有asElement()、isSubtype()等方法</p>
</li>
<li><p>ElementUtils 它包含很多Elements(一组Element)的帮助类信息，它有getPackageElement()、getTypeElement()、getPackageOf()方法。</p>
</li>
<li><p>Filer 创建文件</p>
</li>
<li><p>Messager 异常消息提醒</p>
</li>
</ul>
<p>####3.4.2 process()方法中常用API解读</p>
<pre><code><span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? <span class="keyword">extends</span> TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>{
}
</code></pre><p>1.获取所有含有@InjectView注解的Elements.</p>
<pre><code>roundEnv.<span class="function"><span class="title">getElementsAnnotatedWith</span><span class="params">(InjectView.class)</span></span>
</code></pre><p>返回的结果:Element元素的Set集合Set&lt;? extends Element&gt; annotatedElements</p>
<p>2.判断被标注@InjectView的Element是否是Class</p>
<pre><code>annotatedElement.<span class="function"><span class="title">getKind</span><span class="params">()</span></span> != ElementKind.CLASS
</code></pre><p>3.如果annotatedElement是ElementKind.CLASS，那么在某种程度上我们就可以直接将它当成TypeElement</p>
<pre><code>TypeElement typeElement = <span class="list">(<span class="keyword">TypeElement</span>)</span> annotatedElement<span class="comment">;</span>
</code></pre><p>4.判断classElement是否是被Public修饰</p>
<pre><code>classElement.<span class="function"><span class="title">getModifiers</span><span class="params">()</span></span>.<span class="function"><span class="title">contains</span><span class="params">(Modifier.PUBLIC)</span></span>
</code></pre><p>5.从Element元素的Set集合迭代出一个Element后,拿它的包名</p>
<pre><code>final String packageName = processingEnv.getElementUtils<span class="params">()</span>.getPackageOf<span class="params">(firstAnnotatedElement)</span>.toString<span class="params">()</span>;
</code></pre></span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/01/11/ZTN01_3/" itemprop="url">
                【正谈1月】Android注解范式编程Part1
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-01-11T21:32:09+08:00" content="2016-01-11">
            2016-01-11
          </time>
        </span>

        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>Android注解范式编程Part1</p>
<h2 id="一-概念">一.概念</h2><h3 id="1-1_含义:">1.1 含义:</h3><p>Android的注解是来源于Java本身,它相当于一种标记,加上这种标记后就等于给程序打上了一种“注释和解读”。java编译器和程序可以通过反射来获取此标记,然后根据定义的这个注解的“动作代码”去执行相应的操作。</p>
<h3 id="1-2_注解的定义格式：">1.2 注解的定义格式：</h3><pre><code>@头注释
<span class="variable">@interface</span>自定义{
    属性元素...
}
</code></pre><p>注解的格式由三个部分组成:</p>
<ul>
<li><em>1.@头注释：说明该注解的使用标注环境和场景；</em></li>
<li><em>2.@interface修饰：定义为该对象为自定义注解对象；</em></li>
<li><em>3.属性元素 ： 类似于参数(对象)量概念。</em></li>
</ul>
<p>比如下面的一个最简单的注解格式：</p>
<pre><code><span class="keyword">public</span> @<span class="class"><span class="keyword">interface</span> <span class="title">MyAnnotation</span> </span>{
    <span class="comment">//......</span>
}
</code></pre><p>或者一个更复杂的:</p>
<pre><code><span class="annotation">@Retention</span>(RetentionPolicy.RUNTIME)
<span class="annotation">@Target</span>(ElementType.METHOD)
<span class="annotation">@Documented</span>
<span class="keyword">public</span> <span class="annotation">@interface</span> GET {
    String value() <span class="keyword">default</span> <span class="string">""</span>;
}
</code></pre><h3 id="1-3_注解的书写格式：">1.3 注解的书写格式：</h3><p>也就是如何去用注解：</p>
<pre><code><span class="decorator">@ + 英文关键词</span>
</code></pre><p>比如Java提供给我们覆写方法的注解“@Override”，上面示例的使用为@MyAnnotation和@GET.</p>
<h3 id="1-4_系统提供的三个标准注解">1.4 系统提供的三个标准注解</h3><ul>
<li><em>@Override，表示当前的方法定义将覆盖超类中的方法。</em>    </li>
<li><em>@Deprecated，使用了注解为它的元素编译器将发出警告，因为注解@Deprecated是不赞成使用的代码，被弃用的代码。</em></li>
<li><em>@SuppressWarnings，关闭不当编译器警告信息。</em></li>
</ul>
<h2 id="二-自定义注解">二.自定义注解</h2><p>系统提供的三个标准注解是无法满足Android开发的生产环境的,所以我们必须自定义注解,然后解析该注解标识的对象(类、方法、字段等),完成相应业务逻辑.</p>
<p>Java为我们提供了一个元注解的概念,它的作用就是负责标注其他注解,去自定义该注解的工作范围和使用场景.</p>
<h3 id="2-1_元注解">2.1 元注解</h3><p>Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对自定义的annotation类型作说明。</p>
<ul>
<li>1.@Target ： 告知注解可以用于什么地方;</li>
<li>2.@Retention : </li>
<li>3.@Documented</li>
<li>4.@Inherited</li>
</ul>
<h4 id="2-1-1_@Target">2.1.1 @Target</h4><p>作用:告知注解可以用于什么地方.</p>
<p>书写格式:</p>
<pre><code>@<span class="function"><span class="title">Target</span><span class="params">(ElementType.METHOD)</span></span>
</code></pre><p>可选的ElementType参数有：</p>
<pre><code>ElemenetType<span class="class">.CONSTRUCTOR</span>      构造器声明 
ElemenetType<span class="class">.FIELD</span>          　域声明（包括 enum 实例） 
ElemenetType<span class="class">.LOCAL_VARIABLE</span>   局部变量声明 
ElemenetType<span class="class">.METHOD</span>           方法声明 
ElemenetType<span class="class">.PACKAGE</span>          包声明 
ElemenetType<span class="class">.PARAMETER</span>        参数声明 
ElemenetType<span class="class">.TYPE</span>          　 类，接口（包括注解类型）或enum声明
</code></pre><h4 id="2-1-2_@Retention">2.1.2 @Retention</h4><p>作用:表示需要在什么级别保存该注解信息.</p>
<p>书写格式:</p>
<pre><code>@<span class="function"><span class="title">Retention</span><span class="params">(RetentionPolicy.RUNTIME)</span></span>
</code></pre><p>可选的RetentionPolicy参数包括：</p>
<pre><code>RetentionPolicy<span class="class">.SOURCE</span> 　　　   注解将被编译器丢弃 
RetentionPolicy<span class="class">.CLASS</span> 　　　　　 注解在class文件中可用，但会被VM丢弃 
RetentionPolicy<span class="class">.RUNTIME</span> 　　　  VM将在运行期也保留注释，因此可以通过反射机制读取注解的信息。
</code></pre><p>同时根据级别的不同我们也将产生两种不同的注解时处理模式:</p>
<pre><code>RetentionPolicy               |<span class="string"> Describe                          </span>|<span class="string"> Chinese     </span>|<span class="string">  Example
------------------------------</span>|<span class="string"> --------------------------------- </span>|<span class="string"> ---------   </span>|<span class="string"> ---------- 
RetentionPolicy.RUNTIME       </span>|<span class="string"> Run Time Annotation Processor     </span>|<span class="string"> 运行时注解   </span>|<span class="string"> Retrofit
RetentionPolicy.CLASS         </span>|<span class="string"> Compile Time Annotation Processor </span>|<span class="string"> 编译时注解   </span>|<span class="string"> ButterKnife</span>
</code></pre><p>两者最大的区别在于:RTAP是运行时才会去操作注解,而CTAP是编译时就根据注解生成新的类对象或者完成了注解操作.<br>所以CTAP的性能十分优良,而RTAP则由于大量反射的使用导致性能受限.但CTAP的代码书写要相对于RTAP复杂很多,两者各有优势,具体的范例我为在Part2中提供出来，会做专门的比较。</p>
<h4 id="2-1-3_@Document">2.1.3 @Document</h4><p>作用:表示需要在什么级别保存该注解信息.</p>
<p>书写格式:</p>
<pre><code><span class="annotation">@Document</span>
</code></pre><h4 id="2-1-4_@Inherited">2.1.4 @Inherited</h4><p>作用:允许子类继承父类中的注解(class级别).</p>
<p>书写格式:</p>
<pre><code><span class="annotation">@Inherited</span>
</code></pre><h3 id="2-2_注解的元素(属性)">2.2 注解的元素(属性)</h3><p>注解的元素看起来就像接口的方法，唯一的区别在于可以为其制定默认值。没有元素的注解称为标记注解。</p>
<p>注解属性的类型只能是如下类型：</p>
<ul>
<li>String类型</li>
<li>8大基本数据类型</li>
<li>Class类型</li>
<li>枚举类型</li>
<li>注解类型</li>
<li>以上类型的一维数组</li>
</ul>
<p>示例:</p>
<pre><code><span class="annotation">@Target</span>(ElementType.METHOD)
<span class="annotation">@Retention</span>(RetentionPolicy.RUNTIME)
<span class="keyword">public</span> <span class="annotation">@interface</span> User {
      <span class="keyword">public</span> <span class="function">String <span class="title">id</span><span class="params">()</span></span>;
      <span class="keyword">public</span> String description() <span class="keyword">default</span> <span class="string">"defalut description"</span>;
}
</code></pre><p>或者:</p>
<pre><code><span class="annotation">@Retention</span>(RetentionPolicy.RUNTIME)
<span class="annotation">@Target</span>(ElementType.METHOD)
<span class="keyword">public</span> <span class="annotation">@interface</span> Subscribe {

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Mode</span></span>{
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Main = <span class="number">0</span>;
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Backgroud = <span class="number">1</span>;
    }

    <span class="function"><span class="keyword">int</span> <span class="title">mode</span><span class="params">()</span> <span class="keyword">default</span> Mode.Main</span>;
    <span class="function">String <span class="title">queue</span><span class="params">()</span> <span class="keyword">default</span> "GLOBAL"</span>;
}
</code></pre><p>使用:</p>
<pre><code><span class="at_rule">@<span class="keyword">Subscribe(mode=</span> Subscribe.Mode.Backgroud)
public void <span class="function">onProcessData</span>(ProcessData data) </span>{
    <span class="tag">mGlobalBus</span><span class="class">.post</span>(<span class="tag">new</span> <span class="tag">ProgressStatusEvent</span>(<span class="tag">i</span> + 1, <span class="tag">data</span><span class="class">.totalSteps</span>,<span class="tag">data</span><span class="class">.rank</span>));            
}
</code></pre><p>关于注解的元素,不一定在使用注解时都必须赋值,甚至可以标注注解时一个元素都不赋值.比如:</p>
<pre><code> @<span class="function">Subscribe
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onProgressStatusEvent</span>(<span class="params">ProgressStatusEvent <span class="keyword">event</span></span>) </span>{
    mProgressStatusEvent = <span class="keyword">event</span>;
    <span class="keyword">int</span> rank = <span class="keyword">event</span>.rank;
    mProgressBar0.setMax(<span class="keyword">event</span>.totalSteps);
    mProgressBar0.setProgress(<span class="keyword">event</span>.step);        
}
</code></pre><h2 id="3-设置注解并解析注解">3.设置注解并解析注解</h2><p>所谓设置注解也就是使用和标注自定义注解</p>
<p>比如自定义的注解:</p>
<pre><code><span class="annotation">@Target</span>(ElementType.METHOD)
<span class="annotation">@Retention</span>(RetentionPolicy.RUNTIME)
<span class="keyword">public</span> <span class="annotation">@interface</span> UserInfo {
      <span class="keyword">public</span> <span class="function">String <span class="title">id</span><span class="params">()</span></span>;
      <span class="keyword">public</span> String description() <span class="keyword">default</span> <span class="string">"defalut description"</span>;
}
</code></pre><p>使用它如下：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PasswordUtils</span> </span>{    

    <span class="annotation">@UserInfo</span>(id = <span class="number">47</span>, description = <span class="string">"Passwords must contain at least one numeric"</span>)
    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validatePassword</span><span class="params">(String password)</span> </span>{
           <span class="keyword">return</span> (password.matches(<span class="string">"\\w*\\d\\w*"</span>));
    }    

}
</code></pre><p>那么我们如何去解析这段注解：</p>
<blockquote>
<p>解决方案 : 通过注解处理器得到注解。<br>从原理上讲，注解处理器就是通过反射机制获取被检查方法上的注解信息，然后根据注解元素的值进行特定的处理。</p>
</blockquote>
<p>四个核心API:</p>
<p><img src="http://i.imgur.com/ldqqewB.png" width="80%"> </p>
<p>示例:</p>
<pre><code><span class="keyword">private</span> <span class="keyword">void</span> getAnno() {
    <span class="comment">//拿被注解方法上的</span>
    <span class="keyword">for</span> (Method m : PasswordUtils.<span class="keyword">class</span>.getDeclaredMethods()) {
        <span class="keyword">boolean</span> hasAnnotation = m.isAnnotationPresent(UserInfo.<span class="keyword">class</span>);
        <span class="comment">/**
         * 判断方法中是否有指定注解类型的注解
         */</span>
        <span class="keyword">if</span> (hasAnnotation) {
            <span class="comment">//拿到注解类</span>
            UserInfo annotation = m.getAnnotation(UserInfo.<span class="keyword">class</span>);
            <span class="keyword">if</span> (annotation != <span class="keyword">null</span>) {
                <span class="comment">//这样就拿到了定义的值:47</span>
                String id = annotation.id();
                String <span class="keyword">description</span> = annotation.<span class="keyword">description</span>();
                Toast.makeText(MainActivity.<span class="keyword">this</span>,<span class="string">"id="</span>+id+<span class="string">"/description="</span>+<span class="keyword">description</span>,Toast.LENGTH_LONG).show();
            }
        }
    }
}
</code></pre><p>代码见:<a href="https://github.com/xiaomeixw/AndroidDemo/blob/master/annotationdemo/src/main/java/sabria/demo/annotationdemo/MainActivity.java#L18" target="_blank" rel="external">AndroidDemo</a></p>
<h2 id="4-不同类型的拿法(运行时注解)">4.不同类型的拿法(运行时注解)</h2><p>这里特指运行时注解的处理方案,关于编译时注解我会给专门的part内容进行描述</p>
<p>定义注解：</p>
<pre><code><span class="annotation">@Target</span>({ElementType.TYPE,ElementType.METHOD,ElementType.FIELD,ElementType.CONSTRUCTOR})
<span class="annotation">@Retention</span>(RetentionPolicy.RUNTIME)
<span class="keyword">public</span> <span class="annotation">@interface</span> MyAnno {
    <span class="function">String <span class="title">name</span><span class="params">()</span> </span>;
    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;
    <span class="function">Class&lt;Long&gt; <span class="title">gid</span><span class="params">()</span></span>;
}
</code></pre><p>使用注解：</p>
<pre><code><span class="annotation">@MyAnno</span>(name=<span class="string">"type"</span>,gid=Long.<span class="keyword">class</span>)
使用了类注解
public <span class="class"><span class="keyword">class</span> <span class="title">UserAnnotation</span> </span>{

    <span class="comment">//字段</span>
    <span class="annotation">@TestA</span>(name=<span class="string">"param"</span>,id=<span class="number">1</span>,gid=Long.<span class="keyword">class</span>) <span class="comment">// 使用了类成员注解</span>
    private Integer age;

    <span class="comment">//构造器</span>
    <span class="annotation">@TestA</span>(name=<span class="string">"construct"</span>,id=<span class="number">2</span>,gid=Long.<span class="keyword">class</span>)<span class="comment">// 使用了构造方法注解</span>
    public UserAnnotation() {
    }

    <span class="comment">//方法a，b，c</span>
    <span class="annotation">@TestA</span>(name=<span class="string">"public method"</span>, id=<span class="number">3</span>, gid=Long.<span class="keyword">class</span>)<span class="comment">// 使用了 public 方法注解</span>
    public <span class="keyword">void</span> a() {
        <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; m = <span class="keyword">new</span> HashMap&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;(<span class="number">0</span>);
    }

    <span class="annotation">@TestA</span>(name=<span class="string">"protected method"</span>, id=<span class="number">4</span>, gid=Long.<span class="keyword">class</span>)<span class="comment">//protected 方法注解</span>
    protected <span class="keyword">void</span> b() { 
        <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; m = <span class="keyword">new</span> HashMap&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;(<span class="number">0</span>);
    }

    <span class="annotation">@TestA</span>(name=<span class="string">"private method "</span> , id = <span class="number">5</span>, gid=Long.<span class="keyword">class</span>) <span class="comment">// private 方法注解</span>
    private <span class="keyword">void</span> c(){
        <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; m = <span class="keyword">new</span> HashMap&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;(<span class="number">0</span>);
    }

    public <span class="keyword">void</span> b(Integer a){ 
    }
}
</code></pre><p>解析注解:</p>
<h3 id="4-1_解析类上注解">4.1 解析类上注解</h3><pre><code>private void parseTypeAnnotation<span class="params">()</span> throws ClassNotFoundException{
    <span class="comment">//先找到类</span>
    Class clazz = Class.forName<span class="params">(<span class="string">"sabria.demo.annotationdemo.getanno.UserAnnotation"</span>)</span>;
    <span class="comment">//拿到注解器</span>
    Annotation[] annotations = clazz.getAnnotations<span class="params">()</span>;
    <span class="keyword">for</span> <span class="params">(Annotation annotation : annotations)</span> {
        <span class="comment">//拿到类上的注解对象</span>
        MyAnno testA = <span class="params">(MyAnno)</span> annotation;
        say<span class="params">(<span class="string">"type name = "</span> + clazz.getName<span class="params">()</span> + <span class="string">"  |  id = "</span> + testA.id<span class="params">()</span> + <span class="string">"  |  name = "</span> + testA.name<span class="params">()</span> + <span class="string">"  |  　　　　　　　　　　　　　　　　　　　　gid = "</span> + testA.gid<span class="params">()</span>)</span>;
    }
}
</code></pre><p>打印如下:</p>
<blockquote>
<p>01-11 15:24:57.414  25515-25515/sabria.demo.annotationdemo I/MainActivity﹕ type name = sabria.demo.annotationdemo.getanno.UserAnnotation  |  id = 0  |  name = type  | gid = class java.lang.Long</p>
</blockquote>
<h3 id="4-2_解析方法上注解">4.2 解析方法上注解</h3><pre><code>private <span class="type">void</span> parseMethodAnnotation() {
    //拿到<span class="type">UserAnnotation</span>类中的所有方法
    <span class="type">Method</span>[] methods = <span class="type">UserAnnotation</span>.class.getDeclaredMethods();
    //一个一个方法判断
    <span class="keyword">for</span> (<span class="type">Method</span> <span class="keyword">method</span> : methods) {
         /*
         * 判断方法中是否有指定注解类型的注解
         * 方法上面是否有@<span class="type">MyAnno</span>
         */
        boolean hasAnnotation = <span class="keyword">method</span>.isAnnotationPresent(<span class="type">MyAnno</span>.class);
        <span class="keyword">if</span>(hasAnnotation){
            //有的话,拿注解器
            <span class="type">MyAnno</span> annotation = <span class="keyword">method</span>.getAnnotation(<span class="type">MyAnno</span>.class);
            say(<span class="string">"method name = "</span> + <span class="keyword">method</span>.getName() + <span class="string">"  |  id = "</span> +
                    annotation.id() + <span class="string">"  |  description = "</span> + annotation.name() + <span class="string">"  |  gid = "</span> + annotation.gid());
        }
    }
}
</code></pre><p>打印如下:</p>
<blockquote>
<p>01-11 15:24:57.424  25515-25515/sabria.demo.annotationdemo I/MainActivity﹕ method name = a  |  id = 3  |  description = public method  |  gid = class java.lang.Long</p>
<p>01-11 15:24:57.434  25515-25515/sabria.demo.annotationdemo I/MainActivity﹕ method name = b  |  id = 4  |  description = protected method  |  gid = class java.lang.Long</p>
<p>01-11 15:24:57.434  25515-25515/sabria.demo.annotationdemo I/MainActivity﹕ method name = c  |  id = 5  |  description = private method   |  gid = class java.lang.Long</p>
</blockquote>
<h3 id="4-3_解析构造器上注解">4.3 解析构造器上注解</h3><pre><code><span class="keyword">private</span> <span class="built_in">void</span> parseConstructAnnotation() {
    Constructor[] constructors = UserAnnotation.class.getConstructors();
    <span class="keyword">for</span> (Constructor <span class="constructor"><span class="keyword">constructor</span> : constructors) </span>{
            <span class="comment">/*
             * 判断构造方法中是否有指定注解类型的注解
             */</span>
        <span class="built_in">boolean</span> hasAnnotation = <span class="constructor"><span class="keyword">constructor</span>.isAnnotationPresent(MyAnno.class);
        if(hasAnnotation)</span>{
                 <span class="comment">/*
                 * 根据注解类型返回方法的指定类型注解
                 */</span>
            MyAnno annotation = (MyAnno) <span class="constructor"><span class="keyword">constructor</span>.getAnnotation(MyAnno.class);
            say("<span class="keyword">constructor</span> = " + <span class="keyword">constructor</span>.getName()
                    + "   |   id = " + annotation.id() + "  |  description = "
                    + annotation.name() + "  |   gid= "+annotation.gid());
        }
    }
}</span>
</code></pre><p>打印如下:</p>
<blockquote>
<p>01-11 15:30:08.984  30046-30046/sabria.demo.annotationdemo I/MainActivity﹕ constructor = sabria.demo.annotationdemo.getanno.UserAnnotation   |   id = 2  |  description = construct  |   gid= class java.lang.Long</p>
</blockquote>
<h3 id="4-4_解析字段上注解">4.4 解析字段上注解</h3><pre><code>private void parseFieldAnnotation<span class="params">()</span> {

    <span class="comment">//1.拿这个类上的所有字段</span>
    Field[] fields = UserAnnotation.class.getDeclaredFields<span class="params">()</span>;
    <span class="keyword">for</span> <span class="params">(Field field : fields)</span> {
        <span class="comment">//2.该字段上是否有注解</span>
        boolean hasAnnotation = field.isAnnotationPresent<span class="params">(MyAnno.class)</span>;
        <span class="keyword">if</span><span class="params">(hasAnnotation)</span>{
            <span class="comment">//3.拿到注解器对象</span>
            MyAnno annotation = field.getAnnotation<span class="params">(MyAnno.class)</span>;
            say<span class="params">(<span class="string">"Field = "</span> + field.getName<span class="params">()</span>
                    + <span class="string">"  |  id = "</span> + annotation.id<span class="params">()</span> + <span class="string">"  |  description = "</span>
                    + annotation.name<span class="params">()</span> + <span class="string">"  |  gid= "</span>+annotation.gid<span class="params">()</span>)</span>;
        }
    }

}
</code></pre><p>打印如下:</p>
<blockquote>
<p>01-11 15:30:08.994  30046-30046/sabria.demo.annotationdemo I/MainActivity﹕ Field = age  |  id = 1  |  description = param  |  gid= class java.lang.Long</p>
</blockquote>
<p>代码见:</p>
<p>总结:</p>
<ul>
<li>1.拿这个类上的方法或字段;</li>
<li>2.判断方法或者字段上是否有给注解;</li>
<li>3.拿到注解对象,获取值</li>
</ul>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/01/06/ZTN01_2/" itemprop="url">
                【杂谈1月】JobSchedule即将开源
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-01-06T23:47:48+08:00" content="2016-01-06">
            2016-01-06
          </time>
        </span>

        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>即将重磅开源Android后台线程调度类库:JobSchedule</p>
<p>先上一张1个月前画的Jobschedule草图流程.为了这个开源框架准备了1个多月的时间,希望可以为android开源做出贡献.</p>
<p><img src="http://7xn9yd.com1.z0.glb.clouddn.com/766556IMG_0085.JPG" alt=""></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/03/ZTN01_1/" itemprop="url">
                【正谈1月】Java线程范式编程 Part-1
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-03T22:57:48+08:00" content="2015-12-03">
            2015-12-03
          </time>
        </span>

        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>Java线程范式编程 Part-1</p>
<h2 id="1-_创建线程三方案">1. 创建线程三方案</h2><ul>
<li><p><em>通过扩展Thread类来创建多线程:</em></p>
<p>  new MyThread(Runnable).start();</p>
</li>
<li><p><em>通过实现Runnable接口来创建多线程:</em></p>
<p>  new Thread(new MyRunnable()).start();</p>
</li>
<li><p><em>通过实现callable<t>接口</t></em></p>
<p>  class MyTask implements Callable<t><br>  executor.submit(MyTask);</t></p>
</li>
</ul>
<p>方案一和方案二都是没有返回值的,方案三有返回值.</p>
<blockquote>
<p>扩展Thread类:</p>
</blockquote>
<p>1.匿名方案</p>
<pre><code><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        Utils.runContent(MainActivity.<span class="keyword">this</span>);
    }
}).start();
</code></pre><p>2.class方案</p>
<pre><code><span class="keyword">new</span> <span class="type">RunnerThread</span>().start();

<span class="class"><span class="keyword">class</span> <span class="title">RunnerThread</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Thread</span> {</span>
    <span class="annotation">@Override</span>
    public void run() {
        <span class="type">Utils</span>.runContent(<span class="type">MainActivity</span>.<span class="keyword">this</span>);
    }
}
</code></pre><blockquote>
<p>实现Runnable接口</p>
</blockquote>
<pre><code><span class="keyword">new</span> Thread(<span class="keyword">new</span> RunnerRunnable()).start();

<span class="class"><span class="keyword">class</span> <span class="title">RunnerRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        Utils.runContent(MainActivity.<span class="keyword">this</span>);
    }
}
</code></pre><blockquote>
<p>实现callable<t>接口</t></p>
</blockquote>
<pre><code>ExecutorService pool = Executors.newCachedThreadPool();
WorkCallable workCallable = <span class="keyword">new</span> WorkCallable();
Future&lt;Integer&gt; future = pool.submit(workCallable);
Utils.log(<span class="string">"Future运行结果:="</span>+integer);

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>{
    @Override
    <span class="keyword">public</span> Integer call() throws Exception {
        Thread.sleep(<span class="number">1000</span>);
        <span class="keyword">int</span> <span class="keyword">sum</span> = <span class="number">0</span>;
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {
            <span class="keyword">sum</span> = <span class="keyword">sum</span> + i;
        }
        <span class="keyword">return</span> <span class="keyword">sum</span>;
    }
}
</code></pre><h2 id="2-_关键字volatile">2. 关键字volatile</h2><blockquote>
<p>它访问的是原数据而不是拷贝的变量数据</p>
</blockquote>
<p> 线程为了提高效率，将某成员变量(如A)拷贝了一份（如B），线程中对A的访问其实访问的是B。<br> 只在某些动作时才进行A和B的同步。因此存在A和B不一致的情况。volatile就是用来避免这种情况的。<br> volatile告诉jvm， 它所修饰的变量不保留拷贝，直接访问主内存中的（也就是上面说的A)</p>
<p>使用环境场景:主要用在判断变量线程安全方面.</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">volatileKeyWord</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Thread</span> {</span>

    <span class="keyword">private</span>  volatile boolean isRunning = <span class="literal">true</span>;

    <span class="annotation">@Override</span>
    public void run() {
        <span class="keyword">while</span> (isRunning) {
            <span class="type">Log</span>.i(<span class="type">TAG</span>,<span class="string">"Running"</span>+<span class="type">Thread</span>.currentThread().getName());             
            <span class="keyword">try</span> {
                <span class="type">Thread</span>.sleep(<span class="number">50</span>);
            } <span class="keyword">catch</span> (<span class="type">InterruptedException</span> e) {
                e.printStackTrace();
            }
        }
    }

    public  void shutDown() {
        isRunning = <span class="literal">false</span>;
    }
}
</code></pre><h2 id="3-_关键字join">3. 关键字join</h2><blockquote>
<p>3.1 概念:</p>
</blockquote>
<p>thread.Join把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。</p>
<blockquote>
<p>3.2 使用:</p>
</blockquote>
<p>join是Thread类的一个方法，启动线程后直接调用.</p>
<pre><code><span class="type">Thread</span> t = <span class="keyword">new</span> <span class="type">AThread</span><span class="literal">()</span>; 
t.start<span class="literal">()</span>; 
t.join<span class="literal">()</span>;
</code></pre><blockquote>
<p>3.3 为什么要用join()方法:</p>
</blockquote>
<p>在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。</p>
<p>“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行。</p>
<blockquote>
<p>3.4 Code:</p>
</blockquote>
<pre><code><span class="keyword">private</span> <span class="keyword">int</span> count =<span class="number">0</span>;
<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ThreadJoin</span><span class="params">()</span> </span>{
    Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
        @<span class="function">Override
        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
            <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span> ; i &lt;<span class="number">10</span> ; i ++){
                increment(Thread.currentThread().getName());
            }
        }
    });
    thread1.start();

    Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
        @<span class="function">Override
        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
            <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span> ; i &lt;<span class="number">10</span> ; i ++){
                increment(Thread.currentThread().getName());
            }
        }
    });


    <span class="keyword">try</span> {
        thread1.join();
        thread2.start();
        thread2.join();
    } <span class="keyword">catch</span> (InterruptedException e) {
        e.printStackTrace();
    }

    Utils.<span class="built_in">log</span>(<span class="string">"Count is: "</span> + count);

}
</code></pre><p>LogCat：</p>
<pre><code><span class="number">12</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">37.478</span>  <span class="number">24623</span>-<span class="number">24661</span>/sabria.demo.threadpractice I/MainActivity﹕ Thread in Progress: Thread-<span class="number">37224</span> and count is: <span class="number">1</span>
<span class="number">12</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">37.478</span>  <span class="number">24623</span>-<span class="number">24661</span>/sabria.demo.threadpractice I/MainActivity﹕ Thread in Progress: Thread-<span class="number">37224</span> and count is: <span class="number">2</span>
<span class="number">12</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">37.478</span>  <span class="number">24623</span>-<span class="number">24661</span>/sabria.demo.threadpractice I/MainActivity﹕ Thread in Progress: Thread-<span class="number">37224</span> and count is: <span class="number">3</span>
<span class="number">12</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">37.478</span>  <span class="number">24623</span>-<span class="number">24661</span>/sabria.demo.threadpractice I/MainActivity﹕ Thread in Progress: Thread-<span class="number">37224</span> and count is: <span class="number">4</span>
<span class="number">12</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">37.478</span>  <span class="number">24623</span>-<span class="number">24661</span>/sabria.demo.threadpractice I/MainActivity﹕ Thread in Progress: Thread-<span class="number">37224</span> and count is: <span class="number">5</span>
<span class="number">12</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">37.478</span>  <span class="number">24623</span>-<span class="number">24661</span>/sabria.demo.threadpractice I/MainActivity﹕ Thread in Progress: Thread-<span class="number">37224</span> and count is: <span class="number">6</span>
<span class="number">12</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">37.478</span>  <span class="number">24623</span>-<span class="number">24661</span>/sabria.demo.threadpractice I/MainActivity﹕ Thread in Progress: Thread-<span class="number">37224</span> and count is: <span class="number">7</span>
<span class="number">12</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">37.478</span>  <span class="number">24623</span>-<span class="number">24661</span>/sabria.demo.threadpractice I/MainActivity﹕ Thread in Progress: Thread-<span class="number">37224</span> and count is: <span class="number">8</span>
<span class="number">12</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">37.478</span>  <span class="number">24623</span>-<span class="number">24661</span>/sabria.demo.threadpractice I/MainActivity﹕ Thread in Progress: Thread-<span class="number">37224</span> and count is: <span class="number">9</span>
<span class="number">12</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">37.478</span>  <span class="number">24623</span>-<span class="number">24661</span>/sabria.demo.threadpractice I/MainActivity﹕ Thread in Progress: Thread-<span class="number">37224</span> and count is: <span class="number">10</span>
<span class="number">12</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">37.478</span>  <span class="number">24623</span>-<span class="number">24662</span>/sabria.demo.threadpractice I/MainActivity﹕ Thread in Progress: Thread-<span class="number">37225</span> and count is: <span class="number">11</span>
<span class="number">12</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">37.478</span>  <span class="number">24623</span>-<span class="number">24662</span>/sabria.demo.threadpractice I/MainActivity﹕ Thread in Progress: Thread-<span class="number">37225</span> and count is: <span class="number">12</span>
<span class="number">12</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">37.478</span>  <span class="number">24623</span>-<span class="number">24662</span>/sabria.demo.threadpractice I/MainActivity﹕ Thread in Progress: Thread-<span class="number">37225</span> and count is: <span class="number">13</span>
<span class="number">12</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">37.478</span>  <span class="number">24623</span>-<span class="number">24662</span>/sabria.demo.threadpractice I/MainActivity﹕ Thread in Progress: Thread-<span class="number">37225</span> and count is: <span class="number">14</span>
<span class="number">12</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">37.478</span>  <span class="number">24623</span>-<span class="number">24662</span>/sabria.demo.threadpractice I/MainActivity﹕ Thread in Progress: Thread-<span class="number">37225</span> and count is: <span class="number">15</span>
<span class="number">12</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">37.478</span>  <span class="number">24623</span>-<span class="number">24662</span>/sabria.demo.threadpractice I/MainActivity﹕ Thread in Progress: Thread-<span class="number">37225</span> and count is: <span class="number">16</span>
<span class="number">12</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">37.478</span>  <span class="number">24623</span>-<span class="number">24662</span>/sabria.demo.threadpractice I/MainActivity﹕ Thread in Progress: Thread-<span class="number">37225</span> and count is: <span class="number">17</span>
<span class="number">12</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">37.478</span>  <span class="number">24623</span>-<span class="number">24662</span>/sabria.demo.threadpractice I/MainActivity﹕ Thread in Progress: Thread-<span class="number">37225</span> and count is: <span class="number">18</span>
<span class="number">12</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">37.478</span>  <span class="number">24623</span>-<span class="number">24662</span>/sabria.demo.threadpractice I/MainActivity﹕ Thread in Progress: Thread-<span class="number">37225</span> and count is: <span class="number">19</span>
<span class="number">12</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">37.478</span>  <span class="number">24623</span>-<span class="number">24662</span>/sabria.demo.threadpractice I/MainActivity﹕ Thread in Progress: Thread-<span class="number">37225</span> and count is: <span class="number">20</span>
<span class="number">12</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">37.478</span>  <span class="number">24623</span>-<span class="number">24623</span>/sabria.demo.threadpractice I/MainActivity﹕ Count is: <span class="number">20</span>
</code></pre><h2 id="4-_LockObject_加锁机制">4. LockObject 加锁机制</h2><blockquote>
<p>4.1 锁机制目的:</p>
</blockquote>
<p>保证了同步代码在同一时刻只有一个线程在执行。<br>类比于:厕所,在同一时刻只有一个人在使用，多人想进入,里面有一个人在用,其他人必需排队.那个在使用的人,通过厕所门的锁来保证只有自己在使用.</p>
<p>4.2 锁机制方案</p>
<ul>
<li><p><em>1. 在需要同步的方法的方法签名中加入synchronized关键字。</em></p>
<pre><code> <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">synMethod</span><span class="params">()</span> </span>{
    <span class="comment">//方法体</span>
}
</code></pre></li>
<li><p><em>2. 使用synchronized块对需要进行同步的代码段进行同步。</em></p>
<pre><code><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">synMethod</span><span class="params">()</span></span>{
    <span class="keyword">synchronized</span>(syncObject) {
      <span class="comment">//一次只能有一个线程进入</span>
    }
}
</code></pre></li>
<li><p><em>3. 使用JDK 5中提供的java.util.concurrent.lock包中的Lock对象。</em></p>
<pre><code><span class="keyword">private</span> Lock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();
<span class="keyword">private</span> Condition notFull = <span class="keyword">lock</span>.newCondition();
</code></pre></li>
</ul>
<p>4.3 线程安全就是说多线程访问同一代码，不会产生不确定的结果。</p>
<p>并行和并发区别</p>
<p>1、并行是指两者同时执行一件事，比如赛跑，两个人都在不停的往前跑；<br>2、并发是指资源有限的情况下，两者交替轮流使用资源，比如一段路(单核CPU资源)同时只能过一个人，A走一段后，让给B，B用完继续给A ，交替使用，目的是提高效率</p>
<h2 id="5-_ThreadPool线程池">5. ThreadPool线程池</h2><pre><code>ExecutorService executor = Executors.newFixedThreadPool(5)<span class="comment">;</span>
pool.execute(workRunnable)<span class="comment">;</span>
</code></pre><blockquote>
<p>固定大小的线程池:</p>
</blockquote>
<pre><code>ExecutorService executor = Executors.newFixedThreadPool(<span class="number">5</span>);
</code></pre><p>我们创建了包含5个工作线程的固定大小线程池。然后，我们向线程池提交10个任务。由于线程池的大小是5，因此首先会启动5个工作线程，其他任务将进行等待。一旦有任务结束，工作线程会从等待队列中挑选下一个任务并开始执行。</p>
<blockquote>
<p>单任务线程池:</p>
</blockquote>
<pre><code>ExecutorService pool = Executors.newSingleThreadExecutor()<span class="comment">;</span>
</code></pre><p>我们创建了包含1个工作线程的固定大小线程池.由于线程池的大小是1，因此首先会启动1个工作线程，其他任务将进行等待。一旦有任务结束，工作线程会从等待队列中挑选下一个任务并开始执行。</p>
<blockquote>
<p>可变尺寸的线程池:</p>
</blockquote>
<pre><code>ExecutorService pool = Executors.newCachedThreadPool()<span class="comment">;</span>
</code></pre><p>execute多少个runnable就运行多少个任务</p>
<blockquote>
<p>延迟连接池:</p>
</blockquote>
<pre><code>ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">2</span>);
pool.schedule(runnable, <span class="number">10</span>, TimeUnit.MILLISECONDS);

延迟多久后执行任务
</code></pre><blockquote>
<p>自定义线程池:</p>
</blockquote>
<pre><code>ThreadPoolExecutor
<span class="keyword">public</span> ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize,
                          <span class="keyword">int</span> maximumPoolSize,
                          <span class="keyword">long</span> keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&lt;Runnable&gt; workQueue)
</code></pre><p>用给定的初始参数和默认的线程工厂及处理程序创建新的 ThreadPoolExecutor。使用 Executors 工厂方法之一比使用此通用构造方法方便得多。<br>参数：</p>
<pre><code>corePoolSize - 池中所保存的线程数，包括空闲线程。
maximumPoolSize - 池中允许的最大线程数。
keepAliveTime - 当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。
unit - keepAliveTime 参数的时间单位。
workQueue - 执行前用于保持任务的队列。此队列仅保持由<span class="instruction"> execute </span>方法提交的 Runnable 任务。
</code></pre><p>抛出：<br>IllegalArgumentException - 如果 corePoolSize 或 keepAliveTime 小于零，或者 maximumPoolSize 小于或等于零，或者 corePoolSize 大于 maximumPoolSize。</p>
<p>NullPointerException - 如果 workQueue 为 null</p>
<p>AsyncTask的线程池:</p>
<pre><code><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CPU_COUNT = Runtime.getRuntime().availableProcessors();
<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = CPU_COUNT + <span class="number">1</span>;
<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_POOL_SIZE = CPU_COUNT * <span class="number">2</span> + <span class="number">1</span>;
<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEEP_ALIVE = <span class="number">1</span>;
<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadFactory sThreadFactory = <span class="keyword">new</span> ThreadFactory() {
    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger mCount = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);

    <span class="keyword">public</span> <span class="function">Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>{
        <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">"AsyncTask #"</span> + mCount.getAndIncrement());
    }
};
<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; sPoolWorkQueue =
        <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">128</span>);
</code></pre><h2 id="6-1_ExecutorService的生命周期">6-1 ExecutorService的生命周期</h2><p>ExecutorService的生命周期有3种状态:运行、关闭和已终止.</p>
<ul>
<li><p><em>void shutdown()</em> ： 平缓的关闭,不再接收新任务,同时等待已经提交的任务执行完成–包括那些还未开始执行的任务.</p>
</li>
<li><p><em>List<runnable> shutdownNow()</runnable></em> ： 执行粗暴的关闭,将尝试取消所有运行中的任务,并且不再启动队列中尚未开始开始执行的任务.</p>
</li>
<li><p><em>boolean awaitTermination(timeout,unit)</em> : 这个方法有两个参数，一个是timeout即超时时间，另一个是unit即时间单位。这个方法会使线程等待timeout时长，当超过timeout时间后，会监测ExecutorService是否已经关闭，若关闭则返回true，否则返回false。一般情况下会和shutdown方法组合使用。</p>
<pre><code> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> throws IOException, InterruptedException </span>{   
    ExecutorService executor = Executors.newFixedThreadPool(<span class="number">2</span>);   
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {   
        Runnable run = <span class="keyword">new</span> Runnable() {   
            @<span class="function">Override  
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{   
                System.out.println(<span class="string">"thread start"</span>);   
            }   
        };   
        executor.execute(run);   
    }   
    executor.shutdown();   
    <span class="keyword">try</span> {
        executor.awaitTermination(Long.MAX_VALUE, TimeUnit.DAYS); 
    } <span class="keyword">catch</span> (InterruptedException ignored) {
    }        
    System.out.println(<span class="string">"all thread complete"</span>);   
} 
</code></pre></li>
<li><p><em>boolean isShutdown()</em> ： 这个方法在ExecutorService关闭后返回true，否则返回false.</p>
</li>
<li><p><em>boolean isTerminated()</em> ： 这个方法会校验ExecutorService当前的状态是否为“TERMINATED”即关闭状态，当为“TERMINATED”时返回true否则返回false</p>
</li>
</ul>
<p>所以我们在执行完成submit()/execute()后,最好显示的调用shutdown():</p>
<pre><code>executor.submit/execute(worker)<span class="comment">;</span>
executor.shutdown()<span class="comment">;</span>
executor.awaitTermination(1, TimeUnit.DAYS)<span class="comment">;</span>
</code></pre><h2 id="6-2-_pool-execute_和_pool-submit">6-2. pool.execute 和 pool.submit</h2><p>pool.execute(workRunnable); 和 pool.submit(callback/workRunnable)区别</p>
<ul>
<li><em>a.接收的参数不一样</em></li>
<li><em>b.submit有返回值，而execute没有</em></li>
<li><em>c.submit方便Exception处理</em></li>
</ul>
<p>code:</p>
<pre><code><span class="keyword">Future</span>&lt;?&gt; <span class="keyword">future</span> = THREAD_POOL_EXECUTOR.submit(workRunnable);
<span class="keyword">future</span>.get();<span class="comment">//获取任务执行结果</span>
</code></pre><h2 id="7-_Callable、Future和FutureTask">7. Callable、Future和FutureTask</h2><p>创建线程的2种方式，一种是直接继承Thread，另外一种就是实现Runnable接口.<br>这2种方式都有一个缺陷就是：在执行完任务之后无法获取执行结果.</p>
<blockquote>
<p>7.1 callbakc</p>
</blockquote>
<p>//call()函数返回的类型就是传递进来的V类型<br>public interface Callable<v> {<br>    V call() throws Exception;<br>}</v></p>
<p>怎么使用Callable呢？一般情况下是配合ExecutorService来使用的，在ExecutorService接口中声明了若干个submit方法的重载版本.</p>
<p><t> Future<t> submit(Callable<t> task);</t></t></t></p>
<blockquote>
<p>7.2 future</p>
</blockquote>
<p>Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。</p>
<p>1）判断任务是否完成；<br>2）能够中断任务；<br>3）能够获取任务执行结果。</p>
<p>因为Future只是一个接口，所以是无法直接用来创建对象使用的，因此就有了下面的FutureTask。FutureTask是Future接口的一个唯一实现类.</p>
<blockquote>
<p>7.3 futureTask</p>
</blockquote>
<p>FutureTask类实现了RunnableFuture接口</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span><span class="inheritance">&lt;<span class="parent">V</span></span>&gt; <span class="title">implements</span> <span class="title">RunnableFuture</span><span class="inheritance">&lt;<span class="parent">V</span></span>&gt;</span>
</code></pre><p>RunnableFuture继承了Runnable接口和Future接口，而FutureTask实现了RunnableFuture接口。所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>{
    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;
}
</code></pre><p>FutureTask提供了2个构造器：</p>
<pre><code>public <span class="type">FutureTask</span>(<span class="type">Callable</span>&lt;V&gt; callable) {
}
public <span class="type">FutureTask</span>(<span class="type">Runnable</span> runnable, V <span class="literal">result</span>) {
}
</code></pre><blockquote>
<p>7.4 使用</p>
</blockquote>
<p>Callable+Future获取执行结果：</p>
<pre><code><span class="type">ExecutorService</span> executor = <span class="type">Executors</span>.newCachedThreadPool();
<span class="type">Future</span>&lt;<span class="type">Integer</span>&gt; <span class="literal">result</span> = executor.submit(task);
<span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"task运行结果"</span>+<span class="literal">result</span>.get());
</code></pre><p>使用Callable+FutureTask获取执行结果：</p>
<pre><code>ExecutorService executor = Executors.newCachedThreadPool<span class="params">()</span>;
FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;<span class="params">(task)</span>;
executor.submit<span class="params">(futureTask)</span>;
System.out.println<span class="params">(<span class="string">"task运行结果"</span>+futureTask.get<span class="params">()</span>)</span>;
</code></pre><p>或者：</p>
<pre><code>FutureTask&lt;<span class="built_in">Integer</span>&gt; futureTask = <span class="literal">new</span> FutureTask&lt;<span class="built_in">Integer</span>&gt;(task);
<span class="keyword">Thread</span> <span class="keyword">thread</span> = <span class="literal">new</span> <span class="keyword">Thread</span>(futureTask);
<span class="keyword">thread</span><span class="built_in">.</span>start();
</code></pre><p>注意这种方式和第一种方式效果是类似的，只不过一个使用的是ExecutorService，一个使用的是Thread</p>
<p>System.out.println(“task运行结果”+futureTask.get());</p>
<p>其中的task代码：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>{
    @Override
    <span class="keyword">public</span> Integer call() throws Exception {
        System.out.println(<span class="string">"子线程在进行计算"</span>);
        Thread.sleep(<span class="number">3000</span>);
        <span class="keyword">int</span> <span class="keyword">sum</span> = <span class="number">0</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)
            <span class="keyword">sum</span> += i;
        <span class="keyword">return</span> <span class="keyword">sum</span>;
    }
}
</code></pre><h2 id="8-_队列Queue">8. 队列Queue</h2><blockquote>
<p>8.1 概念:</p>
</blockquote>
<p>多数生产消费模型的首选数据结构就是队列(先进先出)。Java提供的线程安全的Queue可以分为阻塞队列和非阻塞队列，<br>其中阻塞队列的典型例子是BlockingQueue，非阻塞队列的典型例子是ConcurrentLinkedQueue，<br>在实际应用中要根据实际需要选用阻塞队列BlockingQueue或者非阻塞队列ConcurrentLinkedQueue。</p>
<p>Queue是什么就不需要多说了吧，一句话：队列是先进先出。相对的，栈是后进先出。</p>
<p>BlockingQueue 一个接口，Java5提供了不同的现实，如ArrayBlockingQueue和LinkedBlockingQueue，两者都是先进先出（FIFO）顺序。<br>而ArrayLinkedQueue是自然有界的，LinkedBlockingQueue可选的边界。</p>
<p>LinkedBlockingQueue<br>由于LinkedBlockingQueue实现是线程安全的，实现了先进先出等特性，是作为生产者消费者的首选，<br>LinkedBlockingQueue 可以指定容量，也可以不指定，不指定的话，默认最大是Integer.MAX_VALUE，<br>其中主要用到put和take方法，put方法在队列满的时候会阻塞直到有队列成员被消费，take方法在队列空的时候会阻塞，直到有队列成员被放进来。</p>
<p>ConcurrentLinkedQueue<br>ConcurrentLinkedQueue是Queue的一个安全实现．Queue中元素按FIFO原则进行排序．采用CAS操作，来保证元素的一致性。<br>LinkedBlockingQueue是一个线程安全的阻塞队列，它实现了BlockingQueue接口，<br>BlockingQueue接口继承自java.util.Queue接口，并在这个接口的基础上增加了take和put方法，这两个方法正是队列操作的阻塞版本。</p>
<p>ArrayBlockingQueue是一个由数组支持的有界阻塞队列。此队列按 FIFO（先进先出）原则对元素进行排序。队列的头部 是在队列中存在时间最长的元素.<br>队列的尾部 是在队列中存在时间最短的元素。新元素插入到队列的尾部，队列获取操作则是从队列头部开始获得元素。</p>
<p>Queue:</p>
<p>1.ArrayDeque, （数组双端队列）<br>2.PriorityQueue, （优先级队列）<br>3.ConcurrentLinkedQueue, （基于链表的并发队列）<br>4.DelayQueue, （延期阻塞队列）（阻塞队列实现了BlockingQueue接口）<br>5.ArrayBlockingQueue, （基于数组的并发阻塞队列）<br>6.LinkedBlockingQueue, （基于链表的FIFO阻塞队列）<br>7.LinkedBlockingDeque, （基于链表的FIFO双端阻塞队列）<br>8.PriorityBlockingQueue, （带优先级的无界阻塞队列）<br>9.SynchronousQueue （并发同步阻塞队列）</p>
<p><a href="http://blog.csdn.net/tayanxunhua/article/details/20962307" target="_blank" rel="external">http://blog.csdn.net/tayanxunhua/article/details/20962307</a></p>
<h2 id="9-_消费者生产者模式">9. 消费者生产者模式</h2><p>一个线程生产,另一个线程消费.</p>
<h3 id="何为生产消费者模式:">何为生产消费者模式:</h3><p>某个模块负责产生数据，这些数据由另一个模块来负责处理（此处的模块是广义的，可以是类、函数、线程、进程等）。产生数据的模块，就形象地称为生产者；而处理数据的模块，就称为消费者。该模式还需要有一个缓冲区处于生产者和消费者之间，作为一个中介。生产者把数据放入缓冲区，而消费者从缓冲区取出数据。</p>
<p>作用:生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。</p>
<p>这个阻塞队列就是用来给生产者和消费者解耦的。</p>
<p><img src="http://i.imgur.com/WHpT8Md.png" alt=""></p>
<p>阻塞指的是暂停一个线程的执行以等待某个条件发生.</p>
<p>基于阻塞队列构建的消费者-生成者模式中,当数据生成时,生成者将数据放入队列,而当消费者准备处理数据时，将从队列中取出数据.<br>生成者和消费者都不需要知道对方的标识或数量，他们只与队列或者缓冲区打交道.</p>
<p><img src="http://i.imgur.com/m0w8V3G.png" alt="一个工作队列"></p>
<p>洗盘工将洗好的盘子放在盘架上,而烘盘工从盘架上取出盘子并把他们烘干。盘架相当于阻塞队列:如果盘架上没有盘子，那么消费者(烘盘工)会一直等到，直到有盘子需要烘干.如果盘架满了,那么那么生成者(洗盘工)会停止清洗直到盘架上有更多的空间。<br>在这里每个工人只需要与盘架打交道,不需要知道有多少生产者或消费者,或者谁生成了某个指定的工作项.</p>
<p>生成者和消费者的角色是相对的,在某个环境中的消费者在另一个环境中可能会成为生成者。</p>
<p><img src="http://i.imgur.com/XlyzjrH.png" alt=""></p>
<p>烘盘工匠消费洗干净的盘子，而产生烘干的盘子，第三人“放盘工”将会把所有烘干的盘子放入厨房橱柜中。在这种情况下烘干盘子的工人既是消费者，也是生成者，从而产生了两个共享的工作队列.每个队列都可能阻塞烘干工作的运行.</p>
<p>生产者与消费者模型中，要保证以下几点： </p>
<ul>
<li>1 同一时间内只能有一个生产者生产     生产方法加锁sychronized </li>
<li>2 同一时间内只能有一个消费者消费     消费方法加锁sychronized </li>
<li>3 生产者生产的同时消费者不能消费     生产方法加锁sychronized </li>
<li>4 消费者消费的同时生产者不能生产     消费方法加锁sychronized </li>
<li>5 共享空间空时消费者不能继续消费     消费前循环判断是否为空，空的话将该线程wait，释放锁允许其他同步方法执行 </li>
<li>6 共享空间满时生产者不能继续生产     生产前循环判断是否为满，满的话将该线程wait，释放锁允许其他同步方法执行    </li>
</ul>
<p>a.经典的方法是使用wait和notify方法在生产者和消费者线程中合作；</p>
<p>b.使用阻塞队列。支持阻塞的方法put()和take()</p>
<p><a href="http://www.cnblogs.com/linjiqin/archive/2013/05/30/3108188.html" target="_blank" rel="external">http://www.cnblogs.com/linjiqin/archive/2013/05/30/3108188.html</a></p>
<p><a href="http://www.cnblogs.com/dolphin0520/p/3920385.html" target="_blank" rel="external">http://www.cnblogs.com/dolphin0520/p/3920385.html</a></p>
<blockquote>
<p>9.1 使用 wait和notify 模拟生产消费者模式</p>
</blockquote>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> waitNotifyPC {

    <span class="keyword">private</span> <span class="keyword">int</span> queueSize = <span class="number">10</span>;
    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; <span class="built_in">queue</span> = <span class="keyword">new</span> PriorityQueue&lt;&gt;(queueSize);


    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startwaitNoticyPC</span><span class="params">()</span></span>{
        <span class="keyword">new</span> Producer().start();
        <span class="keyword">new</span> Consumer().start();
    }

    <span class="keyword">class</span> Consumer extends Thread{
        @<span class="function">Override
        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
            consume();
        }

        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>{
            <span class="keyword">while</span> (<span class="literal">true</span>){
                synchronized (<span class="built_in">queue</span>){
                    <span class="keyword">while</span> (<span class="built_in">queue</span>.size()==<span class="number">0</span>){
                        <span class="keyword">try</span> {
                            Utils.<span class="built_in">log</span>(<span class="string">"队列空，等待数据"</span>);
                            <span class="built_in">queue</span>.wait();
                        } <span class="keyword">catch</span> (InterruptedException e) {
                            e.printStackTrace();
                            <span class="built_in">queue</span>.notify();
                        }
                    }
                    <span class="comment">//每次都移走首元素</span>
                    <span class="built_in">queue</span>.poll();
                    <span class="built_in">queue</span>.notify();
                    Utils.<span class="built_in">log</span>(<span class="string">"从队列取走一个元素，队列剩余"</span> + <span class="built_in">queue</span>.size() + <span class="string">"个元素"</span>);
                }
            }
        }
    }

    <span class="keyword">class</span> Producer extends Thread{
        @<span class="function">Override
        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
            produce();
        }

        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>{
            <span class="keyword">while</span> (<span class="literal">true</span>){
                synchronized (<span class="built_in">queue</span>){
                    <span class="keyword">while</span> (<span class="built_in">queue</span>.size() == queueSize){
                        <span class="keyword">try</span> {
                            Utils.<span class="built_in">log</span>(<span class="string">"队列满，等待有空余空间"</span>);
                            <span class="built_in">queue</span>.wait();
                        } <span class="keyword">catch</span> (InterruptedException e) {
                            e.printStackTrace();
                            <span class="built_in">queue</span>.notify();
                        }
                    }
                    <span class="built_in">queue</span>.offer(<span class="number">1</span>);<span class="comment">//每次插入一个元素</span>
                    <span class="built_in">queue</span>.notify();
                    Utils.<span class="built_in">log</span>(<span class="string">"向队列取中插入一个元素，队列剩余空间："</span> + (queueSize - <span class="built_in">queue</span>.size()));

                }
            }
        }
    }




}
</code></pre><p>LogCat:</p>
<pre><code><span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">59</span>:<span class="number">28.929</span>    <span class="number">4438</span>-<span class="number">4497</span>/sabria.demo.threadpractice I/MainActivity﹕ 队列空，等待数据
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">59</span>:<span class="number">28.929</span>    <span class="number">4438</span>-<span class="number">4495</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">9</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">59</span>:<span class="number">28.929</span>    <span class="number">4438</span>-<span class="number">4497</span>/sabria.demo.threadpractice I/MainActivity﹕ 从队列取走一个元素，队列剩余<span class="number">0</span>个元素
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">59</span>:<span class="number">28.929</span>    <span class="number">4438</span>-<span class="number">4497</span>/sabria.demo.threadpractice I/MainActivity﹕ 队列空，等待数据
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">59</span>:<span class="number">28.929</span>    <span class="number">4438</span>-<span class="number">4495</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">9</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">59</span>:<span class="number">28.929</span>    <span class="number">4438</span>-<span class="number">4495</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">8</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">59</span>:<span class="number">28.929</span>    <span class="number">4438</span>-<span class="number">4495</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">7</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">59</span>:<span class="number">28.929</span>    <span class="number">4438</span>-<span class="number">4495</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">6</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">59</span>:<span class="number">28.929</span>    <span class="number">4438</span>-<span class="number">4495</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">5</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">59</span>:<span class="number">28.929</span>    <span class="number">4438</span>-<span class="number">4495</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">4</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">59</span>:<span class="number">28.929</span>    <span class="number">4438</span>-<span class="number">4497</span>/sabria.demo.threadpractice I/MainActivity﹕ 从队列取走一个元素，队列剩余<span class="number">5</span>个元素
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">59</span>:<span class="number">28.929</span>    <span class="number">4438</span>-<span class="number">4497</span>/sabria.demo.threadpractice I/MainActivity﹕ 从队列取走一个元素，队列剩余<span class="number">4</span>个元素
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">59</span>:<span class="number">28.929</span>    <span class="number">4438</span>-<span class="number">4497</span>/sabria.demo.threadpractice I/MainActivity﹕ 从队列取走一个元素，队列剩余<span class="number">3</span>个元素
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">59</span>:<span class="number">28.929</span>    <span class="number">4438</span>-<span class="number">4497</span>/sabria.demo.threadpractice I/MainActivity﹕ 从队列取走一个元素，队列剩余<span class="number">2</span>个元素
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">59</span>:<span class="number">28.929</span>    <span class="number">4438</span>-<span class="number">4497</span>/sabria.demo.threadpractice I/MainActivity﹕ 从队列取走一个元素，队列剩余<span class="number">1</span>个元素
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">59</span>:<span class="number">28.929</span>    <span class="number">4438</span>-<span class="number">4497</span>/sabria.demo.threadpractice I/MainActivity﹕ 从队列取走一个元素，队列剩余
</code></pre><p>9.2 使用Condition模拟生产消费者模式</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> conditionPC {

    <span class="keyword">private</span> <span class="keyword">int</span> queueSize = <span class="number">10</span>;
    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; <span class="built_in">queue</span> = <span class="keyword">new</span> PriorityQueue&lt;&gt;(queueSize);
    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();
    <span class="keyword">private</span> Condition notFull = lock.newCondition();
    <span class="keyword">private</span> Condition notEmpty = lock.newCondition();


    <span class="comment">/**
     *

     */</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startConditionPC</span><span class="params">()</span> </span>{
        <span class="keyword">new</span> Product().start();

        <span class="keyword">new</span> Consumer().start();

    }


    <span class="keyword">class</span> Product extends Thread {
        @<span class="function">Override
        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
            produce();
        }

        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>{
            <span class="keyword">while</span> (<span class="literal">true</span>) {
                lock.lock();

                <span class="keyword">try</span> {
                    <span class="keyword">while</span> (<span class="built_in">queue</span>.size() == queueSize) {

                        <span class="keyword">try</span> {
                            Utils.<span class="built_in">log</span>(<span class="string">"队列满，等待有空余空间"</span>);
                            notFull.await();
                        } <span class="keyword">catch</span> (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }

                    <span class="built_in">queue</span>.offer(<span class="number">1</span>);<span class="comment">//每次插入一个元素</span>
                    notEmpty.signal();<span class="comment">//对应Object的notify()</span>
                    Utils.<span class="built_in">log</span>(<span class="string">"向队列取中插入一个元素，队列剩余空间："</span> + (queueSize - <span class="built_in">queue</span>.size()));
                } finally {
                    lock.unlock();
                }


            }


        }
    }

    <span class="keyword">class</span> Consumer extends Thread{

        @<span class="function">Override
        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
            consume();
        }

        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>{

            <span class="keyword">while</span> (<span class="literal">true</span>){
                lock.lock();


                <span class="keyword">try</span> {

                    <span class="comment">//队列不为空,就取poll,为空就await</span>
                    <span class="keyword">while</span> (<span class="built_in">queue</span>.size()==<span class="number">0</span>){

                        <span class="keyword">try</span> {

                            Utils.<span class="built_in">log</span>(<span class="string">"队列满，等待有空余空间"</span>);
                            notEmpty.await();

                        } <span class="keyword">catch</span> (InterruptedException e) {
                            e.printStackTrace();
                        }


                    }

                    <span class="built_in">queue</span>.poll();
                    notFull.signal();

                    Utils.<span class="built_in">log</span>(<span class="string">"从队列取走一个元素，队列剩余"</span>+<span class="built_in">queue</span>.size()+<span class="string">"个元素"</span>);

                }finally {
                    lock.unlock();
                }
            }
        }
    }


}
</code></pre><p>LogCat:</p>
<pre><code><span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">9</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">8</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">7</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">6</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">5</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">4</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">3</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">2</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">1</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">0</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 队列满，等待有空余空间
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">813</span>/sabria.demo.threadpractice I/MainActivity﹕ 从队列取走一个元素，队列剩余<span class="number">9</span>个元素
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">813</span>/sabria.demo.threadpractice I/MainActivity﹕ 从队列取走一个元素，队列剩余<span class="number">8</span>个元素
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">813</span>/sabria.demo.threadpractice I/MainActivity﹕ 从队列取走一个元素，队列剩余<span class="number">7</span>个元素
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">813</span>/sabria.demo.threadpractice I/MainActivity﹕ 从队列取走一个元素，队列剩余<span class="number">6</span>个元素
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">813</span>/sabria.demo.threadpractice I/MainActivity﹕ 从队列取走一个元素，队列剩余<span class="number">5</span>个元素
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">813</span>/sabria.demo.threadpractice I/MainActivity﹕ 从队列取走一个元素，队列剩余<span class="number">4</span>个元素
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">813</span>/sabria.demo.threadpractice I/MainActivity﹕ 从队列取走一个元素，队列剩余<span class="number">3</span>个元素
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">813</span>/sabria.demo.threadpractice I/MainActivity﹕ 从队列取走一个元素，队列剩余<span class="number">2</span>个元素
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">813</span>/sabria.demo.threadpractice I/MainActivity﹕ 从队列取走一个元素，队列剩余<span class="number">1</span>个元素
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">813</span>/sabria.demo.threadpractice I/MainActivity﹕ 从队列取走一个元素，队列剩余<span class="number">0</span>个元素
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">813</span>/sabria.demo.threadpractice I/MainActivity﹕ 队列满，等待有空余空间
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">9</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">8</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">7</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">6</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">5</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">4</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">3</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">2</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">1</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">0</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 队列满，等待有空余空间
......
</code></pre><blockquote>
<p>9.3 使用阻塞队列模式模拟生成消费者模式:</p>
</blockquote>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> PCMechanism {

    BlockingQueue&lt;Integer&gt; <span class="built_in">queue</span> = <span class="keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(<span class="number">10</span>);

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startPcM</span><span class="params">()</span></span>{

        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
            @<span class="function">Override
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                <span class="keyword">try</span> {
                    producer();
                } <span class="keyword">catch</span> (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
            @<span class="function">Override
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                <span class="keyword">try</span> {
                    consumer();
                } <span class="keyword">catch</span> (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        thread1.start();
        thread2.start();


    }



    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> throws InterruptedException </span>{
        Random random = <span class="keyword">new</span> Random();
        <span class="keyword">while</span> (<span class="literal">true</span>){
            <span class="built_in">queue</span>.put(random.nextInt(<span class="number">100</span>));
        }

    }

    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> throws InterruptedException </span>{
        Random random = <span class="keyword">new</span> Random();
        <span class="keyword">while</span> (<span class="literal">true</span>){
            Thread.sleep(<span class="number">100</span>);
            <span class="keyword">if</span> (random.nextInt(<span class="number">10</span>) == <span class="number">0</span>) {
                Integer value =  <span class="built_in">queue</span>.take();
                Utils.<span class="built_in">log</span>(<span class="string">"Taken value: "</span> + value + <span class="string">"; Queue size is: "</span> + <span class="built_in">queue</span>.size());
            }
        }
    }


}
</code></pre><p>LogCat:</p>
<pre><code><span class="number">12</span>-<span class="number">17</span> <span class="number">17</span>:<span class="number">07</span>:<span class="number">50.499</span>    <span class="number">9132</span>-<span class="number">9220</span>/sabria.demo.threadpractice I/MainActivity﹕ Taken value: <span class="number">37</span>; Queue size is: <span class="number">10</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">17</span>:<span class="number">07</span>:<span class="number">50.699</span>    <span class="number">9132</span>-<span class="number">9220</span>/sabria.demo.threadpractice I/MainActivity﹕ Taken value: <span class="number">2</span>; Queue size is: <span class="number">9</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">17</span>:<span class="number">07</span>:<span class="number">50.999</span>    <span class="number">9132</span>-<span class="number">9220</span>/sabria.demo.threadpractice I/MainActivity﹕ Taken value: <span class="number">77</span>; Queue size is: <span class="number">10</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">17</span>:<span class="number">07</span>:<span class="number">51.199</span>    <span class="number">9132</span>-<span class="number">9220</span>/sabria.demo.threadpractice I/MainActivity﹕ Taken value: <span class="number">47</span>; Queue size is: <span class="number">10</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">17</span>:<span class="number">07</span>:<span class="number">52.909</span>    <span class="number">9132</span>-<span class="number">9220</span>/sabria.demo.threadpractice I/MainActivity﹕ Taken value: <span class="number">40</span>; Queue size is: <span class="number">9</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">17</span>:<span class="number">07</span>:<span class="number">53.699</span>    <span class="number">9132</span>-<span class="number">9220</span>/sabria.demo.threadpractice I/MainActivity﹕ Taken value: <span class="number">57</span>; Queue size is: <span class="number">9</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">17</span>:<span class="number">07</span>:<span class="number">56.319</span>    <span class="number">9132</span>-<span class="number">9220</span>/sabria.demo.threadpractice I/MainActivity﹕ Taken value: <span class="number">76</span>; Queue size is: <span class="number">9</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">17</span>:<span class="number">07</span>:<span class="number">56.519</span>    <span class="number">9132</span>-<span class="number">9220</span>/sabria.demo.threadpractice I/MainActivity﹕ Taken value: <span class="number">39</span>; Queue size is: <span class="number">10</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">17</span>:<span class="number">07</span>:<span class="number">57.029</span>    <span class="number">9132</span>-<span class="number">9220</span>/sabria.demo.threadpractice I/MainActivity﹕ Taken value: <span class="number">70</span>; Queue size is: <span class="number">10</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">17</span>:<span class="number">07</span>:<span class="number">58.019</span>    <span class="number">9132</span>-<span class="number">9220</span>/sabria.demo.threadpractice I/MainActivity﹕ Taken value: <span class="number">13</span>; Queue size is: <span class="number">10</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">17</span>:<span class="number">07</span>:<span class="number">59.829</span>    <span class="number">9132</span>-<span class="number">9220</span>/sabria.demo.threadpractice I/MainActivity﹕ Taken value: <span class="number">51</span>; Queue size is: <span class="number">9</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">17</span>:<span class="number">08</span>:<span class="number">00.229</span>    <span class="number">9132</span>-<span class="number">9220</span>/sabria.demo.threadpractice I/MainActivity﹕ Taken value: <span class="number">48</span>; Queue size is: <span class="number">9</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">17</span>:<span class="number">08</span>:<span class="number">00.539</span>    <span class="number">9132</span>-<span class="number">9220</span>/sabria.demo.threadpractice I/MainActivity﹕ Taken value: <span class="number">76</span>; Queue size is: <span class="number">9</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">17</span>:<span class="number">08</span>:<span class="number">01.839</span>    <span class="number">9132</span>-<span class="number">9220</span>/sabria.demo.threadpractice I/MainActivity﹕ Taken value: <span class="number">54</span>; Queue size is: <span class="number">10</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">17</span>:<span class="number">08</span>:<span class="number">02.949</span>    <span class="number">9132</span>-<span class="number">9220</span>/sabria.demo.threadpractice I/MainActivity﹕ Taken value: <span class="number">34</span>; Queue size is: <span class="number">9</span>
......
</code></pre></span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/03/ZT12_2/" itemprop="url">
                【正谈12月】动态代理范式编程-Part1
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-03T21:32:48+08:00" content="2015-12-03">
            2015-12-03
          </time>
        </span>

        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="一-代理模式">一.代理模式</h2><p>###1.1 概念</p>
<p><img src="http://i.imgur.com/FBNavuM.jpg" alt=""></p>
<p>对其他对象提供一种代理以控制对这个对象的访问</p>
<p>浅显理解一下：  </p>
<pre><code><span class="literal">A</span> 需要访问 C 
</code></pre><p>—&gt;  </p>
<pre><code>A 通过 <span class="keyword">B </span>间接访问 到C
</code></pre><p>其中的代理B和目标对象C都是实现同一个接口，因此他们可以都彼此了解。</p>
<p>在某些情况下，一个客户不想或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。表面上客户是在访问代理对象，实际代理对象中访问中调用的是目标对象的方法。</p>
<h3 id="2-操作方案：">2.操作方案：</h3><p><img src="http://i.imgur.com/UZEHkFf.png" alt=""></p>
<p>1.定义一个共同型接口</p>
<pre><code><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">CommonInter</span>{                    
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSting</span>(<span class="params"></span>)</span>;        
} 
</code></pre><p>2.实际目标对象</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonInterImp</span>  <span class="keyword">implements</span> <span class="title">CommonInter</span></span>{  

    <span class="annotation">@Override</span>  
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSting</span><span class="params">()</span> </span>{  
        System.out.println(<span class="string">"CommonInterImp"</span>);                
    }  

}      
</code></pre><p>3.创建代理对象</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommProxy</span> <span class="keyword">implements</span> <span class="title">CommonInter</span> </span>{  

    <span class="comment">//多态--持有接口实现对象的引用</span>
    <span class="keyword">private</span> CommonInter commonInter;  

    <span class="function"><span class="keyword">public</span> <span class="title">CommProxy</span><span class="params">()</span></span>{
        <span class="comment">//默认是实现类commonInterImp</span>
        <span class="keyword">this</span>.commonInter = <span class="keyword">new</span> commonInterImp();  
    }  

    <span class="function"><span class="keyword">public</span> <span class="title">CommProxy</span><span class="params">(CommonInter commonInter)</span></span>{ 
        <span class="comment">//其他的任何一个实现类 </span>
        <span class="keyword">this</span>.commonInter = commonInter;  
    }  

    <span class="annotation">@Override</span>  
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSting</span><span class="params">()</span> </span>{  
        <span class="comment">//实际调用的是目标对象的doSting();              </span>
        <span class="keyword">this</span>.commonInter.doSting();  

    }        
}
</code></pre><p>4.调用</p>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
     <span class="comment">//创建代理对象  </span>
     CommProxy proxy = <span class="keyword">new</span> CommProxy();  
     <span class="comment">//表面调用代理对象的方法，实际上代理中是调用的目标对象的方法  </span>
     proxy.doSting();  
}
</code></pre><h2 id="二-动态代理">二.动态代理</h2><h3 id="2-1_概念">2.1 概念</h3><p>在某些情况下，我们A不希望或是不能直接访问对象 C，而是通过访问一个中介对象 B，由 B 去访问 C 达成目的，这种方式我们就称为代理。</p>
<ul>
<li><em>A：工作对象(Client)</em></li>
<li><em>B：代理类(Proxy)</em></li>
<li><em>C：被代理类，委托类，目标对象(RealObject)</em></li>
</ul>
<p>代理优点有：</p>
<pre><code><span class="number">1.</span>隐藏目标对象的实现
<span class="number">2.</span>解耦，不改变目标对象代码情况下做一些额外处理，比如添加初始判断及其他公共操作.
</code></pre><p>一个非常典型的使用场景比如：<br>代理类：</p>
<pre><code><span class="keyword">class</span> <span class="title">CommProxy</span> <span class="title">implements</span> <span class="title">CommInter</span>  {  
    <span class="keyword">private</span> CommonInter impl;

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSting</span>(<span class="params"></span>)  </span>{  
        <span class="keyword">if</span> (impl==<span class="keyword">null</span>)  {  
            impl = <span class="keyword">new</span> commonInterImp();  
        }  
        doBefore();  
        impl.doSting();  
        doAfter();  
    }  
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span>(<span class="params"></span>)  </span>{  
        System.<span class="keyword">out</span>.println(<span class="string">"前置处理！"</span>);  
    }  
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span>(<span class="params"></span>)  </span>{  
        System.<span class="keyword">out</span>.println(<span class="string">"后置处理！"</span>);  
    }  
}
</code></pre><p>静态代理：代理类在程序运行前已经存在的代理方式称为静态代理。</p>
<p>动态代理：代理类在程序运行前不存在、运行时由程序动态生成的代理方式称为动态代理。</p>
<h3 id="2-2_实现动态代理包括三步：">2.2 实现动态代理包括三步：</h3><p>(1). 新建目标对象；</p>
<p>(2). 实现InvocationHandler接口，这是负责连接代理类和目标对象的中间类必须实现的接口；</p>
<p>(3). 通过Proxy类新建代理类对象。</p>
<p>本质：<br>动态代理实现实际是双层的静态代理，开发者提供了目标对象C，程序动态生成了代理类 A：$Proxy。开发者还需要提供一个实现了InvocationHandler的子类 B。B它其实是连接程序自动生成的动态代理类 A 和目标对象 C</p>
<p>工作对象—》调用程序生成的动态代理A—》调用链接子类B—》目标对象C</p>
<h3 id="2-3_几个API参数的含义：">2.3 几个API参数的含义：</h3><p>1.public Object invoke(Object proxy, Method method, Object[] args)  </p>
<pre><code>* <span class="variable">@param</span> proxy 在其上调用方法的代理实例,通过 Proxy.<span class="function">newProxyInstance</span>() 生成的代理类对象：&amp;Proxy
* <span class="variable">@param</span> method 对应于在代理对象&amp;Proxy上调用的接口方法的 Method 实例
* <span class="variable">@param</span> args &amp;Proxy对象的method的参数，如果没有，设为null
</code></pre><p>2.Object result = method.invoke(obj,args);  </p>
<pre><code>* <span class="variable">@param</span> Object receiver 执行这个方法的对象owner,一般创建动态代理时指定的目标对象
* <span class="variable">@param</span> Object... args 方法上的参数
</code></pre><p>3.Proxy.newProxyInstance(cls.getClassLoader(),cls.getInterfaces(),new ProxyInvocationHandler(obj));  </p>
<pre><code>* <span class="variable">@param</span> ClassLoader loader loader表示目标对象的类加载器
* <span class="variable">@param</span> Class&lt;?&gt;[] interfaces interfaces表示目标对象的接口，生成代理类时需要实现这些接口
* <span class="variable">@param</span> InvocationHandler h是InvocationHandler实现类对象，负责连接动态代理类和目标对象的中间类
</code></pre><h3 id="2-4_动态代理范例：">2.4 动态代理范例：</h3><p>1.新建目标对象：</p>
<pre><code><span class="comment">//共同接口对象</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CommonInter</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doString</span><span class="params">()</span></span>;
}

<span class="comment">//目标对象</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonInterImp</span> <span class="keyword">implements</span> <span class="title">CommonInter</span></span>{
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doString</span><span class="params">()</span> </span>{
        System.out.print(<span class="string">"CommonInterImp---doString()"</span>);

    }
}    
</code></pre><p>2.动态角色实现InvocationHandler 接口，它将动态生成代理类。</p>
<pre><code>public class <span class="type">ProxyInvocationHandler</span> implements <span class="type">InvocationHandler</span>{

    private <span class="type">Object</span> obj;

    /**
     * 这里传进来的就是目标对象,它要去调用invoke方法
     * @param obj
     */
    <span class="type">ProxyInvocationHandler</span>(<span class="type">Object</span> obj){
        this.obj=obj;
    }


    /**
     *
     * @param proxy   在其上调用方法的代理实例,通过 <span class="type">Proxy</span>.newProxyInstance() 生成的代理类对象
     * @param <span class="keyword">method</span>  代理对象被调用的函数
     * @param args    代理对象被调用的函数的参数，如果没有，设为null
     * @<span class="keyword">return</span>
     * @throws <span class="type">Throwable</span>
     */
    @<span class="type">Override</span>
    public <span class="type">Object</span> invoke(<span class="type">Object</span> proxy, <span class="type">Method</span> <span class="keyword">method</span>, <span class="type">Object</span>[] args) throws <span class="type">Throwable</span> {
        //前置操作
        doBefore();
        /**
         * @param <span class="type">Object</span> receiver 执行这个方法的对象owner,一般创建动态代理时指定的目标对象
         * @param <span class="type">Object</span>... args 方法上的参数
         */
        <span class="type">Object</span> <span class="literal">result</span>=<span class="keyword">method</span>.invoke(obj,args);
        //后置操作
        doAfter();
        <span class="keyword">return</span> <span class="literal">result</span>;
    }

    /**
     * 工厂
     * @param obj
     * @<span class="keyword">return</span>
     */
    public <span class="keyword">static</span>  <span class="type">Object</span> factory(<span class="type">Object</span> obj){
        <span class="type">Class</span>&lt;?&gt; cls = obj.getClass();
        /**
         * @param <span class="type">ClassLoader</span> loader loader表示类加载器
         * @param <span class="type">Class</span>&lt;?&gt;[] interfaces 表示委托类的接口，生成代理类时需要实现这些接口
         * @param <span class="type">InvocationHandler</span> invocationHandler h是<span class="type">InvocationHandler</span>实现类对象，负责连接代理类和委托类的中间类
         */
        <span class="keyword">return</span> <span class="type">Proxy</span>.newProxyInstance(cls.getClassLoader(),cls.getInterfaces(),new <span class="type">ProxyInvocationHandler</span>(obj));
    }


    private <span class="type">void</span> doBefore() {
        <span class="type">System</span>.<span class="keyword">out</span>.print(<span class="string">"doBefore"</span>);
    }

    private <span class="type">void</span> doAfter() {
        <span class="type">System</span>.<span class="keyword">out</span>.print(<span class="string">"doAfter"</span>);
    }
}
</code></pre><p>3.通过 Proxy 类静态函数生成代理对象</p>
<pre><code>/<span class="keyword">*</span><span class="keyword">*</span>
 <span class="keyword">*</span> 工厂
 <span class="keyword">*</span> <span class="comment">@param obj</span>
 <span class="keyword">*</span> <span class="comment">@return</span>
 <span class="keyword">*</span>/
public static  Object factory(Object obj){
    Class<span class="variable">&lt;?&gt;</span> cls = obj.getClass();
    /<span class="keyword">*</span><span class="keyword">*</span>
    <span class="keyword">*</span> <span class="comment">@param ClassLoader loader loader表示目标对象的类加载器</span>
    <span class="keyword">*</span> <span class="comment">@param Class&lt;?&gt;[] interfaces 表示目标对象的接口，生成代理类时需要实现这些接口</span>
    <span class="keyword">*</span> <span class="comment">@param InvocationHandler invocationHandler h是InvocationHandler实现类对象，负责连接代理类和委托类的中间类</span>
    <span class="keyword">*</span>/
    return Proxy.newProxyInstance(cls.getClassLoader(),cls.getInterfaces(),new ProxyInvocationHandler(obj));
}
</code></pre><p>4.调用：</p>
<pre><code><span class="keyword">private</span> void getDynamicProxy<span class="literal">()</span> {
    <span class="type">CommonInterImp</span> commonInterImp = <span class="keyword">new</span> <span class="type">CommonInterImp</span><span class="literal">()</span>;
    <span class="type">CommonInter</span> tiny = (<span class="type">CommonInter</span>)<span class="type">ProxyInvocationHandler</span>.factory(commonInterImp);
    tiny.doString<span class="literal">()</span>;
}
</code></pre><h3 id="2-5_动态代理在Android中应用的本质">2.5 动态代理在Android中应用的本质</h3><p>所接触到的开源项目中,动态代理都是为封装代码而存在，它将我们需求完成的操作，都通过一句话调用完成：</p>
<p>比如原始HTTP请求Retrofit</p>
<blockquote>
<p>拼接请求 —URL发送HTTP请求—获取JSON —解析JSON为Bean对象 —&gt;显示数据</p>
</blockquote>
<p>Retrofit的动态代理封装了:</p>
<blockquote>
<p>URL发送HTTP请求—&gt; 获取JSON —&gt; 解析JSON为Bean对象</p>
</blockquote>
<p>变成:</p>
<blockquote>
<p>拼接请求 — Retrofit 动态代理 invoke() 完成 通用操作 —&gt;显示数据</p>
</blockquote>
<p>当你调用Retrofit时你要完成的只不过是拼接请求,而后Retrofit的动态代理invoke中完成<br>“使用OKHttp完成网络请求，获取JSON并解析为Bean对象返回”的操作.</p>
<p>最终目的是为了：“代码结构的简化,封装优良调用”的目的.</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/02/ZT12_1/" itemprop="url">
                【正谈12月】取之于开源,必回归于开源
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-02T22:32:48+08:00" content="2015-12-02">
            2015-12-02
          </time>
        </span>

        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>优雅的开源代码到Github,并提供Jcenter下载</p>
<p>##一. 发布项目到Github<br>你会看到无数的如何开源代码到GitHub文章，他们极度强调装逼般的使用命名行配合Git工具的方案来处理代码的上传.不评价这种方案，但在我的理解中,上传代码究竟目的是什么,难道不是为了更方便的维护代码和更新和管理代码吗,Git命令行的方式,很难直观的感知文件的各种Git状态，和选择上传具体哪个文件。并且操作极度麻烦。所以,我们究竟是应该把开源放在秀技术上，还是放在有效优雅的管理代码上.这是个值得深思的问题.本文不会告知你如何装逼的命令行开源代码到GitHub,自己有兴趣去百度吧.<br>我仍然希望我们一定要知道自己要做的这件事的目的是什么,不要本末倒置的来发现和处理问题.</p>
<p><a href="http://blog.csdn.net/deng0zhaotai/article/details/38760883?utm_source=tuicool&amp;utm_medium=referral" title="http://blog.csdn.net/deng0zhaotai/article/details/38760883?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">命令行装逼型文章,请移步此</a></p>
<h3 id="方案_1-1-_通过GitHub配合GitHub-Desktop">方案 1.1. 通过GitHub配合GitHub-Desktop</h3><p>该方案旨在不通过AndroidStudio实现上传代码到GitHub<br>此方法虽然操作比方案2复杂，但通用性强,C代码,python代码,或者任何一门语言的代码都可以这样上传.并可以自己控制目录层级.</p>
<p>操作步骤一：<br>1.在GitHub中New Repositories</p>
<p><img src="http://i.imgur.com/8JR2S9S.png" alt=""></p>
<p><img src="http://i.imgur.com/YHZtZ9X.png" alt=""></p>
<p>注意指定Languages为Android,然后开源许可授权可以指定你希望的授权模式,一般选Apcahe License2.0</p>
<p><a href="http://www.apache.org/licenses/LICENSE-2.0.html" title="Apcahe License2.0" target="_blank" rel="external">Apcahe License2.0协议见此</a></p>
<p><img src="http://i.imgur.com/cFwn08C.png" alt=""></p>
<p>生成的library是空白的,只有需求initialize的README.md.</p>
<p>2.下载并获取GitHub-Desktop软件</p>
<p><a href="https://desktop.github.com/" title="https://desktop.github.com/" target="_blank" rel="external">https://desktop.github.com/</a></p>
<p>3.clone library 到 GitHub-Desktop.</p>
<p><img src="http://i.imgur.com/D7ynkwj.png" alt=""></p>
<p><img src="http://i.imgur.com/pRpUPeh.png" alt=""></p>
<p><img src="http://i.imgur.com/qzMr4gn.png" alt=""></p>
<p>4.在AndroidStudio中完成library</p>
<p><img src="http://i.imgur.com/9xHsFPG.png" alt=""></p>
<p>5.将library的整个文件包复制粘贴到clone library下来的地址中</p>
<p><img src="http://i.imgur.com/T3sVUwr.png" alt=""></p>
<p><img src="http://i.imgur.com/P4E0iXc.png" alt=""></p>
<p><img src="http://i.imgur.com/UANZiA4.png" alt=""></p>
<p>6.此时GitHub-Desktop就会自动感知有文件发生了”Change”</p>
<p><img src="http://i.imgur.com/YGhbiFo.png" alt=""></p>
<p>7.提交并同步到GitHub</p>
<p><img src="http://i.imgur.com/bauziZK.png" alt=""></p>
<p><img src="http://i.imgur.com/O8n8v0X.png" alt=""></p>
<p>自此你就完成了第一次同步代码到GitHub.</p>
<p><img src="http://i.imgur.com/m9oYczn.png" alt=""></p>
<p>若想更新，可以使用Android Stuido import project的方式，这样的话,就将Android Stuido和library的git状态关联起来了.<br>然后每次修改后,在GitHub-Desktop中都会将修改文件状态关联到”Change”,然后更新并同步GitHub就行了.</p>
<h3 id="方案_1-2-_通过AndroidStudio配合GitHub-Desktop">方案 1.2. 通过AndroidStudio配合GitHub-Desktop</h3><p>1.在AndroidStudio中创建一个项目,并选择share 到 GitHub</p>
<p><img src="http://i.imgur.com/Bp5rjkm.png" alt=""></p>
<p>2.初次会让你登陆GitHub</p>
<p><img src="http://i.imgur.com/XjEZhcZ.png" alt=""></p>
<p>3.初次会创建主分支的密码</p>
<p><img src="http://i.imgur.com/Q1L5DRr.png" alt=""></p>
<p>4.初次提交填写描述</p>
<p><img src="http://i.imgur.com/d6Rg2Eu.png" alt=""></p>
<p>此时提交后,就直接发布到了GitHub,同时,在AndroidStudio中就能直接关联到git文件的几种信息状态了.</p>
<p><img src="http://i.imgur.com/dyFX5zZ.png" alt=""></p>
<p>更新的话,就直接在AndroidStuido更新了(就和你平时做项目git管理一样:Add-Commit-Pull)，或者通过GitHub-Desktop,它也会感知”Change”.</p>
<p><img src="http://i.imgur.com/wHZ4GO6.png" alt=""></p>
<p>##二. 上传代码到 Jcenter</p>
<p>我们开源项目后，需要提供Maven或者Gradle compile 地址,比如：</p>
<pre><code><span class="keyword">compile</span> <span class="string">'com.squareup.retrofit:retrofit:2.0.0-beta2'</span>
</code></pre><p>这样其他开放者就可以直接在Build.gradle中导入并编译我们的library.使用bintray将会非常方便的帮助我们完成这项工作.</p>
<p>1.使用github登录<a href="https://bintray.com" target="_blank" rel="external">https://bintray.com</a>;</p>
<p>2.获取：bintray.user  和 bintray.apikey;</p>
<p><img src="http://i.imgur.com/D7HO6Tf.png" alt=""></p>
<p>3.根目录的 local.properties,填写bintray.user和 bintray.apikey.注意请勿上传该文件到github(gitignore忽略这个文件到git );</p>
<p><img src="http://i.imgur.com/4hJmxaK.png" alt=""></p>
<p>4.根目录的 build:gradle 装载bintray插件</p>
<pre><code><span class="keyword">classpath</span> <span class="string">'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.0'</span>
<span class="keyword">classpath</span> <span class="string">'com.github.dcendents:android-maven-gradle-plugin:1.3'</span>
</code></pre><p><img src="http://i.imgur.com/oPpcFm0.png" alt=""></p>
<p>5.在library的build:gradle中  配置library参数,指定项目名称版本号等信息</p>
<p>操作步骤1:引入library plugin</p>
<pre><code><span class="tag">apply</span> <span class="rule"><span class="attribute">plugin</span>:<span class="value"> <span class="string">'com.jfrog.bintray'</span></span></span>
</code></pre><p>操作步骤2：读取local.properties文件中的user和appkey信息</p>
<pre><code><span class="comment">//important</span>
Properties properties = <span class="keyword">new</span> Properties()
properties.load(<span class="keyword">project</span>.rootProject.<span class="keyword">file</span>(<span class="string">'local.properties'</span>).newDataInputStream())

version = <span class="string">"1.0.0"</span><span class="comment">//发布的library的版本号,这个比较关键！！！</span>

<span class="keyword">def</span> siteUrl = <span class="string">'https://github.com/meilishenqi/GradeBar'</span>      <span class="comment">// 项目的主页(可随意，建议填library的github地址)</span>
<span class="keyword">def</span> gitUrl = <span class="string">'https://github.com/meilishenqi/GradeBar'</span>      <span class="comment">// Git仓库的url(可随意，建议填library的github地址)</span>
<span class="keyword">group</span> = <span class="string">"com.mlm.gradebar"</span>    <span class="comment">// 这里是groupId ,必须填写(建议填唯一的包名)</span>

bintray {
    user = properties.getProperty(<span class="string">"bintray.user"</span>) <span class="comment">//读取 local.properties 文件里面的 bintray.user</span>
    key = properties.getProperty(<span class="string">"bintray.apikey"</span>)

    <span class="keyword">configurations</span> = [<span class="string">'archives'</span>]
    pkg {
        repo = <span class="string">"maven"</span>
        <span class="keyword">group</span> = <span class="keyword">group</span>
        name = <span class="string">"gradebar"</span><span class="comment">//发布到JCenter上的项目名字，必须填写</span>
        websiteUrl = siteUrl
        vcsUrl = gitUrl
        licenses = [<span class="string">"Apache-2.0"</span>]
        publish = <span class="keyword">true</span>
    }
}
</code></pre><p><img src="http://i.imgur.com/EIdKKYQ.png" alt=""></p>
<p>操作步骤三(可选):执行install-task<br>如果不执行,不能自动生成pom.xml文件，注意需要装载插件apply plugin: ‘com.github.dcendents.android-maven’，否则无法运行install();</p>
<pre><code><span class="operator"><span class="keyword">install</span> {
    repositories.mavenInstaller {
        // This generates POM.<span class="keyword">xml</span> <span class="keyword">with</span> proper <span class="keyword">parameters</span>
        pom {
            <span class="keyword">project</span> {
                packaging <span class="string">'aar'</span>
                // <span class="keyword">Add</span> your description here
                <span class="keyword">name</span> <span class="string">'The library is a custom view about "Personal center consumption points" in our old version app'</span>     //项目描述
                <span class="keyword">url</span> siteUrl
                // <span class="keyword">Set</span> your license
                licenses {
                    license {
                        <span class="keyword">name</span> <span class="string">'The Apache Software License, Version 2.0'</span>
                        <span class="keyword">url</span> <span class="string">'http://www.apache.org/licenses/LICENSE-2.0.txt'</span>
                    }
                }
                developers {
                    developer {
                        <span class="keyword">id</span> <span class="string">'xiaomeixw'</span>        //开发者的基本信息(建议填自己名称)
                        <span class="keyword">name</span> <span class="string">'xiaomeixw'</span>    //开发者基本信息(建议填自己名称)
                        email <span class="string">'jpxw007@gmail.com'</span>   //开发者基本信息(建议填自己名称)
                    }
                }
                scm {
                    <span class="keyword">connection</span> gitUrl
                    developerConnection gitUrl
                    <span class="keyword">url</span> siteUrl
                }
            }
        }
    }
}</span>
</code></pre><p>5.通过命令行上传项目上传到Bintray</p>
<pre><code>gradlew <span class="keyword">install</span>
</code></pre><p><img src="http://i.imgur.com/8VHsif4.png" alt=""></p>
<pre><code><span class="label">gradlew</span> <span class="keyword">bintrayUpload </span>
</code></pre><p><img src="http://i.imgur.com/oslP3wf.png" alt=""></p>
<p>然后在bintray中查看：</p>
<p><img src="http://i.imgur.com/t2Ojkon.png" alt=""></p>
<p>6.点击Add to JCenter 添加到JCenter,然后填写信息</p>
<p><img src="http://i.imgur.com/FzNLPWu.png" alt=""></p>
<p>问题：1 在bintray点击添加到Add to JCenter</p>
<p>Please fix the following before submitting a JCenter inclusion request</p>
<p><img src="http://i.imgur.com/VcsEvHW.png" alt=""></p>
<p>解决方案一：</p>
<p>Use the non-zipped output or select “explode output” checkbox in the JCenter UI if you are using it.</p>
<p><a href="https://github.com/blundell/release-android-library/issues/3" target="_blank" rel="external">https://github.com/blundell/release-android-library/issues/3</a></p>
<p>其实这种情况产生的原因在于：你gradlew install时没有成功,没有自动生成pom.xml文件,所以导致在bintray中无法正常添加到Jcenter.</p>
<p>解决方案二:在library的build.gradle中添加install-task<br>同时需要添加插件：apply plugin: ‘com.github.dcendents.android-maven’，要不然找不到install().</p>
<pre><code>apply plugin: 'com.github.dcendents.android-maven'

<span class="operator"><span class="keyword">install</span> {
    repositories.mavenInstaller {
        // This generates POM.<span class="keyword">xml</span> <span class="keyword">with</span> proper <span class="keyword">parameters</span>
        pom {
            <span class="keyword">project</span> {
                packaging <span class="string">'aar'</span>
                // <span class="keyword">Add</span> your description here
                <span class="keyword">name</span> <span class="string">'The library is a custom view about "Personal center consumption points" in our old version app'</span>     //项目描述
                <span class="keyword">url</span> siteUrl
                // <span class="keyword">Set</span> your license
                licenses {
                    license {
                        <span class="keyword">name</span> <span class="string">'The Apache Software License, Version 2.0'</span>
                        <span class="keyword">url</span> <span class="string">'http://www.apache.org/licenses/LICENSE-2.0.txt'</span>
                    }
                }
                developers {
                    developer {
                        <span class="keyword">id</span> <span class="string">'xiaomeixw'</span>        //开发者基本信息
                        <span class="keyword">name</span> <span class="string">'xiaomeixw'</span>    //开发者基本信息
                        email <span class="string">'jpxw007@gmail.com'</span>   //开发者基本信息
                    }
                }
                scm {
                    <span class="keyword">connection</span> gitUrl
                    developerConnection gitUrl
                    <span class="keyword">url</span> siteUrl
                }
            }
        }
    }
}</span>
</code></pre><p>然后命令行重新：</p>
<pre><code>gradlew <span class="keyword">install</span>
</code></pre><p>问题：2 在cmd或者Android的命令行中运行gradlew install</p>
<p>FAILURE: Build failed with an exception.  提示出现编码问题</p>
<p><img src="http://i.imgur.com/wmxE2dP.png" alt=""></p>
<p>解决方案：library的build.gradle中添加：</p>
<pre><code><span class="comment">//</span>
<span class="keyword">task</span> javadoc(type: Javadoc) {
    <span class="keyword">source</span> = android.<span class="keyword">sourceSets</span>.main.java.srcDirs
    <span class="keyword">classpath</span> += <span class="keyword">project</span>.files(android.getBootClasspath().<span class="keyword">join</span>(<span class="keyword">File</span>.pathSeparator))
}
javadoc {
    <span class="keyword">options</span>{
        encoding <span class="string">"UTF-8"</span>
        charSet <span class="string">'UTF-8'</span>
        author <span class="keyword">true</span>
        version <span class="keyword">true</span>
        links <span class="string">"http://docs.oracle.com/javase/7/docs/api"</span>
    }
}
</code></pre><p>问题：3 Add To JCenter被拒绝<br>bintray需要四个基本文件才可以提供上传到JCenter服务：</p>
<p><img src="http://i.imgur.com/8qv5q7v.png" alt=""></p>
<ul>
<li><em>pom.xml</em></li>
<li><em>.aar file</em></li>
<li><em>sources jar</em></li>
<li><em>javadoc jar</em></li>
</ul>
<p><img src="http://i.imgur.com/ojjA6ZW.png" alt=""><br>但我第一个上传的版本只有2个文件，还需要sources.jar和javadoc.jar</p>
<p>解决方案在library的build.gradle中添加相关gradle的任务：</p>
<p><a href="http://stackoverflow.com/questions/11474729/how-to-build-sources-jar-with-gradle" target="_blank" rel="external">http://stackoverflow.com/questions/11474729/how-to-build-sources-jar-with-gradle</a></p>
<p>添加生成source.jar 任务：</p>
<pre><code><span class="keyword">task</span> sourcesJar(type: Jar) {
    <span class="keyword">from</span> android.<span class="keyword">sourceSets</span>.main.java.srcDirs
    classifier = <span class="string">'sources'</span>
}
</code></pre><p>添加生成javadoc.jar 任务：</p>
<pre><code><span class="keyword">task</span> javadocJar(type: Jar, dependsOn: javadoc) {
    classifier = <span class="string">'javadoc'</span>
    <span class="keyword">from</span> javadoc.<span class="keyword">destinationDir</span>
}
</code></pre><p>最后：</p>
<pre><code><span class="title">artifacts</span> {
    <span class="title">archives</span> javadocJar
    archives sourcesJar
}
</code></pre><p>再次重新 </p>
<pre><code>gradlew <span class="keyword">install</span>
</code></pre><p>然后上传</p>
<pre><code><span class="label">gradlew</span> <span class="keyword">bintrayUpload </span>
</code></pre><p>如果这次运行提示：</p>
<ul>
<li>What went wrong:<br>Execution failed for task ‘:library:bintrayUpload’.<br>org.apache.http.conn.HttpHostConnectException: Connection to <a href="https://api.bintray.com" target="_blank" rel="external">https://api.bintray.com</a> refused</li>
</ul>
<p>很简单,删除bintray上第一次上传的，然后重新上传运行一次.</p>
<p><img src="http://i.imgur.com/ekharB3.png" alt=""></p>
<p>然后Add To JCenter就可以了</p>
<p>最后附录library的完整build.gradle</p>
<pre><code>apply plugin: <span class="string">'com.android.library'</span>
apply plugin: <span class="string">'com.jfrog.bintray'</span><span class="comment">//improtant</span>
apply plugin: <span class="string">'com.github.dcendents.android-maven'</span><span class="comment">//for javadoc-task</span>


android {
    compileSdkVersion <span class="number">22</span>
    buildToolsVersion <span class="string">"22.0.1"</span>

    defaultConfig {
        minSdkVersion <span class="number">14</span>
        targetSdkVersion <span class="number">22</span>
        versionCode <span class="number">1</span>
        versionName <span class="string">"1.0"</span>
    }
    buildTypes {
        release {
            minifyEnabled <span class="keyword">false</span>
            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span>
        }
    }
}

<span class="keyword">dependencies</span> {
    <span class="keyword">compile</span> <span class="keyword">fileTree</span>(dir: <span class="string">'libs'</span>, <span class="keyword">include</span>: [<span class="string">'*.jar'</span>])
}

<span class="comment">//important</span>
<span class="keyword">task</span> javadoc(type: Javadoc) {
    <span class="keyword">source</span> = android.<span class="keyword">sourceSets</span>.main.java.srcDirs
    <span class="keyword">classpath</span> += <span class="keyword">project</span>.files(android.getBootClasspath().<span class="keyword">join</span>(<span class="keyword">File</span>.pathSeparator))
}
javadoc {
    <span class="keyword">options</span>{
        encoding <span class="string">"UTF-8"</span>
        charSet <span class="string">'UTF-8'</span>
        author <span class="keyword">true</span>
        version <span class="keyword">true</span>
        links <span class="string">"http://docs.oracle.com/javase/7/docs/api"</span>
    }
}

<span class="comment">//important 自动生成pom.xml文件</span>
version = <span class="string">"1.0.0"</span><span class="comment">//发布的library的版本号</span>

<span class="keyword">def</span> siteUrl = <span class="string">'https://github.com/meilishenqi/GradeBar'</span>      <span class="comment">// 项目的主页(可随意)</span>
<span class="keyword">def</span> gitUrl = <span class="string">'https://github.com/meilishenqi/GradeBar'</span>      <span class="comment">// Git仓库的url(可随意)</span>
<span class="keyword">group</span> = <span class="string">"com.mlm.gradebar"</span>    <span class="comment">// 这里是groupId ,必须填写(建议填包名)</span>

install {
    <span class="keyword">repositories</span>.mavenInstaller {
        <span class="comment">// This generates POM.xml with proper parameters</span>
        pom {
            <span class="keyword">project</span> {
                packaging <span class="string">'aar'</span>
                <span class="comment">// Add your description here</span>
                name <span class="string">'The library is a custom view about "Personal center consumption points" in our old version app'</span>     <span class="comment">//项目描述</span>
                url siteUrl
                <span class="comment">// Set your license</span>
                licenses {
                    license {
                        name <span class="string">'The Apache Software License, Version 2.0'</span>
                        url <span class="string">'http://www.apache.org/licenses/LICENSE-2.0.txt'</span>
                    }
                }
                developers {
                    developer {
                        id <span class="string">'xiaomeixw'</span>        <span class="comment">//开发者基本信息</span>
                        name <span class="string">'xiaomeixw'</span>    <span class="comment">//开发者基本信息</span>
                        email <span class="string">'jpxw007@gmail.com'</span>   <span class="comment">//开发者基本信息</span>
                    }
                }
                scm {
                    connection gitUrl
                    developerConnection gitUrl
                    url siteUrl
                }
            }
        }
    }
}

<span class="comment">//生成source.jar</span>
<span class="keyword">task</span> sourcesJar(type: Jar) {
    <span class="keyword">from</span> android.<span class="keyword">sourceSets</span>.main.java.srcDirs
    classifier = <span class="string">'sources'</span>
}

<span class="comment">//生成javadocJar</span>
<span class="keyword">task</span> javadocJar(type: Jar, dependsOn: javadoc) {
    classifier = <span class="string">'javadoc'</span>
    <span class="keyword">from</span> javadoc.<span class="keyword">destinationDir</span>
}

<span class="keyword">artifacts</span> {
    archives sourcesJar
    archives javadocJar
}



<span class="comment">//important读取 local.properties 文件里面的 bintray.user和bintray.apikey</span>
Properties properties = <span class="keyword">new</span> Properties()
properties.load(<span class="keyword">project</span>.rootProject.<span class="keyword">file</span>(<span class="string">'local.properties'</span>).newDataInputStream())


bintray {
    user = properties.getProperty(<span class="string">"bintray.user"</span>)
    key = properties.getProperty(<span class="string">"bintray.apikey"</span>)

    <span class="keyword">configurations</span> = [<span class="string">'archives'</span>]
    pkg {
        repo = <span class="string">"maven"</span>
        <span class="keyword">group</span> = <span class="keyword">group</span>
        name = <span class="string">"gradebar"</span><span class="comment">//发布到JCenter上的项目名字，必须填写</span>
        websiteUrl = siteUrl
        vcsUrl = gitUrl
        licenses = [<span class="string">"Apache-2.0"</span>]
        publish = <span class="keyword">true</span>
    }
}
</code></pre><p>问题四：gradlew install 和 gradlew bintrayUpload 每次都要运行吗？</p>
<p>不是，gradlew install只在第一次运行,如果你提供了完整了四个文件，就无需再运行.</p>
<p>如果要更新version,只需要修改library的build.grade的</p>
<pre><code><span class="keyword">version</span> = <span class="string">"1.0.0"</span><span class="comment">//发布的library的版本号</span>
</code></pre><p>为</p>
<pre><code><span class="keyword">version</span> = <span class="string">"1.0.1"</span><span class="comment">//发布的library的版本号</span>
</code></pre><p>然后</p>
<pre><code><span class="label">gradlew</span> <span class="keyword">bintrayUpload </span>
</code></pre><p>就可以了，发布完成，也不需要 add jcenter, bintray会自动帮你更新version.</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/11/16/ZT11_2/" itemprop="url">
                【正谈11月】链式调用模式封装
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-11-16T22:32:48+08:00" content="2015-11-16">
            2015-11-16
          </time>
        </span>

        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>链式调用模式封装</p>
<p>链式调用以点链形态表现API,最大的优势在于封装接口,API接口简单、使用方便,能够快速的记忆以及快速的拓展API。</p>
<pre><code><span class="tag">Tom</span><span class="class">.with</span>(<span class="tag">context</span>)
      <span class="class">.analyze</span>(<span class="tag">image</span>)
          <span class="class">.perform</span>(<span class="tag">calculus</span>)
                  <span class="class">.showMe</span>(<span class="tag">answer</span>);
</code></pre><blockquote>
<p>It’s like saying: “Tom, analyze this image, perform some calculus and give me the answer!”</p>
</blockquote>
<p>链式调用又分为：</p>
<ul>
<li><p><em>单类链式调用</em>：链式调用的元素都在单个类中完成操作.</p>
</li>
<li><p><em>多类间链式调用</em>：链式调用的元素分布在多个类之间跳转完成.</p>
</li>
<li><p><em>Bilder链式调用</em>：以Builder模式的API风格完成调用.</p>
</li>
</ul>
<h2 id="一-_Single-Chain单类链式调用">一. Single-Chain单类链式调用</h2><p><a href="https://github.com/jcmore2/BannerTime/blob/master/bannertime/src/main/java/com/jcmore2/bannertime/BannerTime.java" title="https://github.com/jcmore2/BannerTime/blob/master/bannertime/src/main/java/com/jcmore2/bannertime/BannerTime.java" target="_blank" rel="external">https://github.com/jcmore2/BannerTime/blob/master/bannertime/src/main/java/com/jcmore2/bannertime/BannerTime.java</a></p>
<pre><code>BannerTime.init<span class="params">(this)</span>
             .shownTime<span class="params">(<span class="number">4000</span>)</span>
             .hiddenTime<span class="params">(<span class="number">3000</span>)</span>
             .imageBanner<span class="params">(<span class="string">"http://pre03.deviantart.net/2aa0/th/pre/f/2012/321/d/1/african_landscape_by_dasflon-d5l9t7c.jpg"</span>)</span>
             .withKOButton<span class="params">()</span>
             .withKOButton<span class="params">()</span>
                        .show<span class="params">()</span>;
</code></pre><p>Single-Chain是指单个类中完成链式调用的构建,它的核心元素就在于:</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MainClass <span class="title">doString</span>(<span class="params">String <span class="keyword">value</span></span>) </span>{
    <span class="keyword">return</span> sInstance;
}
</code></pre><p>返回该类的对象实体.然后通过该对象实体不断的调用里面的方法.每个方法都返回的是对象的实体.</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SingleChain</span> {

    <span class="keyword">private</span> <span class="keyword">static</span> SingleChain sInstance;
    <span class="keyword">private</span> <span class="keyword">static</span> Context mContext;

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> shownTime ;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> hiddenTime ;
    <span class="keyword">private</span> <span class="keyword">static</span> String imageBanner ;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> okVisibility;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> koVisibility;

    <span class="function"><span class="keyword">private</span> <span class="title">SingleChain</span>(<span class="params">Context context</span>) </span>{
        <span class="keyword">try</span> {
            <span class="keyword">if</span> (context == <span class="keyword">null</span>) {
                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cant init, context must not be null"</span>);
            }
        } <span class="keyword">catch</span> (Exception e) {
            e.printStackTrace();
        }
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleChain <span class="title">with</span>(<span class="params">Context context</span>)</span>{
        <span class="keyword">if</span>(sInstance == <span class="keyword">null</span>){
            sInstance = <span class="keyword">new</span> SingleChain(context);
        }
        mContext=context;
        <span class="keyword">return</span> sInstance;
    }


    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleChain <span class="title">shownTime</span>(<span class="params"><span class="keyword">int</span> time</span>) </span>{
        shownTime=time;
        <span class="keyword">return</span> sInstance;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleChain <span class="title">hiddenTime</span>(<span class="params"><span class="keyword">int</span> time</span>) </span>{
        hiddenTime=time;
        <span class="keyword">return</span> sInstance;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleChain <span class="title">imageBanner</span>(<span class="params">String url</span>) </span>{
        imageBanner=url;
        <span class="keyword">return</span> sInstance;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleChain <span class="title">withOKButton</span>(<span class="params"></span>) </span>{
        okVisibility= View.VISIBLE;
        <span class="keyword">return</span> sInstance;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleChain <span class="title">withKOButton</span>(<span class="params"></span>) </span>{
        koVisibility = View.VISIBLE;
        <span class="keyword">return</span> sInstance;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span>(<span class="params"></span>) </span>{

        <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"It´ necessary call '.with()' method"</span>);


        createDialog();
    }

    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createDialog</span>(<span class="params"></span>) </span>{
        <span class="comment">//......</span>
        hanlder content；
        <span class="comment">//......</span>
    }

}
</code></pre><h2 id="二-_multi-Chain单类链式调用">二. multi-Chain单类链式调用</h2><p><a href="https://github.com/xiaomeixw/HappyKandy" title="https://github.com/xiaomeixw/HappyKandy" target="_blank" rel="external">https://github.com/xiaomeixw/HappyKandy</a></p>
<pre><code><span class="tag">HappyKandy</span>
        <span class="class">.load</span>(<span class="tag">bean</span><span class="class">.getImage</span>())
                <span class="class">.setAspectRatio</span>(1<span class="class">.68f</span>)
                        <span class="class">.setGifTrue</span>()
                            <span class="class">.into</span>(<span class="tag">draweeView</span>);
</code></pre><p>multi-Chain是指多个类中之间完成链式调用的构建,它的核心元素就在于:</p>
<pre><code><span class="keyword">Class</span> A  ---&gt;  <span class="keyword">Class</span> B ---&gt; <span class="keyword">Class</span> C
</code></pre><p>其中Class A 和 Class B 都只是封装,真正起代码处理作用的还是Class C:</p>
<p>FrescoManager:</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> FrescoManager {


    /**
     * Initialize Fresco <span class="keyword">in</span> Application
     */
    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> initFresco(Application application){
        Fresco.initialize(application);
    }


    /**
     * Fresco not support relative path,should Absolute path need URI's scheme like <span class="string">"http://"</span> <span class="keyword">or</span> <span class="string">"file://"</span>
     * @param url  (web_image)            http:<span class="comment">//</span>
     *             (local_image)            file:<span class="comment">//</span>
     *             (Content provider)   content:<span class="comment">//</span>
     *             (asset_image)   asset:<span class="comment">//</span>
     *             (res_iamge)     res:<span class="comment">//package/R.drawable.ic_launcher</span>
     * @<span class="keyword">return</span>
     */
    <span class="keyword">public</span> <span class="keyword">static</span> FrescoCreator load(String url){

        FrescoRetriever retriever = FrescoRetriever.get();
        <span class="keyword">return</span> retriever.get(url);
    }

}
</code></pre><p>FrescoRetriever:</p>
<pre><code>public class FrescoRetriever {

   <span class="keyword"> private</span><span class="keyword"> static</span><span class="keyword"> final</span> FrescoRetriever<span class="instruction"> instance </span>=<span class="instruction"> new </span>FrescoRetriever(<span class="function">)</span>;

   <span class="keyword"> private</span> volatile FrescoCreator frescoCreator;

   <span class="keyword"> public</span><span class="keyword"> static</span> FrescoRetriever<span class="function"> get(</span><span class="function">)</span> {
       <span class="instruction"> return </span>instance;
    }

   <span class="keyword"> public</span> FrescoCreator<span class="function"> get(</span>String url<span class="function">)</span> {
       <span class="instruction"> return </span>getFrescoUrl(url<span class="function">)</span>;
    }

   <span class="keyword"> private</span> FrescoCreator<span class="function"> getFrescoUrl(</span>String url<span class="function">)</span> {
       <span class="instruction"> return </span>new<span class="function"> FrescoCreator(</span>url<span class="function">)</span>;
    }

}
</code></pre><p>FrescoCreator：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> FrescoCreator {

    <span class="comment">/**
     * Http or File Url，must begin with http:// or file://
     */</span>
    <span class="keyword">private</span> String mUrl;
    <span class="comment">/**The image control*/</span>
    <span class="comment">//private SimpleDraweeView mImageView;</span>
    <span class="comment">/**
     * Aspect ratio
     */</span>
    <span class="keyword">private</span> <span class="keyword">float</span> mRatio = <span class="number">0.0f</span>;
    <span class="comment">/**
     * whether show gif
     */</span>
    <span class="keyword">private</span> boolean mGif = <span class="literal">false</span>;
    <span class="comment">/**
     * whether set JPEG Progressive shows
     */</span>
    <span class="keyword">private</span> boolean mProJpeg = <span class="literal">false</span>;
    <span class="comment">/**
     * whether set crop
     */</span>
    <span class="keyword">private</span> boolean mCenterCrop = <span class="literal">false</span>;
    <span class="comment">/**
     * whether  set  Aspect ratio
     */</span>
    <span class="keyword">private</span> boolean mRsize = <span class="literal">false</span>;


    <span class="keyword">private</span> <span class="keyword">int</span> mWidth;
    <span class="keyword">private</span> <span class="keyword">int</span> mHeight;

    FrescoCreator(String url) {
        <span class="keyword">this</span>.mUrl = url;
    }


    <span class="function"><span class="keyword">public</span> FrescoCreator <span class="title">setAspectRatio</span><span class="params">(<span class="keyword">float</span> ratio)</span> </span>{
        <span class="keyword">this</span>.mRatio = ratio;
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }

    <span class="function"><span class="keyword">public</span> FrescoCreator <span class="title">setGifTrue</span><span class="params">()</span> </span>{
        <span class="keyword">this</span>.mGif = <span class="literal">true</span>;
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }

    <span class="function"><span class="keyword">public</span> FrescoCreator <span class="title">setProgressiveJPEGTrue</span><span class="params">()</span> </span>{
        <span class="keyword">this</span>.mProJpeg = <span class="literal">true</span>;
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }

    <span class="function"><span class="keyword">public</span> FrescoCreator <span class="title">placeholder</span><span class="params">(<span class="keyword">int</span> drawable)</span> </span>{
        <span class="keyword">this</span>.mPlaceholder = drawable;
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }

    <span class="function"><span class="keyword">public</span> FrescoCreator <span class="title">fail</span><span class="params">(<span class="keyword">int</span> drawable)</span> </span>{
        <span class="keyword">this</span>.mFailImg = drawable;
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }


    <span class="function"><span class="keyword">public</span> FrescoCreator <span class="title">error</span><span class="params">(<span class="keyword">int</span> drawable)</span> </span>{
        <span class="keyword">this</span>.mErrorImg = drawable;
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }

    <span class="function"><span class="keyword">public</span> FrescoCreator <span class="title">centerCrop</span><span class="params">()</span> </span>{
        <span class="keyword">this</span>.mCenterCrop = <span class="literal">true</span>;
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }


    <span class="function"><span class="keyword">public</span> FrescoCreator <span class="title">resize</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>{
        <span class="keyword">this</span>.mRsize = <span class="literal">true</span>;
        <span class="keyword">this</span>.mWidth = width;
        <span class="keyword">this</span>.mHeight = height;
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }


    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">into</span><span class="params">(SimpleDraweeView imageView)</span> </span>{
        Uri uri = getCommonUri(imageView);
        <span class="keyword">if</span> (!mGif) {
            <span class="keyword">if</span> (mRsize) {

                ImageRequest request = ImageRequestBuilder.newBuilderWithSource(uri)
                        .setResizeOptions(<span class="keyword">new</span> ResizeOptions(mWidth, mHeight))
                        .build();
                DraweeController controller = Fresco.newDraweeControllerBuilder()
                        .setImageRequest(request)
                        .build();
                imageView.setController(controller);


            } <span class="keyword">else</span> {
                imageView.setImageURI(uri);
            }

        } <span class="keyword">else</span> {
            DraweeController controller = getGifController(imageView, uri);
            imageView.setController(controller);
        }

    }
}
</code></pre><h2 id="三-_Builder模式链式调用">三. Builder模式链式调用</h2><p>构造器和静态工厂的问题在于无法友善的拓展大量的可选参数.<br>对于参数，一般采用重叠构造器的方法处理，这种过多的参数面临代码难于编写和维护.</p>
<p>构造器多参</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> People {

    <span class="keyword">private</span> <span class="built_in">String</span> mName;<span class="comment">// required</span>
    <span class="keyword">private</span> <span class="built_in">String</span> mSex;<span class="comment">// required</span>

    <span class="keyword">private</span> <span class="built_in">String</span> mAddress;<span class="comment">// optional</span>
    <span class="keyword">private</span> <span class="built_in">String</span> mAge;<span class="comment">// optional</span>
    <span class="keyword">private</span> <span class="built_in">String</span> mProject;<span class="comment">// optional</span>
    <span class="keyword">private</span> <span class="built_in">String</span> mFat;<span class="comment">// optional</span>

    <span class="keyword">public</span> People(<span class="built_in">String</span> name, <span class="built_in">String</span> sex) {
        <span class="keyword">this</span>(name, sex, <span class="string">"USA"</span>);
    }

    <span class="keyword">public</span> People(<span class="built_in">String</span> name, <span class="built_in">String</span> sex, <span class="built_in">String</span> address) {
        <span class="keyword">this</span>(name, sex, address, <span class="string">"20"</span>);
    }

    <span class="keyword">public</span> People(<span class="built_in">String</span> name, <span class="built_in">String</span> sex, <span class="built_in">String</span> address, <span class="built_in">String</span> age) {
        <span class="keyword">this</span>(name, sex, address, age, <span class="string">"shopping,movie,travel"</span>);
    }

    <span class="keyword">public</span> People(<span class="built_in">String</span> name, <span class="built_in">String</span> sex, <span class="built_in">String</span> address, <span class="built_in">String</span> age, 
                    <span class="built_in">String</span> project) {
        <span class="keyword">this</span>(name, sex, address, age, project, <span class="string">"0"</span>);
    }

    <span class="keyword">public</span> People(<span class="built_in">String</span> name, <span class="built_in">String</span> sex, <span class="built_in">String</span> address, <span class="built_in">String</span> age, 
                    <span class="built_in">String</span> project, <span class="built_in">String</span> fat) {
        <span class="keyword">this</span>.mName = name;
        <span class="keyword">this</span>.mSex = sex;
        <span class="keyword">this</span>.mAddress = address;
        <span class="keyword">this</span>.mAge = age;
        <span class="keyword">this</span>.mProject = project;
        <span class="keyword">this</span>.mFat = fat;
    }

}   
</code></pre><p>调用：</p>
<pre><code>People people = <span class="keyword">new</span> People(<span class="string">"Tony"</span>, <span class="string">"man"</span>, <span class="string">" 13 Liverpool Road, 
</span>            Islington, London, London, N1 <span class="number">0</span>RW<span class="string">", "</span><span class="number">32</span><span class="string">", "</span><span class="keyword">read</span><span class="string">", "</span><span class="number">50</span>kg");
</code></pre><p>构造器和静态工厂的问题在于无法友善的拓展大量的可选参数.</p>
<p>所以Builder模式应运而生：</p>
<ul>
<li><em>1.它主要在于将参数分成两种类型，一种是必须的参数，一种是非必需参数;</em></li>
<li><em>2.必需型参数，要做null值判断，同事如果用户外部没有传入，那么就会builder中启用默认型参数;</em></li>
<li><em>3.非必需型可以有也可以无.</em></li>
</ul>
<h2 id="3-1_ExportBuilder">3.1 ExportBuilder</h2><p>不在class中封装Builder,new Builder的操作是在外部(引用API时)直接处理</p>
<h2 id="3-2_PcakageBuilder">3.2 PcakageBuilder</h2><p>直接在calss中封装builder,外部直接不在处理new Builder操作</p>
<p><a href="https://github.com/square/picasso/blob/master/picasso/src/main/java/com/squareup/picasso/Picasso.java" title="https://github.com/square/picasso/blob/master/picasso/src/main/java/com/squareup/picasso/Picasso.java" target="_blank" rel="external">https://github.com/square/picasso/blob/master/picasso/src/main/java/com/squareup/picasso/Picasso.java</a></p>
<pre><code>Picasso.<span class="function"><span class="title">with</span><span class="params">(context)</span></span>
  .<span class="function"><span class="title">load</span><span class="params">(url)</span></span>
  .<span class="function"><span class="title">resize</span><span class="params">(<span class="number">50</span>, <span class="number">50</span>)</span></span>
  .<span class="function"><span class="title">centerCrop</span><span class="params">()</span></span>
  .<span class="function"><span class="title">into</span><span class="params">(imageView)</span></span>
</code></pre><blockquote>
<p>Picasso.with—&gt;new Builder(context)中进行必要参数的非空判断—&gt;.build()进行非必要参数的null赋值—&gt;new Picasso()—&gt;load(url)—&gt;new RequestCreator();</p>
</blockquote>
<p><img src="http://i.imgur.com/WiG5Hdh.png" alt=""></p>
<p>Picasso.class:</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Picasso</span> </span>{

    <span class="keyword">static</span> <span class="keyword">volatile</span> Picasso singleton = <span class="keyword">null</span>;

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Picasso <span class="title">with</span><span class="params">(Context context)</span> </span>{
        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) {
          <span class="keyword">synchronized</span> (Picasso.class) {
            <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) {
              singleton = <span class="keyword">new</span> Builder(context).build();              
            }
          }
        }
        <span class="keyword">return</span> singleton;
      }

     <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>{
        <span class="keyword">private</span> <span class="keyword">final</span> Context context;<span class="comment">// required 必须型参数</span>

        <span class="keyword">private</span> Downloader downloader;<span class="comment">// optional 非必须型参数</span>
        <span class="keyword">private</span> ExecutorService service;<span class="comment">// optional 非必须型参数</span>

        ......

        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(Context context)</span> </span>{
          <span class="comment">//对必须型参数进行null值报错</span>
          <span class="keyword">if</span> (context == <span class="keyword">null</span>) {
            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Context must not be null."</span>);
          }

          <span class="keyword">this</span>.context = context.getApplicationContext();
        }

        <span class="function"><span class="keyword">public</span> Builder <span class="title">downloader</span><span class="params">(Downloader downloader)</span> </span>{
          <span class="keyword">if</span> (downloader == <span class="keyword">null</span>) {
            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Downloader must not be null."</span>);
          }
          <span class="keyword">if</span> (<span class="keyword">this</span>.downloader != <span class="keyword">null</span>) {
            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Downloader already set."</span>);
          }
          <span class="keyword">this</span>.downloader = downloader;
          <span class="keyword">return</span> <span class="keyword">this</span>;
        }

        .......

        <span class="function"><span class="keyword">public</span> Picasso <span class="title">build</span><span class="params">()</span> </span>{
          Context context = <span class="keyword">this</span>.context;

          <span class="comment">//对于非必须性参数进行null赋值</span>
          <span class="keyword">if</span> (downloader == <span class="keyword">null</span>) {
            downloader = Utils.createDefaultDownloader(context);
          }

          <span class="keyword">if</span> (service == <span class="keyword">null</span>) {
            service = <span class="keyword">new</span> PicassoExecutorService();
          }

          .....

          <span class="keyword">return</span> <span class="keyword">new</span> Picasso(context, dispatcher, cache, listener, transformer, requestHandlers, stats,
              defaultBitmapConfig, indicatorsEnabled, loggingEnabled);
        }
      }

    <span class="function"><span class="keyword">public</span> RequestCreator <span class="title">load</span><span class="params">(String path)</span> </span>{
        <span class="keyword">if</span> (path == <span class="keyword">null</span>) {
          <span class="keyword">return</span> <span class="keyword">new</span> RequestCreator(<span class="keyword">this</span>, <span class="keyword">null</span>, <span class="number">0</span>);
        }
        <span class="keyword">if</span> (path.trim().length() == <span class="number">0</span>) {
          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Path must not be empty."</span>);
        }
        <span class="keyword">return</span> load(Uri.parse(path));
      }

}  
</code></pre></span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/10/23/LB_D/" itemprop="url">
                【杂谈10月】Library-Everyday-Gitbook上线
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-10-23T23:45:48+08:00" content="2015-10-23">
            2015-10-23
          </time>
        </span>

        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <p>&emsp;&emsp;其实准确的说应该是今天凌晨1点钟完成上线，今天又用了一天时间完善了昨天(10/22)、今天(10/23)和明天(10/24)三天的library.</p>
<h2 id="1-为什么要做这个gitbook">1.为什么要做这个gitbook</h2><p>&emsp;&emsp;其实之前一直都想把自己每天学习和浏览的印记记录下来，一方面是有时经常fork 优秀的library,隔一段时间就忘记了。二是想做一个不同于其他网站或者博客的library库。</p>
<p>&emsp;&emsp;国内有很多优秀的开源和共享主义者都会经常分享一些优秀的library，但他们的library一般都只分享给中国开发者。我想尝试的是站在中国开发者的角度为老外们来点咱中国人的干货。</p>
<h2 id="2-这个gitbook主要是给中国开发者看的吗，为什么有中文的释义">2.这个gitbook主要是给中国开发者看的吗，为什么有中文的释义</h2><p>&emsp;&emsp;说实话，不是，主要是给老外看的。<br>&emsp;&emsp;中文释义一方面是方便我自己最快速的查看库的内容【苦笑】(谁让我中文这么好)。另一方面是给“英文不比我好”的中国Android开发同仁看的。</p>
<h2 id="3-听说你更新一个AndroidEveryday要花2个小时，不就几个libraries一列举吗,搞怎么麻烦">3.听说你更新一个AndroidEveryday要花2个小时，不就几个libraries一列举吗,搞怎么麻烦</h2><p>&emsp;&emsp;这个要重点解释下，因为为了照顾国外开发者，同时国外很多优秀的文章的图片在国内访问也很慢。鉴于技术网络环境问题。所以我采取的是，将所有的图片都下载或者右键另存为本地资源后，做裁剪和压缩后上传到github或者markdown。有时一排要放两个图片，为了美观我需要将高度都定为同一个值(比如500px)，此时就要用ps或者美图秀秀这样的工具操作咯。其实1个小时不到写完本日的AndroidEveryday，但是要花30多分钟处理图片。同时还要将完成的AndroidEveryday系列Push到3个地方更新：</p>
<pre><code>1<span class="class">.gitHub</span>的<span class="tag">README</span><span class="class">.md</span>
2<span class="class">.gitbook</span>的内页<span class="class">.md</span>
3.个人博客
</code></pre><p>&emsp;&emsp;很多博客的英文原文网站如果不翻墙根本打不开，虽然有VPN，但是速度也不是很快。gitbook的速度即使在VPN下也慢如蜗牛。这种痛苦，作为搞技术的你也是应该懂的。</p>
<p>&emsp;&emsp;同时每周日都需有精心准备的专题策划(先透露下10月25日本周日的第一次“周日策划专题”是我们的Jake Wharton大神周刊，期待哦)。</p>
<pre><code>搜索优秀Library + 排版 + 关键信息整理 + 图片处理 + 更新 = <span class="number">2</span>小时！
</code></pre><p>&emsp;&emsp;所以木办法，精益求精，要做就做好，绝不敷衍！</p>
<h2 id="4-真的是天天更新吗，来源哪里">4.真的是天天更新吗，来源哪里</h2><p>&emsp;&emsp;对，没错，必须的。一方面是提醒自己要有责任心，说出来的话就要做到。另一方面是，一个人在一个领域耕耘7年，就能成为这个领域的专家，坚持不懈的学习很重要。这不仅是份能够养活自己的工作，而且是自己追求开源精神的重要过程。</p>
<p>&emsp;&emsp;来源：(暂时来源，不排除以后收集推荐的)</p>
<pre><code><span class="number">1.</span>自己每天浏览相关技术网站后收集；
<span class="number">2.</span>自己摆弄github search;
<span class="number">3.</span>项目中遇到问题后查询相关信息偶然发现;
</code></pre><h2 id="5-有些英文有些生硬，怕老外看的懂吗">5.有些英文有些生硬，怕老外看的懂吗</h2><p>&emsp;&emsp;说实话是有点担心，不过，英文就这水平，看的”小”懂，发音烂，口齿不清。呵呵，所以笨鸟必须天天飞。</p>
<h2 id="6-同事说：作为搞技术的，你其实文笔不错，说让你出书,你怎么看">6.同事说：作为搞技术的，你其实文笔不错，说让你出书,你怎么看</h2><p>&emsp;&emsp;呵呵，中国国内的一坨烂书，这里抄抄、那里抄抄，只会圈钱，误人子弟。我能力不够，不会出书。做人要对得起自己的良心，自己水平不够，绝不误人子弟，赚黑心钱。</p>
<h2 id="7-未来博客和Gitbook的发展和更新">7.未来博客和Gitbook的发展和更新</h2><p>&emsp;&emsp;首先每天都要更新AndroidEveryday系列.同时还有好几篇博文都欠债下来了。现在公司APP也在开发，比较忙，所以有时请谅解。其次本年一定完成所有的范式编程系列文章。久等了啊！</p>
<p>&emsp;&emsp;最后再次表达下本人的理念：</p>
<pre><code>取之于开源，必最终回归于开源，此谓之：大道！
</code></pre><p>&emsp;&emsp;下面是这三天的AndroidEveryday，算是Demo小样，博客中也雅俗共赏下咯，看看和github的排版有什么不同。</p>
          <div class="post-more-link text-center">
            <a class="btn" href="/2015/10/23/LB_D/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/10/23/ZT11_1/" itemprop="url">
                【正谈10月】Explore NoSql on Android
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-10-23T23:45:48+08:00" content="2015-10-23">
            2015-10-23
          </time>
        </span>

        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <h2 id="一-前言">一.前言</h2><p>D.Richard Hipp不曾想到在这一年他萌芽的轻量级数据库居然诞生在一条漂泊在大海的军舰上，这个诞生于2000年8月的Sqlite数据库由13万行C代码构成,轻量简洁稳定的优势特点,使它经过多年的发展成为Google&amp;Apple在移动端上探索数据库的核心主力，广泛而且大量的被使用。9年后,也就是2009年，NoSql形态数据库被逐渐推上历史的舞蹈核心，Mongodb在服务端架构数据库中大行其道，许多中小型数据库均开始由MySql转向更友好形态的Mongodb.而此时距离iphone1代发布已经过去了整整2年。<br>尽管如此，但在移动端领域NoSql形态数据库仍然还是处于萌芽起步阶段，在写这篇博客时我不经问自己:在Android上探索NoSql型数据库是否为时尚早?也许我们仍然需要时间来检验这个问题和它可能存在的标准答案！</p>
<h2 id="二-何为Nosql">二.何为Nosql</h2><p>泛指非关系型的数据库，关系数据库关注在关系上，NoSQL关注在存储上。<br>NoSQL数据库种类繁多，但是一个共同的特点都是去掉了关系数据库的关系型特性。数据之间无关系，容易扩展。<br>当前主流四种主要形态的NoSql型数据库：</p>
<ul>
<li><em>键值（key-value）比如：Oracle BDB</em></li>
<li><em>列存储数据库 比如：HBase</em></li>
<li><em>文档型数据库 比如：MongoDb</em></li>
<li><em>图形(Graph)数据库 比如：Infinite Graph</em></li>
</ul>
<p>主流的Nosql型数据库在Android端的探索主要是以key-value键值对的形式存在。这一类数据库主要会使用到一个哈希表，这个表中有一个特定的键和一个指针指向特定的数据。Key/value模型对于IT系统来说的优势在于简单、易部署。但是如果DBA只对部分值进行查询或更新的时候，Key/value就显得效率低下了。</p>
<p>使用场景：</p>
<ul>
<li><em>1.取代SP存储；</em></li>
<li><em>2.用于缓存场景.</em></li>
</ul>
          <div class="post-more-link text-center">
            <a class="btn" href="/2015/10/23/ZT11_1/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/10/19/ZT10_3_S/" itemprop="url">
                【正谈10月】Square技术架构
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-10-19T22:45:48+08:00" content="2015-10-19">
            2015-10-19
          </time>
        </span>

        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>一个由Square搭建的‘OK’框架，将构造一套有效的Android架构开发。</p>
<h2 id="背景">背景</h2><p>2015年4月9日Android界的大神Jake Wharton参加Droidcon MTL 2015大会，在会议上他向Andorid开发者展示了Square公司的一套成熟架构，这套架构他们开源并完善了3年多，演讲的主题也便是我们今天要讨论的核心问题：A Few ‘Ok’ Libraries in Square。</p>
<p><img src="http://7xn9yd.com1.z0.glb.clouddn.com/Image%201111113.png" alt=""><br>(话说J神在Square的伙食是不是越来越好了？呵呵{笑脸}…)</p>
<h2 id="A_Few_‘Ok’_Libraries_in_Square">A Few ‘Ok’ Libraries in Square</h2><p><img src="http://i.imgur.com/C3G1yXh.png" alt=""></p>
<blockquote>
<p>*金字塔塔底由Okio替代并延伸java-io;</p>
<p>*网络数据请求层由Okhttp取代HttpClient和HttpURLConnection;</p>
<p>*Json数据转换层由Moshi替代原生json解析;</p>
<p>*表层代码调用层由Retrofit实现REST-API列表。</p>
</blockquote>
<p>======================<br>|    Name  |  Author  |  Description |<br>|    —   |  —     |  —         |<br>|   <a href="https://github.com/square/okio" target="_blank" rel="external">okio</a>    |    <a href="https://github.com/square" target="_blank" rel="external">square</a>    |    [A modern I/O API for Java]    |<br>|   <a href="https://github.com/square/okhttp" target="_blank" rel="external">okhttp</a>    |    <a href="https://github.com/square" target="_blank" rel="external">square</a>    |    [An HTTP+SPDY client for Android and Java applications]    |   <a href="https://github.com/square/moshi" target="_blank" rel="external">moshi</a>    |    <a href="https://github.com/square" target="_blank" rel="external">square</a>    |    [A modern JSON library for Android and Java]   |   <a href="https://github.com/square/retrofit" target="_blank" rel="external">retrofit2</a>    |    <a href="https://github.com/square" target="_blank" rel="external">square</a>    |    [Type-safe HTTP client for Android and Java by Square]        |</p>
<p><img src="http://7xn9yd.com1.z0.glb.clouddn.com/Image222222%204.png" alt=""></p>
<p>这是整体的架构图,四个部成：</p>
<ul>
<li><p>1.DroidconMtl:这个其实不是组成部分，是J神经常技术交流的一个大会的名称，它是加拿大非常有名的一个Android技术交流大会。称它为Android-I/O大会都不为过。所以实际这里的组成是四个包的封装，然后执行调用网络请求代码，也就是我们的代码层面上的东西。这个层级我会给完整的source-demo和notice-tips。</p>
</li>
<li><p>2.Retrofit:调用Retrofit的异步请求逻辑后，封装的是<t>-pojo对象，向下发送逻辑请求。(架构自身完成代码)</t></p>
</li>
<li><p>3.Moshi层，包含Moshi架构本身，以及和Ohttp关联的MoshiConverter解析器。(架构自身完成代码)</p>
</li>
<li><p>4.OKhttp层，就是网络数据的请求层，将请求通过socket最终发送到服务端。(架构自身完成代码)</p>
</li>
</ul>
<p>This talk will be an in-depth look at Okio—a tiny library for interacting with bytes—and a few of the libraries written on top of it: OkHttp, Retrofit, and a newcomer named Moshi.</p>
<p>Okio evolved naturally inside of OkHttp before being split out into its own library. It wraps common patterns behind a friendly API for reading, writing, and processing data. We’ll start with some fundamentals of the library and how it can enable you to work very close to raw data with ease.</p>
<p>After an introduction to Okio, we will look at three libraries written with it: OkHttp, a modern HTTP client; Retrofit, a high-level HTTP wrapper; and Moshi, a brand new library for serialization.</p>
<p>Not only are these libraries powerful on their own, but when combined their efficiency and performance dramatically increase. We’ll conclude with demonstration of how to use them in your applications to great effect.</p>
<p>J神的开场白，不做太直白翻译了，大体的意思就是：会着重描述Okio这个处理字节的类库(读、写和处理data)，同时会介绍OkHttp和Retrofit，以及新类库Moshi。OkHttp是一个现代的标准HTTP请求客户端，Retrofit是一个高级别的Http包装(REST客服端)，Moshi为序列化(其实就就是JSON解析)。这些库单独使用就很强大(powerful),当他们结合时将更效率(efficiency)和性能(performance)提升(increase)。我们将展示如何在你的应用中用好他们。</p>
<p><img src="http://7xn9yd.com1.z0.glb.clouddn.com/Image%20qqqqqq5.png" alt=""></p>
<p><img src="http://7xn9yd.com1.z0.glb.clouddn.com/Image%20qqqqqq6.png" alt=""></p>
<p><img src="http://7xn9yd.com1.z0.glb.clouddn.com/Image%20qqqqqq7.png" alt=""></p>
<p><img src="http://7xn9yd.com1.z0.glb.clouddn.com/Image%20qqqqqqq8.png" alt=""></p>
<h3 id="一-Okio">一.Okio</h3><p>Okio is a new library that complements java.io and java.nio to make it much easier to access, store, and process your data.</p>
<p><a href="https://github.com/square/okio" title="https://github.com/square/okio" target="_blank" rel="external">https://github.com/square/okio</a></p>
<p>Okio是一个对原有的java.io和java.nio进行改进的IO库，使IO操作更加高效和方便。  </p>
<p>1.对数据进行了分块处理，对大数据效率尤为明显;</p>
<p>2.对数据块使用链表进行管理;</p>
<p>3.对闲置的块进行管理，通过一个块池（SegmentPool）的管理，避免系统GC和申请byte时的zero-fill。</p>
<p>4.它对数据的读取写入进行了封装;</p>
<p>5.超时操作;</p>
<h2 id="ByteStrings_and_Buffers">ByteStrings and Buffers</h2><p>Okio is built around two types that pack a lot of capability into a straightforward API:</p>
<ul>
<li>[<strong>ByteString</strong>][3] is an immutable sequence of bytes. For character data, <code>String</code><br>is fundamental. <code>ByteString</code> is String’s long-lost brother, making it easy to<br>treat binary data as a value. This class is ergonomic: it knows how to encode<br>and decode itself as hex, base64, and UTF-8.</li>
</ul>
<p>ByteString是一个固定大小的byte序列（由一个byte数组构成）。String是Java经常使用到的一个基本类型，ByteString对String进行了封装，为byte和String间的转换和String不同值间的转换（UTF-8编解码，Hex编解码，Base64编解码，ASCIll编解码）提供了十分方便的操作。</p>
<ul>
<li>[<strong>Buffer</strong>][4] is a mutable sequence of bytes. Like <code>ArrayList</code>, you don’t need<br>to size your buffer in advance. You read and write buffers as a queue: write<br>data to the end and read it from the front. There’s no obligation to manage<br>positions, limits, or capacities.</li>
</ul>
<p>Buffer是一个不固定大小的byte序列（由一个节点为Segment的双向循环队列链表构成），它充当Sink、Source、InputStream和OutputStream间的高效缓存区，由于Buffer实现了BufferedSource和BufferedSink这两个接口，所以可以很方便的对其进行IO操作。Buffer在多线程编程里很有用，比如一个负责网络的线程可以通过这种方式和工作线程进行数据交换，但是又不发生数据的复制。</p>
<h2 id="Sources_and_Sinks">Sources and Sinks</h2><p>Okio的流类型：<br>Okio includes its own stream types called Source and Sink that work like InputStream and OutputStream。</p>
<ul>
<li><p>接口[<strong>Sink</strong>]，[<strong>BufferedSink</strong>]<br>Sink和java.io中的OutputStream类似，BufferedSink是一个对Sink进行扩展的接口。使用OutputStream时，在传输不同的数据是需要对OutputStream进行不同的包装，比如用DataOutputStream进行原始数据的IO，用BufferedOutputStream进行带缓存的数据IO，用OutputStreamWriter进行字符编码。对于Sink来说，只需要使用BufferedSink就可以实现以上所有的情况。</p>
</li>
<li><p>接口[<strong>Source</strong>]，[<strong>BufferedSource</strong>]<br>Source和java.io中的InputStream类似，BufferedSource是一个对Source进行扩展的接口。使用InputStream时，在传输不同的数据是需要对InputStream进行不同的包装，比如用DataInputStream进行原始数据的IO，用BufferedInputStream进行带缓存的数据IO，用OutputStreamReader进行字符编码。对于Source来说，只需要使用BufferedSource就可以实现以上所有的情况。</p>
</li>
</ul>
<p>Sources and sinks interoperate with InputStream and OutputStream. You can view any Source as an InputStream, and you can view any InputStream as a Source. Similarly for Sink and OutputStream.</p>
<h2 id="API：">API：</h2><p><img src="http://7xn9yd.com1.z0.glb.clouddn.com/736443Image2222%201.png" alt=""></p>
<p>首先来看如何获取Source、Sink和Buffer、ByteString对象</p>
<p><img src="http://7xn9yd.com1.z0.glb.clouddn.com/736443QQQImage%202.png" alt=""></p>
<pre><code><span class="comment">//Source和java.io中的InputStream类似</span>
<span class="keyword">Source</span> <span class="keyword">source</span> = Okio.<span class="keyword">source</span>(InputStream)；
</code></pre><p><img src="http://7xn9yd.com1.z0.glb.clouddn.com/736443qqqqImage%205.png" alt=""></p>
<pre><code><span class="comment">//BufferedSource是一个对Source进行扩展的接口。</span>
BufferedSource pngSource = Okio.buffer(Okio.<span class="keyword">source</span>(<span class="keyword">in</span>));
</code></pre><p><img src="http://7xn9yd.com1.z0.glb.clouddn.com/736443zzzzmage%209.png" alt=""><br><img src="http://7xn9yd.com1.z0.glb.clouddn.com/736443aaaaImage%207.png" alt=""><br><img src="http://7xn9yd.com1.z0.glb.clouddn.com/736443aaaaImage%206.png" alt=""><br><img src="http://7xn9yd.com1.z0.glb.clouddn.com/736443啊啊啊啊Image%208.png" alt=""></p>
<pre><code><span class="comment">// Each chunk is a length, type, data, and CRC offset.</span>
<span class="keyword">int</span> <span class="built_in">length</span> = pngSource.readInt();
String type = pngSource.readUtf8(<span class="number">4</span>);
pngSource.readFully(chunk, <span class="built_in">length</span>);
<span class="keyword">int</span> crc = pngSource.readInt();
</code></pre><p>一般获取Buffer及读取UTF-8字符串文件再获取为inputStream：<br><img src="http://7xn9yd.com1.z0.glb.clouddn.com/736443额Image%2010.png" alt=""><br><img src="http://7xn9yd.com1.z0.glb.clouddn.com/736443tttttImage%2012.png" alt=""><br><img src="http://7xn9yd.com1.z0.glb.clouddn.com/736443ttttttImage%2011.png" alt=""></p>
<pre><code>SSLSocketFactory sslSocketFactory = SSLUtil.getSSLSocketFactory<span class="params">(new Buffer<span class="params">()</span>.writeUtf8<span class="params">(CERT)</span>.inputStream<span class="params">()</span>)</span>;
client.setSslSocketFactory<span class="params">(sslSocketFactory)</span>;
</code></pre><h2 id="OKIO使用：">OKIO使用：</h2><p>根据PNG文件署名域判断一个图片是否是真实PNG：</p>
<pre><code><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ByteString PNG_HEADER=ByteString.decodeHex(<span class="string">"89504e470d0a1a0a"</span>);

<span class="keyword">public</span> <span class="keyword">boolean</span> isPng(InputStream in) <span class="keyword">throws</span> IOException {
  BufferedSource pngSource = Okio.buffer(Okio.<span class="keyword">source</span>(in));

  ByteString header = pngSource.readByteString(PNG_HEADER.<span class="keyword">size</span>());
  <span class="keyword">if</span> (!header.equals(PNG_HEADER)) {
    <span class="keyword">return</span> <span class="keyword">false</span>;
  }<span class="keyword">else</span>{
    <span class="keyword">return</span> <span class="keyword">true</span>;    
  }

}
</code></pre><h3 id="二-Okhttp">二.Okhttp</h3><h3 id="三-Moshi">三.Moshi</h3><h3 id="四-Retrofit">四.Retrofit</h3><p>Retrofit现在分两个版本，一个是2.0前版本，比如1.9-，还有一个就是升级的Retrofit2。Retrofit2内部的核心代码都重新架构过,最主要的是直接支持了更多的json解析框架，API调用虽然有小变化，但整体变化不大。</p>
<p>所以我现在这里的介绍的就是最新的Retrofit2的内容，因为1.9或1.9-将渐渐成为历史。</p>
<h4 id="retrofit完成请求">retrofit完成请求</h4><p>1.Application中初始化创建Retrofit实例：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SnakeService</span> </span>{
    <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>{
        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SnakeService <span class="title">create</span><span class="params">()</span> </span>{
            Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()
                    .baseUrl(<span class="string">"http://www.xxxxx.com/v6/"</span>)                      
                    .addConverterFactory(MoshiConverterFactory.create())
                    .build();
            <span class="keyword">return</span> retrofit.create(SnakeService.class);
        }
    }
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>{

    <span class="keyword">private</span> SnakeService snakeService;

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>{
        <span class="keyword">super</span>.onCreate();
        initService();
    }


    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initService</span><span class="params">()</span> </span>{
        <span class="keyword">this</span>.snakeService = SnakeService.Factory.create();
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyApplication <span class="title">get</span><span class="params">(Context context)</span> </span>{
        <span class="keyword">return</span> (MyApplication) context.getApplicationContext();
    }

    <span class="function"><span class="keyword">public</span> SnakeService <span class="title">getSnakeService</span><span class="params">()</span> </span>{
        <span class="keyword">if</span>(snakeService==<span class="keyword">null</span>){
             snakeService=SnakeService.Factory.create();
        }
        <span class="keyword">return</span> snakeService;
    }
}
</code></pre><p>2.定义接口</p>
<pre><code><span class="variable">@POST</span>(<span class="string">"tehui/getTehuiByJigouId"</span>)
Call&lt;JsonFather&gt; <span class="function">loadData</span>(<span class="variable">@QueryMap</span> Map&lt;String, String&gt; map);


<span class="variable">@POST</span>(<span class="string">"tehui/getTehuiByJigouId"</span>)
Call&lt;ResponseBody&gt; <span class="function">loadData2</span>(<span class="variable">@QueryMap</span> Map&lt;String, String&gt; map);
</code></pre><p>3.根据返回的json串创建json-bean对象</p>
<p>这是我服务器返回的Json:</p>
<pre><code>{
    "<span class="attribute">state</span>": <span class="value"><span class="string">"000"</span></span>,
    "<span class="attribute">t_rs</span>": <span class="value">[
        {
            "<span class="attribute">id</span>": <span class="value"><span class="string">"1422"</span></span>,
            "<span class="attribute">title</span>": <span class="value"><span class="string">"[ 上海万安 ]360艺术美鼻"</span></span>,
            "<span class="attribute">image</span>": <span class="value"><span class="string">"http://tehui.meilimei.com/static/team/2015/0612/14340889238311.jpg?201510201128"</span></span>,
            "<span class="attribute">team_price</span>": <span class="value"><span class="string">"500.00"</span></span>,
            "<span class="attribute">now_number</span>": <span class="value"><span class="string">"1"</span></span>,
            "<span class="attribute">market_price</span>": <span class="value"><span class="string">"22800.00"</span></span>,
            "<span class="attribute">delivery</span>": <span class="value"><span class="string">"coupon"</span></span>,
            "<span class="attribute">deposit</span>": <span class="value"><span class="string">"500.00"</span></span>,
            "<span class="attribute">mechanism</span>": <span class="value"><span class="string">"上海万安医疗美容医院"</span></span>,
            "<span class="attribute">flag</span>": <span class="value"><span class="number">1</span>
        </span>},
        {
            "<span class="attribute">id</span>": <span class="value"><span class="string">"1602"</span></span>,
            "<span class="attribute">title</span>": <span class="value"><span class="string">"[ 上海万安 ]瑞兰玻尿酸注射 不开刀就能美美哒的秘密"</span></span>,
            "<span class="attribute">image</span>": <span class="value"><span class="string">"http://tehui.meilimei.com/static/team/2015/0624/14351340349342.jpg?201510201128"</span></span>,
            "<span class="attribute">team_price</span>": <span class="value"><span class="string">"300.00"</span></span>,
            "<span class="attribute">now_number</span>": <span class="value"><span class="string">"4"</span></span>,
            "<span class="attribute">market_price</span>": <span class="value"><span class="string">"3800.00"</span></span>,
            "<span class="attribute">delivery</span>": <span class="value"><span class="string">"coupon"</span></span>,
            "<span class="attribute">deposit</span>": <span class="value"><span class="string">"300.00"</span></span>,
            "<span class="attribute">mechanism</span>": <span class="value"><span class="string">"上海万安医疗美容医院"</span></span>,
            "<span class="attribute">flag</span>": <span class="value"><span class="number">1</span>
        </span>},
        {
            "<span class="attribute">id</span>": <span class="value"><span class="string">"1603"</span></span>,
            "<span class="attribute">title</span>": <span class="value"><span class="string">"[ 上海万安 ]韩式半永久定妆"</span></span>,
            "<span class="attribute">image</span>": <span class="value"><span class="string">"http://tehui.meilimei.com/static/team/2015/0624/14351340357063.jpg?201510201128"</span></span>,
            "<span class="attribute">team_price</span>": <span class="value"><span class="string">"100.00"</span></span>,
            "<span class="attribute">now_number</span>": <span class="value"><span class="string">"8"</span></span>,
            "<span class="attribute">market_price</span>": <span class="value"><span class="string">"3800.00"</span></span>,
            "<span class="attribute">delivery</span>": <span class="value"><span class="string">"coupon"</span></span>,
            "<span class="attribute">deposit</span>": <span class="value"><span class="string">"100.00"</span></span>,
            "<span class="attribute">mechanism</span>": <span class="value"><span class="string">"上海万安医疗美容医院"</span></span>,
            "<span class="attribute">flag</span>": <span class="value"><span class="number">1</span>
        </span>}
    ]
</span>}
</code></pre><p>注：<a href="http://www.jsonschema2pojo.org/" target="_blank" rel="external">http://www.jsonschema2pojo.org/</a>   使用它将方便的帮助你将json转成pojo代码。</p>
<p>json-bean:</p>
<pre><code>public class JsonFather extends BaseInfoBen{

    private String <span class="keyword">state</span>;

    private String notice;

    public String getNotice() {
        return notice;
    }

    public void <span class="built_in">set</span>Notice(String notice) {
        this.notice = notice;
    }

    private List<span class="variable">&lt;NewHuiListInfo&gt;</span> t_rs = new ArrayList<span class="variable">&lt;NewHuiListInfo&gt;</span>();


    public String getState() {
        return <span class="keyword">state</span>;
    }

    public List<span class="variable">&lt;NewHuiListInfo&gt;</span> getT_rs() {
        return t_rs;
    }

    public void <span class="built_in">set</span>T_rs(List<span class="variable">&lt;NewHuiListInfo&gt;</span> t_rs) {
        this.t_rs = t_rs;
    }

    public void <span class="built_in">set</span>State(String <span class="keyword">state</span>) {
        this.<span class="keyword">state</span> = <span class="keyword">state</span>;
    }

}
</code></pre><p>4.异步调用</p>
<pre><code><span class="keyword">private</span> <span class="keyword">void</span> getData() {

    <span class="keyword">final</span> <span class="keyword">HashMap</span>&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();
    <span class="built_in">map</span>.put(<span class="string">"jigou_id"</span>, <span class="string">"372759"</span>);
    <span class="built_in">map</span>.put(<span class="string">"page"</span>, <span class="string">"1"</span>);
    <span class="built_in">map</span>.put(<span class="string">"signapp"</span>, MD5);

    Call&lt;JsonFather&gt; listCall = MyApplication.<span class="built_in">get</span>(context).getSnakeService().loadData(Collections.unmodifiableMap(<span class="built_in">map</span>));

    listCall.enqueue(<span class="keyword">new</span> Callback&lt;JsonFather&gt;() {



        <span class="comment">//main thread</span>
        @Override
        <span class="keyword">public</span> <span class="keyword">void</span> onResponse(Response&lt;JsonFather&gt; response, Retrofit retrofit) {
            JsonFather body = response.body();
            List&lt;NewHuiListInfo&gt; t_rs = body.getT_rs();
            <span class="keyword">if</span>(<span class="keyword">null</span>==body){
                Toast.makeText(context, <span class="string">"null"</span>, Toast.LENGTH_LONG).show();
            }<span class="keyword">else</span>{
                tvText.setText(t_rs.<span class="built_in">get</span>(<span class="number">0</span>).getImage());
            }              
        }

        <span class="comment">//main thread</span>
        @Override
        <span class="keyword">public</span> <span class="keyword">void</span> onFailure(Throwable throwable) {
            Toast.makeText(context, <span class="string">"onFailure:"</span>+throwable.toString(), Toast.LENGTH_LONG).show();
        }
    });

}
</code></pre><h4 id="核心Tips">核心Tips</h4><p>Tips1.如何添加@GET\@POST请求的参数：</p>
<pre><code>使用<span class="variable">@QueryMap</span>   或者  <span class="variable">@Query</span>
</code></pre><p>Tips2.如何定义 Endpoints</p>
<p>@Path用于url地址上可变的参数量</p>
<pre><code><span class="variable">@GET</span>(<span class="string">"/users/{username}"</span>)
Call&lt;User&gt; <span class="function">getUser</span>(<span class="variable">@Path</span>(<span class="string">"username"</span>) String username);
</code></pre><p>@Query用于一个请求参数   @QueryMap用于封装成map的请求参数组</p>
<pre><code><span class="variable">@GET</span>(<span class="string">"bestof"</span>)
Observable&lt;Feed&gt; <span class="function">bestof</span>(<span class="variable">@Query</span>(<span class="string">"tags"</span>) String tags,
                        <span class="variable">@Query</span>(<span class="string">"user"</span>) String user,
                        <span class="variable">@Query</span>(<span class="string">"flags"</span>) int flags,
                        <span class="variable">@Query</span>(<span class="string">"older"</span>) Long older,
                        <span class="variable">@Query</span>(<span class="string">"score"</span>) int benisScore);

<span class="variable">@GET</span>(<span class="string">"/group/{id}/users"</span>)
Call&lt;List&lt;User&gt;&gt; <span class="function">groupList</span>(<span class="variable">@Path</span>(<span class="string">"id"</span>) int groupId, <span class="variable">@Query</span>(<span class="string">"sort"</span>) String sort);

<span class="variable">@POST</span>(<span class="string">"tehui/getTehuiByJigouId"</span>)
Call&lt;JsonFather&gt; <span class="function">loadData</span>(<span class="variable">@QueryMap</span> Map&lt;String, String&gt; map);
</code></pre><p>调用：</p>
<pre><code><span class="keyword">final</span> <span class="keyword">HashMap</span>&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();
<span class="built_in">map</span>.put(<span class="string">"jigou_id"</span>, <span class="string">"372759"</span>);
<span class="built_in">map</span>.put(<span class="string">"page"</span>, <span class="string">"1"</span>);
<span class="built_in">map</span>.put(<span class="string">"signapp"</span>, MD5);

Call&lt;JsonFather&gt; listCall = MyApplication.<span class="built_in">get</span>(context).getSnakeService().loadData(Collections.unmodifiableMap(<span class="built_in">map</span>));
</code></pre><p>@Headers 请求头信息</p>
<pre><code><span class="variable">@Headers</span>(<span class="string">"Accept: application/json"</span>)
<span class="variable">@HEAD</span>(<span class="string">"/recurso/cultura-ocio/evento-zaragoza?rf=html&amp;results_only=false&amp;srsname=wgs84&amp;rows=1000&amp;q=programa%3D%3Dfiestas%20del%20pilar"</span>)
public void <span class="function">getHeaders</span>(Callback&lt;retrofit.client.Header&gt; callback);
</code></pre><p>@Body 可以声明一个对象作为请求体发送到服务器</p>
<pre><code> <span class="variable">@POST</span>(<span class="string">"/users/new"</span>)
Call&lt;User&gt; <span class="function">createUser</span>(<span class="variable">@Body</span> User user);
</code></pre><p>User对象将被对应的转换器转换为字符串或者字节流提交到服务器。</p>
<p>@FormUrlEncoded 注解来发送表单数据。使用 @Field注解和参数来指定每个表单项的Key，value为参数的值。</p>
<pre><code><span class="variable">@FormUrlEncoded</span>
<span class="variable">@POST</span>(<span class="string">"/user/edit"</span>)
User <span class="function">updateUser</span>(<span class="variable">@Field</span>(<span class="string">"first_name"</span>) String first, <span class="variable">@Field</span>(<span class="string">"last_name"</span>) String last);
</code></pre><p>@Multipart 注解来发送multipart数据(文件上传)。使用 @Part 注解定义要发送的每个文件。</p>
<pre><code><span class="variable">@Multipart</span>
<span class="variable">@PUT</span>(<span class="string">"/user/photo"</span>)
User <span class="function">updateUser</span>(<span class="variable">@Part</span>(<span class="string">"photo"</span>) TypedFile photo, <span class="variable">@Part</span>(<span class="string">"description"</span>) TypedString description);
</code></pre><p>Tips3.Retrofit为什么不需要你关注json格式？</p>
<pre><code>因为实体bean对象其实就代表了json的格式
</code></pre><p>Tips4.如何使用retrofit标识同步和异步：</p>
<p>2.0版本同步：execute()</p>
<pre><code><span class="operator"><span class="keyword">Call</span>&lt;Repo&gt; <span class="keyword">call</span> = service.loadRepo();</span>
Repo repo = <span class="operator"><span class="keyword">call</span>.<span class="keyword">execute</span>();</span>
</code></pre><p>2.0版本异步：enqueue()</p>
<pre><code><span class="operator"><span class="keyword">Call</span>&lt;Repo&gt; <span class="keyword">call</span> = service.loadRepo();</span>
<span class="operator"><span class="keyword">call</span>.<span class="keyword">enqueue</span>(<span class="keyword">new</span> Callback&lt;Repo&gt;() {
    @Override
    <span class="keyword">public</span> <span class="built_in">void</span> onResponse(Response&lt;Repo&gt; response) {
        // <span class="keyword">Get</span> <span class="keyword">result</span> Repo <span class="keyword">from</span> response.<span class="keyword">body</span>()
    }

    @Override
    <span class="keyword">public</span> <span class="built_in">void</span> onFailure(Throwable <span class="keyword">t</span>) {

    }
});</span>
</code></pre><p>Tips5.我该如何只想返回json串，自己去做解析</p>
<p>见issiue：</p>
<p><img src="http://7xn9yd.com1.z0.glb.clouddn.com/强强强强Image%204.png" alt=""></p>
<p>代码：</p>
<pre><code> @POST<span class="params">(<span class="string">"tehui/getTehuiByJigouId"</span>)</span>
Call&lt;ResponseBody&gt; loadData2<span class="params">(@QueryMap Map&lt;String, String&gt; map)</span>;

Call&lt;ResponseBody&gt; listCall2 = MyApplication.get<span class="params">(context)</span>.getSnakeService<span class="params">()</span>.loadData2<span class="params">(Collections.unmodifiableMap<span class="params">(map)</span>)</span>;


listCall2.enqueue<span class="params">(new Callback&lt;ResponseBody&gt;<span class="params">()</span> {
        @Override
        public void onResponse<span class="params">(Response&lt;ResponseBody&gt; response, Retrofit retrofit)</span> {

            //<span class="number">1</span>.先判断是否是<span class="number">200</span>或者<span class="number">201</span>请求成功
            if<span class="params">(response.isSuccess<span class="params">()</span>)</span>{
                // request successful <span class="params">(status code <span class="number">200</span>, <span class="number">201</span>)</span>

                //<span class="number">2</span>.处理是否为null response.body<span class="params">()</span>会返回null
                if<span class="params">(null!=response.body<span class="params">()</span>)</span>{
                    try {
                        tvText.setText<span class="params">(response.body<span class="params">()</span>.string<span class="params">()</span>)</span>;
                    } catch <span class="params">(IOException e)</span> {
                        e.printStackTrace<span class="params">()</span>;
                        tvText.setText<span class="params">(<span class="string">"IOException"</span>)</span>;
                    }
                }
            }else{

                //request not successful <span class="params">(like <span class="number">400</span>,<span class="number">401</span>,<span class="number">403</span> etc)</span>
                //Handle errors

                if<span class="params">(null!=response.errorBody<span class="params">()</span>)</span>{
                    try {
                        tvText.setText<span class="params">(response.errorBody<span class="params">()</span>.string<span class="params">()</span>)</span>;
                    } catch <span class="params">(IOException e)</span> {
                        e.printStackTrace<span class="params">()</span>;
                        tvText.setText<span class="params">(<span class="string">"IOException"</span>)</span>;
                    }
                }


            }



        }

        @Override
        public void onFailure<span class="params">(Throwable throwable)</span> {

        }
 })</span>;
</code></pre><p>注意2.0前的版本如果想返回的是json串使用的是：Response (2.0是ResponseBody)。</p>
<p>Tips6.如何定义URL是最好的书写习惯：</p>
<p>建议：</p>
<ul>
<li>Base URL: 总是以 /结尾</li>
<li>@Url: 不要以 / 开头</li>
</ul>
<p><img src="http://7xn9yd.com1.z0.glb.clouddn.com/rrrImage%205.png" alt=""></p>
<p>最终拼凑成：<a href="http://www.xxxxxx.com/v6/tehui/getTehuiByJigouId" target="_blank" rel="external">http://www.xxxxxx.com/v6/tehui/getTehuiByJigouId</a></p>
<p>Tips7.如何定义json解析工具：</p>
<p><img src="http://7xn9yd.com1.z0.glb.clouddn.com/dddddddImage%206.png" alt=""></p>
<pre><code>Retrofit retrofit = new Retrofit.Builder<span class="params">()</span>
               .baseUrl<span class="params">(<span class="string">"http://www.xxxxxx.com/v6/"</span>)</span>  
               <span class="comment">//指定为moshi解析json                 </span>
               .addConverterFactory<span class="params">(MoshiConverterFactory.create<span class="params">()</span>)</span>                    
               .build<span class="params">()</span>;
       return retrofit.create<span class="params">(SnakeService.class)</span>;
</code></pre><p>Tips8.如何配合使用RxJava：</p>
<p>Retrofit团队有已经准备好了的CallAdapter module。其中最著名的module可能是为RxJava准备的CallAdapter，它将作为Observable返回。</p>
<pre><code><span class="keyword">compile</span> <span class="string">'com.squareup.retrofit:adapter-rxjava:2.0.0-beta1'</span>
<span class="keyword">compile</span> <span class="string">'io.reactivex:rxandroid:1.0.1'</span>
</code></pre><p>Sync Gradle并在Retrofit Builder链表中如下调用addCallAdapterFactory：</p>
<pre><code>Retrofit retrofit = new Retrofit.Builder<span class="params">()</span>
    .baseUrl<span class="params">(<span class="string">"http://api.nuuneoi.com/base/"</span>)</span>
    .addConverterFactory<span class="params">(GsonConverterFactory.create<span class="params">()</span>)</span>
    .addCallAdapterFactory<span class="params">(RxJavaCallAdapterFactory.create<span class="params">()</span>)</span>
    .build<span class="params">()</span>;



Observable&lt;DessertItemCollectionDao&gt; observable = service.loadDessertListRx<span class="params">()</span>;

observable.observeOn<span class="params">(AndroidSchedulers.mainThread<span class="params">()</span>)</span>
    .subscribe<span class="params">(new Subscriber&lt;DessertItemCollectionDao&gt;<span class="params">()</span> {
        @Override
        public void onCompleted<span class="params">()</span> {
            Toast.makeText<span class="params">(getApplicationContext<span class="params">()</span>,
                    <span class="string">"Completed"</span>,
                    Toast.LENGTH_SHORT)</span>
                .show<span class="params">()</span>;
        }

        @Override
        public void onError<span class="params">(Throwable e)</span> {
            Toast.makeText<span class="params">(getApplicationContext<span class="params">()</span>,
                    e.getMessage<span class="params">()</span>,
                    Toast.LENGTH_SHORT)</span>
                .show<span class="params">()</span>;
        }

        @Override
        public void onNext<span class="params">(DessertItemCollectionDao dessertItemCollectionDao)</span> {
            Toast.makeText<span class="params">(getApplicationContext<span class="params">()</span>,
                    dessertItemCollectionDao.getData<span class="params">()</span>.get<span class="params">(<span class="number">0</span>)</span>.getName<span class="params">()</span>,
                    Toast.LENGTH_SHORT)</span>
                .show<span class="params">()</span>;
        }
    })</span>;
</code></pre><p>Tips9.onResponse()方法如何健壮性的处理</p>
<p>在2.0版本，首先不管 response 是否能被解析。onResponse()总是会被调用。但是在结果不能被解析的情况下，response.body()会返回null。</p>
<p>其次：onResponse()和onFailure()都是在主线程运行的。</p>
<pre><code>a.先判断HTTP状态码（HTTP Status Code） 是否为<span class="number">200</span>/<span class="number">201</span>
b.再判断<span class="keyword">body</span>是否为<span class="literal">null</span>
c.数组的size是否为<span class="number">0</span>,如果为<span class="number">0</span>要注意避免<span class="literal">null</span>指针异常或更新为无数据界面.


listCall.enqueue(<span class="keyword">new</span> Callback&lt;ResponseBody&gt;() {
        <span class="keyword">@Override</span>
        <span class="keyword">public</span> <span class="keyword">void</span> onResponse(Response&lt;ResponseBody&gt; response, Retrofit retrofit) {

            <span class="comment">//1.先判断是否是200或者201请求成功</span>
            <span class="keyword">if</span>(response.isSuccess()){
                <span class="comment">// request successful (status code 200, 201)</span>

                <span class="comment">//2.处理是否为null response.body()会返回null</span>
                <span class="keyword">if</span>(<span class="literal">null</span>!=response.<span class="keyword">body</span>()){
                    <span class="keyword">try</span> {
                        <span class="comment">//3.size大小</span>
                        <span class="keyword">if</span>(response.<span class="keyword">body</span>().getArray().size &gt; <span class="number">0</span>){
                             tvText.setText(response.<span class="keyword">body</span>().<span class="built_in">string</span>());
                        }
                    } <span class="keyword">catch</span> (IOException e) {
                        e.printStackTrace();
                        tvText.setText(<span class="string">"IOException"</span>);
                    }
                }
            }<span class="keyword">else</span>{

                <span class="comment">//request not successful (like 400,401,403 etc)--Handle errors</span>

                <span class="keyword">if</span>(<span class="literal">null</span>!=response.errorBody()){
                    <span class="keyword">try</span> {
                        tvText.setText(response.errorBody().<span class="built_in">string</span>());
                    } <span class="keyword">catch</span> (IOException e) {
                        e.printStackTrace();
                        tvText.setText(<span class="string">"IOException"</span>);
                    }
                }


            }



        }

        <span class="keyword">@Override</span>
        <span class="keyword">public</span> <span class="keyword">void</span> onFailure(Throwable throwable) {

        }
    });
</code></pre><p>Tips10.onPreExecute()和onPostExecute的加载loading怎么展示比较好：</p>
<p>将开始加载放在listCall.enqueue之前调用(伪代码):</p>
<pre><code>onStartLoading<span class="params">()</span>
listCall.enqueue<span class="params">(Callback)</span>;
</code></pre><p>将关闭加载放在的回调函数onResponse和onFailure的最开始处理(伪代码)：</p>
<pre><code>onStartLoading<span class="literal">()</span>;
listCall.enqueue(<span class="keyword">new</span> <span class="type">Callback</span><span class="literal">()</span>{
    onResponse<span class="literal">()</span>{
        onStopLoading<span class="literal">()</span>;
    }
    onFailure<span class="literal">()</span>{
        onStopLoading<span class="literal">()</span>;
    }
});
</code></pre><p>Tips11.为什么我网络成功，但返回的array数组里什么都没有,是:[]，moshi究竟需要怎样的格式才可以完成自我json转化为pojo对象：</p>
<pre><code>{
    "<span class="attribute">state</span>": <span class="value"><span class="string">"000"</span></span>,
    "<span class="attribute">t_rs</span>": <span class="value">[
        {
            "<span class="attribute">id</span>": <span class="value"><span class="string">"1422"</span></span>,
            "<span class="attribute">title</span>": <span class="value"><span class="string">"[ 上海万安 ]360艺术美鼻"</span></span>,
            "<span class="attribute">image</span>": <span class="value"><span class="string">"http://tehui.meilimei.com/static/team/2015/0612/14340889238311.jpg?201510200800"</span></span>,
            "<span class="attribute">team_price</span>": <span class="value"><span class="string">"500.00"</span></span>,
            "<span class="attribute">now_number</span>": <span class="value"><span class="string">"1"</span></span>,
            "<span class="attribute">market_price</span>": <span class="value"><span class="string">"22800.00"</span></span>,
            "<span class="attribute">delivery</span>": <span class="value"><span class="string">"coupon"</span></span>,
            "<span class="attribute">deposit</span>": <span class="value"><span class="string">"500.00"</span></span>,
            "<span class="attribute">mechanism</span>": <span class="value"><span class="string">"上海万安医疗美容医院"</span></span>,
            "<span class="attribute">flag</span>": <span class="value"><span class="number">1</span>
        </span>},
        {
            "<span class="attribute">id</span>": <span class="value"><span class="string">"1602"</span></span>,
            "<span class="attribute">title</span>": <span class="value"><span class="string">"[ 上海万安 ]瑞兰玻尿酸注射 不开刀就能美美哒的秘密"</span></span>,
            "<span class="attribute">image</span>": <span class="value"><span class="string">"http://tehui.meilimei.com/static/team/2015/0624/14351340349342.jpg?201510200800"</span></span>,
            "<span class="attribute">team_price</span>": <span class="value"><span class="string">"300.00"</span></span>,
            "<span class="attribute">now_number</span>": <span class="value"><span class="string">"4"</span></span>,
            "<span class="attribute">market_price</span>": <span class="value"><span class="string">"3800.00"</span></span>,
            "<span class="attribute">delivery</span>": <span class="value"><span class="string">"coupon"</span></span>,
            "<span class="attribute">deposit</span>": <span class="value"><span class="string">"300.00"</span></span>,
            "<span class="attribute">mechanism</span>": <span class="value"><span class="string">"上海万安医疗美容医院"</span></span>,
            "<span class="attribute">flag</span>": <span class="value"><span class="number">1</span>
        </span>}
    ]
</span>}
</code></pre><p>看这里的json串，数组的key为t_rs，所以</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">JsonFather</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">BaseInfoBen</span> {</span>

    <span class="keyword">private</span> <span class="type">String</span> state;

    <span class="keyword">private</span> <span class="type">String</span> notice;

    <span class="comment">//这里的这个单词必需和json串对应，否则无法解析成功</span>
    <span class="keyword">private</span> <span class="type">List</span>&lt;<span class="type">NewHuiListInfo</span>&gt; t_rs = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;();

}
</code></pre><p>如果一旦你自定义为比如info：</p>
<pre><code><span class="keyword">private</span> <span class="built_in">List</span>&lt;NewHuiListInfo&gt; info = <span class="literal">new</span> ArrayList&lt;&gt;();
</code></pre><p>那你拿回来的info里面就是空数组，可见暂时和gson不同的moshi是根据变量名单词匹配的。gson的解析是根据注解上的名称value来匹配json串的，moshi因为是新框架，暂时不支持注解对应json名，所以它要求你的变量名和json串相同！</p>
<p>不知J神的moshi解析框架以后是否支持注解…待观察…</p>
<h3 id="五-当SquareFoundation遇到MVP和hibernate,将擦出怎样的火花">五.当SquareFoundation遇到MVP和hibernate,将擦出怎样的火花</h3><p>该部分我会封装一套基于’Ok’ Libraries ，结合MVP分层结构，同时使用hibernate思想操作封装对象的框架。届时请关注我博客的更新。</p>
<h3 id="六-结尾语">六.结尾语</h3><p>&emsp;&emsp;1.大神就是大神，一整个核心架构在台座上昭然若现，极度优良的API和接口调用，极富效率的底层架构，都将让我们一窥Square公司的核心开发技巧和能量。这是中国国内狭隘自私不懂开源的BAT这样的公司不能比拟的;</p>
<p>&emsp;&emsp;2.Square即将上市，最新的消息，估计为60亿美金。10月15日我便在微信朋友圈发布了这条消息：</p>
<p>News : <a href="http://3g.163.com/ntes/special/0034073A/wechat_article.html?docid=B5UQKU57000915BF&amp;spst=0&amp;spss=newsapp&amp;spsf=wx&amp;spsw=1" title="Square IPO欲融资2.75亿美元" target="_blank" rel="external">Square IPO欲融资2.75亿美元</a></p>
<p>&emsp;&emsp;并留下了下面的一段话：</p>
<blockquote>
<p>分享这条消息是因为这家公司是Android开源界的大神，自从这家公司09年成立，就一直专职在社区为Android提供新的技术和架构，而如今很多技术都成为Android开发前沿。这家公司的创始人杰克多西也是Twitter的创始人，但由于Twitter的权利内斗而被自己公司fired。如今糟糕营收和缓慢用户增长的Twitter不得不重新请回自家创始人。多西8岁开始在自己的第一台IBM电脑上学习编程，是个不折不扣的屌丝程序猿，但好在国外优良的创业传统，给予很多有想法的程序猿改变世界以及自己，国外牛逼的互联网公司的创始人都是程序猿。反观国内程序猿如屌丝般的我们，天天奔波在2点1线，每个月为万把块钱的薪酬奋斗，一套房，一辆车，在国内剥削经济和加班风潮下，早已磨灭斗志和创业意识。</p>
</blockquote>
<p>&emsp;&emsp;后来又翻到了一篇2013年年底的新闻：</p>
<p>News : <a href="http://3g.163.com/ntes/special/0034073A/wechat_article.html?docid=9GKN0NE600964KJ3&amp;spst=0&amp;spss=newsapp&amp;spsf=wx&amp;spsw=1" title="太大方了，杰克·多西返还 10% Square 股票" target="_blank" rel="external">太大方了，杰克·多西返还 10% Square 股票</a></p>
<p>&emsp;&emsp;不知道在中国有多少公司能有财富共享的思想，真的很难……你能富有，只是因为你有一帮让你富有的员工。你不写一行代码，你不画一张设计图，你不开发一个客户，你不为一次决策失误买单，你凭什么不珍惜员工。马云说要做一家102年的企业，他指的是已经成立了16年的阿里巴巴…中国国内的互联网环境一直很糟糕，过度的垄断、对技术的敷衍和钱绝不都没有效益领域的偏见思想，导致中国只是一个大局域网的环境，与国外的技术良性发展非常不同。现如今，互联网资本寒冬将至，希望可以戳破这一波非理性型泡沫，留下可以发展的良心企业。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">&raquo;</a>
  </nav>


            </div>

            

            
        </div>

        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/avatar.jpg" alt="熊伟xiongwei" itemprop="image"/>
          <p class="site-author-name" itemprop="name">熊伟xiongwei</p>
        </div>
        <p class="site-description motion-element" itemprop="description">重新发现、定义并创造这个世界...</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">25</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/xiaomeixw" target="_blank">github</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.sabria.net/" target="_blank">anotherblog</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/1561605537" target="_blank">weibo</a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
        <div class="footer-inner">
            <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">熊伟xiongwei</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



        </div>
    </footer>

    <div class="back-to-top"></div>
</div>

<script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
  
  

  



  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.4"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.4"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.4" id="motion.global"></script>



  <script type="text/javascript" src="/js/search-toggle.js"></script>



<script type="text/javascript">
    $(document).ready(function () {
        if (CONFIG.sidebar === 'always') {
            displaySidebar();
        }
    });
</script>




  
  

  







<!-- lazyload -->
<script type="text/javascript" src="/js/lazyload.js"></script>
<script type="text/javascript">
    jQuery(function () {
        jQuery("#posts img").lazyload({
            placeholder: "/images/loading.gif",
            effect: "fadeIn"
        });
    });
</script>
</body>
</html>
