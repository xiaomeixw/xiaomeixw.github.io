<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
    

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.4"/>


    <meta name="description" content="重新发现、定义并创造这个世界..." />



  <meta name="keywords" content="Hexo,next" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.4" />


<meta name="description" content="重新发现、定义并创造这个世界...">
<meta property="og:type" content="website">
<meta property="og:title" content="sabria">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="sabria">
<meta property="og:description" content="重新发现、定义并创造这个世界...">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="sabria">
<meta name="twitter:description" content="重新发现、定义并创造这个世界...">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'hide'
  };
</script>

    <title> sabria </title>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->




<div class="container one-column 
   page-home 
">
    <div class="headband"></div>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">sabria</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-tags"></i> <br />
            标签
          </a>
        </li>
      
    </ul>
  

  
</nav>


        </div>
    </header>

    <main id="main" class="main">
        <div class="main-inner">
            <div id="content" class="content">
                
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/01/22/ZTN01_5/" itemprop="url">
                【杂谈1月】H5与APP交互错疑
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-01-22T16:24:12+08:00" content="2016-01-22">
            2016-01-22
          </time>
        </span>

        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>H5与APP交互错疑：</p>
<p>一般APP与H5的交互分为2个主要的交互组成:</p>
<ul>
<li>1.APP和H5互相调用并传递数据;</li>
</ul>
<p>比较实用的场景为:点击广告Banner进入H5界面商品列表，然后点击里面的一个商品，打开的是APP的产品详情界面。这个需求比较知名的比如是京东APP端的“掌上秒杀”：该界面为H5，点击后进入的商品详情为原生的详情界面。</p>
<ul>
<li>2.浏览器H5调出APP。</li>
</ul>
<p>比较实用的场景为:浏览器打开H5界面，该界面在3-5秒后会自动打开你的APP相关的界面。这个需求比较知名的比如：百度贴吧，浏览器中打开的是某一个贴吧的页面，5秒后手机里面的百度贴吧APP的相应原生界面就会被唤起。</p>
<h2 id="一-H5与APP交互">一.H5与APP交互</h2><p>产品层面需求：</p>
<p>1.进入APP的H5界面商品列表,点击H5的列表的某一个商品后,进入App的特惠详情界面</p>
<p>2.H5同事要求我如果跳转成功后,必需告知它跳转成功.</p>
<hr>
<p>先贴出H5的最后测试成功的代码:</p>
<pre><code><span class="doctype">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="title">html</span> <span class="attribute">lang</span>=<span class="value">"en"</span>&gt;</span>
<span class="tag">&lt;<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"UTF-8"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
<span class="tag">&lt;/<span class="title">head</span>&gt;</span> 
<span class="tag">&lt;<span class="title">body</span>&gt;</span>
  <span class="tag">&lt;<span class="title">center</span>&gt;</span>
    <span class="tag">&lt;<span class="title">br</span> /&gt;</span><span class="tag">&lt;<span class="title">br</span> /&gt;</span><span class="tag">&lt;<span class="title">br</span> /&gt;</span><span class="tag">&lt;<span class="title">br</span> /&gt;</span><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"aa"</span>&gt;</span><span class="tag">&lt;<span class="title">button</span> <span class="attribute">onclick</span>=<span class="value">"dian()"</span>&gt;</span>点我点我点我点我<span class="tag">&lt;/<span class="title">button</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span><span class="tag">&lt;<span class="title">br</span> /&gt;</span><span class="tag">&lt;<span class="title">br</span> /&gt;</span><span class="tag">&lt;<span class="title">br</span> /&gt;</span><span class="tag">&lt;<span class="title">br</span> /&gt;</span><span class="tag">&lt;<span class="title">br</span> /&gt;</span><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"aa"</span>&gt;</span><span class="tag">&lt;<span class="title">button</span> <span class="attribute">onclick</span>=<span class="value">"pay()"</span>&gt;</span>下单<span class="tag">&lt;/<span class="title">button</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">center</span>&gt;</span>
  <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"webview_ios2.php"</span>&gt;</span>1111111<span class="tag">&lt;/<span class="title">a</span>&gt;</span>
  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"result"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
  <span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
  <span class="comment">//判断访问终端</span>
  <span class="keyword">var</span> browser={
      versions:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
          <span class="keyword">var</span> u = navigator.userAgent, app = navigator.appVersion;
          <span class="keyword">return</span> {
              trident: u.indexOf(<span class="string">'Trident'</span>) &gt; -<span class="number">1</span>, <span class="comment">//IE内核</span>
              presto: u.indexOf(<span class="string">'Presto'</span>) &gt; -<span class="number">1</span>, <span class="comment">//opera内核</span>
              webKit: u.indexOf(<span class="string">'AppleWebKit'</span>) &gt; -<span class="number">1</span>, <span class="comment">//苹果、谷歌内核</span>
              gecko: u.indexOf(<span class="string">'Gecko'</span>) &gt; -<span class="number">1</span> &amp;&amp; u.indexOf(<span class="string">'KHTML'</span>) == -<span class="number">1</span>,<span class="comment">//火狐内核</span>
              mobile: !!u.match(<span class="regexp">/AppleWebKit.*Mobile.*/</span>), <span class="comment">//是否为移动终端</span>
              ios: !!u.match(<span class="regexp">/\(i[^;]+;( U;)? CPU.+Mac OS X/</span>), <span class="comment">//ios终端</span>
              android: u.indexOf(<span class="string">'Android'</span>) &gt; -<span class="number">1</span> || u.indexOf(<span class="string">'Linux'</span>) &gt; -<span class="number">1</span>, <span class="comment">//android终端或者uc浏览器</span>
              iPhone: u.indexOf(<span class="string">'iPhone'</span>) &gt; -<span class="number">1</span> , <span class="comment">//是否为iPhone或者QQHD浏览器</span>
              iPad: u.indexOf(<span class="string">'iPad'</span>) &gt; -<span class="number">1</span>, <span class="comment">//是否iPad</span>
              webApp: u.indexOf(<span class="string">'Safari'</span>) == -<span class="number">1</span>, <span class="comment">//是否web应该程序，没有头部与底部</span>
              weixin: u.indexOf(<span class="string">'MicroMessenger'</span>) &gt; -<span class="number">1</span>, <span class="comment">//是否微信 （2015-01-22新增）</span>
              qq: u.match(<span class="regexp">/\sQQ/i</span>) == <span class="string">" qq"</span> <span class="comment">//是否QQ</span>
          };
      }(),
      language:(navigator.browserLanguage || navigator.language).toLowerCase()
  }

  <span class="function"><span class="keyword">function</span> <span class="title">dian</span> (<span class="params"></span>) </span>{
    <span class="keyword">if</span>(browser.versions.android){
      <span class="keyword">var</span> data = <span class="string">'{"hui":"710"}'</span>;
     <span class="comment">//js调用android本地方法</span>
      <span class="keyword">var</span> result = <span class="built_in">window</span>.AndroidTehuiInfo.hui(data);
      <span class="comment">//alert(JSON.stringify(result));</span>
    }
  }

  <span class="comment">//android调用js的方法</span>
  <span class="function"><span class="keyword">function</span> <span class="title">interactive</span>(<span class="params">a</span>)</span>{
      alert(a)  
        <span class="built_in">document</span>.getElementById(<span class="string">"result"</span>).innerHTML=a;  
   }  
  </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
</code></pre><p>解决问题一:点击H5商品列表,进入APP原生商品详情</p>
<p>这里涉及到的就是:JS调用android原生方法</p>
<p>我和同事约定:通过传递json串的方案来处理数据:所以表示js调用android原生方法，传递json串数据给我.</p>
<p>首先H5同事定义一个调用android原生的方法:</p>
<pre><code>function dian () {
   <span class="keyword">if</span>(browser.versions.android){
     <span class="keyword">var</span> data = '{<span class="string">"hui"</span>:<span class="string">"710"</span>}';
    //js调用本地方法
     <span class="keyword">var</span> <span class="literal">result</span> = window.<span class="type">AndroidTehuiInfo</span>.hui(data);
     //alert(<span class="type">JSON</span>.stringify(<span class="literal">result</span>));
   }
 }
</code></pre><p>这点代码的业务逻辑就是:JS调用android原始的类AndroidTehuiInfo它下面的hui()方法，该原生方法的参数是json串(也就是string字符串).这里的json串就告诉我点击H5列表的这个商品的id值，要我展示具体哪一个商品的原生APP详情界面.</p>
<p>那么对于这段话,android端要如何配合:</p>
<p>首先:<br>1.要让webview支持js</p>
<pre><code>mWebView.getSettings<span class="params">()</span>.setJavaScriptEnabled<span class="params">(<span class="literal">true</span>)</span>;  
</code></pre><p>2.和js中指定的类和方法对应上:</p>
<pre><code><span class="comment">//Object是JS调用本地的类的对象，name是对象的别名，在JS可以用这个别名+点语法+方法名就可以调用本地的方法。</span>
web.addJavascriptInterface(<span class="keyword">object</span>,<span class="string">"name"</span>);
</code></pre><p>那么这个js方法对应这个就是:</p>
<pre><code><span class="tag">web</span><span class="class">.addJavascriptInterface</span>(<span class="tag">activity</span><span class="class">.androidTehuiInfo</span>,"<span class="tag">AndroidTehuiInfo</span>");
</code></pre><p>3.然后我们android端要书写一个方法hui(data)对应js，记得方法上标注: @JavascriptInterface</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AndroidTehuiInfo</span> </span>{

    <span class="keyword">private</span> Activity activity;

    <span class="keyword">private</span> WebView web;

    <span class="function"><span class="keyword">public</span> <span class="title">AndroidTehuiInfo</span><span class="params">(Activity activity,WebView web)</span> </span>{
        <span class="keyword">this</span>.web=web;
        <span class="keyword">this</span>.activity = activity;
    }


    <span class="annotation">@JavascriptInterface</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hui</span><span class="params">(String data)</span> </span>{
        <span class="keyword">try</span> {
            <span class="comment">//这里就是解析js传给我的json串，我解析它，然后知道了特惠商品的id值是多少?</span>
            JSONObject json = <span class="keyword">new</span> JSONObject(data);
            String id = json.getString(<span class="string">"hui"</span>);
            Intent intent = <span class="keyword">new</span> Intent(activity, HuiProdcutDetailActivity.class);
            intent.putExtra(<span class="string">"hui"</span>, id);
            activity.startActivity(intent);
        } <span class="keyword">catch</span> (Exception e) {
            e.printStackTrace();
            sendFailInfoToJs();
        }
    }

}
</code></pre><p>自此:JS调用Android端原生方法就完成.</p>
<p>解决问题二: 跳转成功后告知H5同事,我android跳转成功了.</p>
<p>这里实际上涉及到的就是:Android调用JS的方法。</p>
<p>首先H5同事书写方法:</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">interactive</span><span class="params">(a)</span>{</span>
    alert<span class="params">(a)</span>  
      document.getElementById<span class="params">(<span class="string">"result"</span>)</span>.innerHTML=a;  
 }  
</code></pre><p>这里的方法命名interactive(参数)是我们彼此约定的,因为待会我android端必需要用到,否则怎么知道究竟调用哪个方法.</p>
<p>android端要如何配合:</p>
<p>1.在跳转成功的地方返回成功的json串给JS:</p>
<p>json：{“result”:”true”}</p>
<pre><code><span class="keyword">private</span> <span class="keyword">void</span> sendOkInfoToJs() {
    <span class="keyword">final</span> <span class="keyword">JSONObject</span> json = <span class="keyword">new</span> <span class="keyword">JSONObject</span>();
    <span class="keyword">try</span> {
        json.put(<span class="string">"result"</span>, <span class="string">"true"</span>);            
        web.loadUrl(<span class="string">"javascript:interactive('"</span> + json.toString() + <span class="string">"')"</span>);         
    } <span class="keyword">catch</span> (JSONException e) {
        e.printStackTrace();
    }

}
</code></pre><p>2.loadUrl加载本地js的方法interactive(var),传递过去的参数就是我的json串.</p>
<pre><code><span class="tag">web</span><span class="class">.loadUrl</span>("<span class="rule"><span class="attribute">javascript</span>:<span class="value"><span class="function">interactive</span>(<span class="string">'" + json.toString() + "'</span>)<span class="string">");     </span></span></span>
</code></pre><p>然后收到json串的H5同事就去做他自己的业务逻辑.</p>
<p>但是在有些机型上你会发觉Logcat报错:</p>
<blockquote>
<p>java.lang.Throwable: A WebView method was called on thread ‘JavaBridge’. All WebView methods must be called on the same thread. (Expected Looper Looper (main, tid 1) {42da1250} called on Looper (JavaBridge, tid 51131) {42e13150}, FYI main Looper is Looper (main, tid 1) {42da1250})</p>
</blockquote>
<p>原因:在js调用后的Java回调线程并不是同一线程。</p>
<p>解决方案:将</p>
<pre><code><span class="tag">web</span><span class="class">.loadUrl</span>("<span class="rule"><span class="attribute">javascript</span>:<span class="value"><span class="function">interactive</span>(<span class="string">'" + json.toString() + "'</span>)<span class="string">"); </span></span></span>
</code></pre><p>post到同一个线程中去执行:</p>
<pre><code>web.post(<span class="keyword">new</span> Runnable() {
            <span class="annotation">@Override</span>
            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                web.loadUrl(<span class="string">"javascript:interactive('"</span> + json.toString() + <span class="string">"')"</span>);
            }
        });
</code></pre><p>所以AndroidTehuiInfo类完整代码如下：</p>
<pre><code><span class="keyword">package</span> com.work.beauty.js;

<span class="keyword">import</span> android.app.Activity;
<span class="keyword">import</span> android.content.Intent;
<span class="keyword">import</span> android.webkit.JavascriptInterface;
<span class="keyword">import</span> android.webkit.WebView;

<span class="keyword">import</span> com.work.beauty.HuiProdcutDetailActivity;

<span class="keyword">import</span> org.json.JSONException;
<span class="keyword">import</span> org.json.JSONObject;

<span class="comment">/**
 * Created by xiongwei,An Android project Engineer.
 * Date:2015-12-22  12:04
 * Base on Meilimei.com (PHP Service)
 * Describe:
 * Version:1.0
 * Open source
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AndroidTehuiInfo</span> </span>{

    <span class="keyword">private</span> Activity activity;

    <span class="keyword">private</span> WebView web;

    <span class="function"><span class="keyword">public</span> <span class="title">AndroidTehuiInfo</span><span class="params">(Activity activity, WebView web)</span> </span>{
        <span class="keyword">this</span>.web = web;
        <span class="keyword">this</span>.activity = activity;
    }


    <span class="annotation">@JavascriptInterface</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hui</span><span class="params">(String data)</span> </span>{
        <span class="keyword">try</span> {
            JSONObject json = <span class="keyword">new</span> JSONObject(data);
            String id = json.getString(<span class="string">"hui"</span>);
            Intent intent = <span class="keyword">new</span> Intent(activity, HuiProdcutDetailActivity.class);
            intent.putExtra(<span class="string">"hui"</span>, id);
            activity.startActivity(intent);
            <span class="comment">//Android告知JS:告知浏览器现在正常打开了</span>
            sendOkInfoToJs();
        } <span class="keyword">catch</span> (Exception e) {
            e.printStackTrace();
            sendFailInfoToJs();
        }
    }


    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendOkInfoToJs</span><span class="params">()</span> </span>{
        <span class="keyword">final</span> JSONObject json = <span class="keyword">new</span> JSONObject();
        <span class="keyword">try</span> {
            json.put(<span class="string">"result"</span>, <span class="string">"true"</span>);
            web.post(<span class="keyword">new</span> Runnable() {
                <span class="annotation">@Override</span>
                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                    web.loadUrl(<span class="string">"javascript:interactive('"</span> + json.toString() + <span class="string">"')"</span>);
                }
            });

        } <span class="keyword">catch</span> (JSONException e) {
            e.printStackTrace();
        }

    }

    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendFailInfoToJs</span><span class="params">()</span> </span>{
        JSONObject json = <span class="keyword">new</span> JSONObject();
        <span class="keyword">try</span> {
            json.put(<span class="string">"result"</span>, <span class="string">"false"</span>);
            web.post(<span class="keyword">new</span> Runnable() {
                <span class="annotation">@Override</span>
                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                    <span class="comment">//java.lang.Throwable: e.A WebView method was called on thread 'JavaBridge'. All WebView methods must be called on the same thread. (Expected Looper Looper (main, tid 1) {42da1250} called on Looper (JavaBridge, tid 51131) {42e13150}, FYI main Looper is Looper (main, tid 1) {42da1250})</span>
                    web.loadUrl(<span class="string">"javascript:interactive('"</span> + json.toString() + <span class="string">"')"</span>);
                }
            });

        } <span class="keyword">catch</span> (JSONException e) {
            e.printStackTrace();
        }

    }


}
</code></pre><h2 id="二-一个诡异的显示问题">二.一个诡异的显示问题</h2><p>问题:在APP上展示H5的双12活动后，点击其中的一个项目的“拼一单“后,进入的H5详情界面无法正常显示内容，为一片空白。</p>
<p>经过APP端跟踪代码发现Logcat显示信息如下:</p>
<pre><code><span class="list">[<span class="keyword">INFO:CONSOLE</span><span class="list">(<span class="keyword">635</span>)</span>] <span class="string">"Uncaught TypeError: Cannot read property 'dianji' of null"</span>, source: http://m.meilimei.com/zt/20151212/ <span class="list">(<span class="keyword">635</span>)</span></span>
</code></pre><p>定位到项目的H5界面为：</p>
<p><img src="http://i.imgur.com/PHy2eLx.png" alt=""></p>
<p>通过字面意思解读为”dianji”是null,没有被赋值.</p>
<p>而后继续通过关键词”chromium”在Logcat中发现：</p>
<pre><code><span class="number">12</span>-<span class="number">03</span> <span class="number">10</span>:<span class="number">59</span>:<span class="number">03.031</span>  <span class="number">29477</span>-<span class="number">29477</span>/com.work.beauty Iromium﹕ [INFO:CONSOLE(<span class="number">635</span>)] <span class="string">"Uncaught TypeError: Cannot read property 'dianji' of null"</span>, source: http:<span class="comment">//m.meilimei.com/zt/20151212/ (635)</span>
<span class="number">12</span>-<span class="number">03</span> <span class="number">10</span>:<span class="number">59</span>:<span class="number">28.671</span>  <span class="number">29477</span>-<span class="number">29477</span>/com.work.beauty Iromium﹕ [INFO:CONSOLE(<span class="number">635</span>)] <span class="string">"Uncaught TypeError: Cannot read property 'dianji' of null"</span>, source: http:<span class="comment">//m.meilimei.com/zt/20151212/ (635)</span>
<span class="number">12</span>-<span class="number">03</span> <span class="number">10</span>:<span class="number">59</span>:<span class="number">30.561</span>  <span class="number">29477</span>-<span class="number">29477</span>/com.work.beauty Iromium﹕ [INFO:CONSOLE(<span class="number">10</span>)] <span class="string">"The key "</span>minimal-ui<span class="string">" is not recognized and ignored."</span>, source: http:<span class="comment">//m.meilimei.com/wx/#!/store/tehui/4425 (10)</span>
<span class="number">12</span>-<span class="number">03</span> <span class="number">10</span>:<span class="number">59</span>:<span class="number">31.101</span>  <span class="number">29477</span>-<span class="number">29477</span>/com.work.beauty Iromium﹕ [INFO:CONSOLE(<span class="number">90</span>)] <span class="string">"Uncaught TypeError: Cannot call method 'getItem' of null"</span>, source: http:<span class="comment">//m.meilimei.com/wx/skin/js/app.js (90)</span>
</code></pre><p>追踪：<a href="http://m.meilimei.com/wx/skin/js/app.js的getItem()方法,也是null,导致APP内部的webview无法获取值" target="_blank" rel="external">http://m.meilimei.com/wx/skin/js/app.js的getItem()方法,也是null,导致APP内部的webview无法获取值</a>.</p>
<p><img src="http://i.imgur.com/8NM6yKq.png" alt=""></p>
<p>发现问题后向H5同事反馈，同事表示该字段”dianji”和getItem()为读取的Local storage中的,初始化赋值是在其中.</p>
<p>经过Chrome浏览器调试发现：</p>
<p>view-source:<a href="http://m.meilimei.com/zt/20151212/" target="_blank" rel="external">http://m.meilimei.com/zt/20151212/</a>  F12后发现Local storage</p>
<p><img src="http://i.imgur.com/hEWp3tU.png" alt=""></p>
<p>然后继续跟踪 <a href="http://m.meilimei.com/wx/skin/js/app.js" target="_blank" rel="external">http://m.meilimei.com/wx/skin/js/app.js</a>  发觉所有的初始化Local storage都在其中赋值:</p>
<p><img src="http://i.imgur.com/MErAb1U.png" alt=""></p>
<p>问题已经发觉，如何解决：<br>解决方案非常简单，问题既然是在于app内部的Webview无法读取Local Storage,那么读取该值就可以了：</p>
<pre><code>....
getLocalStroge<span class="params">(activity,web)</span>;
web.loadUrl<span class="params">(url)</span>
...

private static void getLocalStroge<span class="params">(Activity activity, WebView mWebView)</span>{
    mWebView.getSettings<span class="params">()</span>.setDomStorageEnabled<span class="params">(<span class="literal">true</span>)</span>;
    mWebView.getSettings<span class="params">()</span>.setAppCacheMaxSize<span class="params">(<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">8</span>)</span>;
    String appCachePath = activity.getApplicationContext<span class="params">()</span>.getCacheDir<span class="params">()</span>.getAbsolutePath<span class="params">()</span>;
    mWebView.getSettings<span class="params">()</span>.setAppCachePath<span class="params">(appCachePath)</span>;
    mWebView.getSettings<span class="params">()</span>.setAllowFileAccess<span class="params">(<span class="literal">true</span>)</span>;
    mWebView.getSettings<span class="params">()</span>.setAppCacheEnabled<span class="params">(<span class="literal">true</span>)</span>;
}
</code></pre><h2 id="三-浏览器打开APP">三.浏览器打开APP</h2><p>需求:在android浏览器上，打开含有美丽神器的H5页面，就要跳转到相应的APP原生界面。</p>
<p>解决方案:</p>
<p>android端需要与H5端共同约定一个intent-filter的scheme</p>
<pre><code><span class="tag">&lt;<span class="title">activity</span>
        <span class="attribute">android:name</span>=<span class="value">"com.work.beauty.NewShowLRActivity"</span>
        <span class="attribute">android:label</span>=<span class="value">"@string/app_name"</span>
        <span class="attribute">android:theme</span>=<span class="value">"@style/AppSplashTran"</span>
        <span class="attribute">android:exported</span>=<span class="value">"true"</span>
        <span class="attribute">android:alwaysRetainTaskState</span>=<span class="value">"true"</span>
        <span class="attribute">android:screenOrientation</span>=<span class="value">"portrait"</span> &gt;</span>
        <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span>
            <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.MAIN"</span> /&gt;</span>

            <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.LAUNCHER"</span> /&gt;</span>
        <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span>

        <span class="comment">&lt;!-- for web call --&gt;</span>
        <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span>
            <span class="tag">&lt;<span class="title">data</span> <span class="attribute">android:scheme</span>=<span class="value">"meilishenqi"</span>/&gt;</span>

            <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.VIEW"</span> /&gt;</span>
            <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.DEFAULT"</span> /&gt;</span>
            <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.BROWSABLE"</span> /&gt;</span>
        <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span>
<span class="tag">&lt;/<span class="title">activity</span>&gt;</span>
</code></pre><p>我们约定的scheme为meilishenqi.</p>
<p>H5同仁的界面约定格式操作如下：</p>
<pre><code>&lt;a href=<span class="string">"<span class="subst">[scheme]</span>://<span class="subst">[host]</span>/<span class="subst">[path]</span>?<span class="subst">[query]</span>"</span>&gt;启动应用程序&lt;/a&gt; 
</code></pre><p>此处的scheme需要与APP指定的android:scheme=”meilishenqi”相同.</p>
<p>参数解释:</p>
<ul>
<li><p>scheme：判别启动的App。 </p>
</li>
<li><p>host：hose地址</p>
</li>
<li><p>path：传值时必须的key     </p>
</li>
<li><p>query：获取值的Key和Value  </p>
</li>
</ul>
<p>关于这块由于我在去年和H5工程师测试的时候大约等待10秒后才能调起APP，存在比较长时间的延迟。后来由于需求变更，继续测试的计划耽搁，等待以后完成测试后补充完成该功能描述。</p>
<p>我会在测试完成后补充完解决方案….</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/01/13/ZTN01_4/" itemprop="url">
                【杂谈1月】Android注解范式编程Part2
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-01-13T01:32:12+08:00" content="2016-01-13">
            2016-01-13
          </time>
        </span>

        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>Android注解范式编程Part2</p>
<p>如果你做过JavaEE开发,你应该知道一个概念，叫:DI(依赖注入),依赖注入是Spring的核心思想,它将对象的创建交给Spring来进行管理,在初始化整个Java-web时,初始化在Spring的配置文件中的一批对象,当代码中需要对象时,只要直接从Spring中获取,而不需要自己去new.同时ClassA中如果需要的是ClassB对象,spring配置文件中也是有相应的对象ref引用的。</p>
<p>如果单纯说Spring概念的话，因为很多Android同仁也没有做过JavaEE的开发，所以最终决定还是在Part2中专门抽一小节给Spring一点概念简述.</p>
<h2 id="一-Spring简述">一.Spring简述</h2><p>Spring是Interface21公司开源的轻量级的JavaEE开发框架。它主要是控制Web三层架构的Service层的操作,它的核心是控制反转（IoC）和面向切面（AOP）。</p>
<p>控制反转（IoC）：应用本身不负责依赖对象的创建及维护。也就是应用本身不new对象。由Spring等IOC容器来处理对象的创建与维护。这个含义在某种程度上也就是DI(依赖注入)。具体的差异我会专门有文章讨论,这里不做过多描述。</p>
<p>面向切面编程（AOP）：通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP思想：在程序员编写代码时，随时动态的插入、删除这些系统服务性代码(如事务)。它的本质：动态代理。(spring使用的不是JDK的动态代理，而是使用个cglib第三方动态代理。)</p>
<p>Spring中最重要的是Bean对象的注入方案问题,比如：如何将PersonDao对象注入PersonService中？<br>理论上有三种解决方案:</p>
<ul>
<li>通过属性+set方法(接口)</li>
<li>通过属性+构造器</li>
<li>使用字段Field注解的方法(注解的方式)</li>
</ul>
<p>这里我就以方案一来处理,其他如果描述过多了，本末倒置，还影响我们讨论Android有关的知识。</p>
<p>PersonServiceBean对象:将PersonDao对象注入PersonService中</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceBean</span> <span class="keyword">implements</span> <span class="title">PersonService</span> </span>{

    <span class="keyword">private</span> PersonDao personDao;

    <span class="function"><span class="keyword">public</span> PersonDao <span class="title">getPersonDao</span><span class="params">()</span></span>{
        <span class="keyword">return</span> personDao;
    }

    <span class="function">Public <span class="keyword">void</span> <span class="title">setPersonDao</span><span class="params">(PersonDao personDao)</span></span>{
        <span class="keyword">this</span>.personDao=personDao;
    }

}
</code></pre><p>Spring配置文件:ref</p>
<pre><code>&lt;bean id=<span class="string">"personDao"</span> class =<span class="string">"sabria.demo.annotationdemo.dao.impl.PersonDao"</span>&gt;&lt;/bean&gt;
&lt;bean id=<span class="string">"personService"</span> class =<span class="string">"sabria.demo.annotationdemo.service.impl.PersonServiceBean"</span>&gt;
    &lt;property name=<span class="string">"personDao"</span> <span class="keyword">ref</span>=<span class="string">"personDao"</span>&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>我们看到Spring.xml文件在配置personService时,指定了一个ref引用”personDao”，然后它指向”sabria.demo.annotationdemo.dao.impl.PersonDao”,这样就完成通过属性+set方法的方案来完成引用对象的注入。</p>
<p>我们看到在Spring中极度简化了对象的创建以及“对象中对其他对象”的引用。而这种思想在Android中也大行其道,在Android端有3个非常成熟的方案在践行DI：Dagger、RoboGuice和ButterKnife.在这里我们不会去谈论这些成熟方案的范例使用或者是源代码解读,在Part2中我们要回归这些library的本质去探究“运行时注解和编译时注解”，而这才是这些DI框架的核心元素。</p>
<p>现在让我们来讨论我们今天Part部分需要探究的主题,我们在使用类似butterknife这样的DI框架时时尝试简化findViewById操作：</p>
<pre><code><span class="at_rule">@<span class="keyword">Bind(R.id.user)</span> EditText username</span>;
</code></pre><p>这种简化操作将会使得类中结构清晰，不用过量书写findViewById,ButterKnife使用的是编译时注解。接下来的两个小节部分我们对于findViewById的这个简单的操作进行两种不同方式的注解处理，以此来更深入的去解读整个Android的注解构建。在Android注解范式编程Part3章节中我将使用part2中的核心知识来解读一个开源框架<a href="https://github.com/JoanZapata/android-asyncservice" target="_blank" rel="external">android-asyncservice</a>,届时你将会明白一个大型android的注解框架其实本质都非常简单,届时希望给你收获。</p>
<h2 id="二-运行时注解">二.运行时注解</h2><pre><code><span class="annotation">@Target</span>(ElementType.FIELD)
<span class="annotation">@Retention</span>(RetentionPolicy.RUNTIME)
<span class="keyword">public</span> <span class="annotation">@interface</span> InjectView {
    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;
}
</code></pre><p>指定RetentionPolicy为RUNTIME模式,在初始化运行代码时或者运行每一个带有注解的activity等情况时均会执行对注解的操作。</p>
<p><img src="http://i.imgur.com/ylsr9M3.png" alt=""></p>
<p>实际上在处理运行时注解时最重要的也就是运行时“对@注解的代码”处理过程,如果你研读过Retrofit的源代码,你会发觉它的核心代码其实只是那个几行，其他的兼容代码(比如兼容Rxjava)都只是辅助，如果你还没有研习过，我建议你好好看看，我有一篇博客和源码对Retrofit的架构有很详细的解读：<a href="https://github.com/xiaomeixw/NoRetrofit/blob/master/library/src/main/java/mlm/noretrofit/library/core/RunTimeParser.java#L119" target="_blank" rel="external">GitHub地址</a>。</p>
<p>回归主题上来，我们来完成ViewInject的操作</p>
<pre><code>public class <span class="type">ViewInject</span> {

    private <span class="keyword">static</span> final <span class="type">String</span> <span class="type">FIND_VIEW_BY_ID</span> = <span class="string">"findViewById"</span>;

    public <span class="keyword">static</span> <span class="type">void</span> inject(<span class="type">Activity</span> activity){
        <span class="type">Class</span>&lt;? extends <span class="type">Activity</span>&gt; aClass = activity.getClass();
        <span class="type">Field</span>[] declaredFields = aClass.getDeclaredFields();
        <span class="keyword">if</span>(declaredFields !=null &amp;&amp; declaredFields.length&gt;<span class="number">0</span>){
            <span class="keyword">for</span>(<span class="type">Field</span> field : declaredFields){
                <span class="type">InjectView</span> annotation = field.getAnnotation(<span class="type">InjectView</span>.class);
                <span class="keyword">if</span>(annotation!=null){
                    <span class="type">int</span> viewId = annotation.value();
                    <span class="keyword">if</span>(viewId!= -<span class="number">1</span>){//defalut <span class="number">0</span>
                        <span class="keyword">try</span> {
                            //得到activity中的方法findViewById，参数二是参数的类型
                            <span class="type">Method</span> <span class="keyword">method</span> = aClass.getMethod(<span class="type">FIND_VIEW_BY_ID</span>, <span class="type">int</span>.class);
                            //通过<span class="keyword">method</span>.ivoke执行该方法，activity.findViewById方法方法的就是view对象
                            <span class="type">Object</span> view = <span class="keyword">method</span>.invoke(activity, viewId);
                            <span class="keyword">if</span>(view!=null){
                                //根据属性名得到其<span class="type">Set</span>方法设置它的值，这里拿到的也就是tvRunId的<span class="type">set</span>方法。
                                field.setAccessible(<span class="literal">true</span>);
                                //得到指定的属性，并给该属性<span class="type">Filed</span>设置值。
                                field.<span class="type">set</span>(activity,view);
                            }
                        } catch (<span class="type">NoSuchMethodException</span> e) {
                            e.printStackTrace();
                        } catch (<span class="type">InvocationTargetException</span> e) {
                            e.printStackTrace();
                        } catch (<span class="type">IllegalAccessException</span> e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        }
    }



}
</code></pre><p>代码非常的简单,我们拿到Activity，然后去拿该类的所有Filed字段，去看这个Filed上是否有一个叫@InjectView的注解,如果有我们此时通过反射getMethod再去拿Activity里面的一个叫public View findViewById(@IdRes int id)方法.然后method.invoke(activity, viewId)执行该方法(这里的viewId也就是你在注解中赋的值).执行完成会得到这个View对象,然后反射调用Filed的set方法将view设置给该Filed字段。</p>
<p><img src="http://i.imgur.com/Cc4ZV7Y.png" alt=""></p>
<p>MainActivity中调用ViewInject.inject(this);就可以了。</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AppCompatActivity</span> {</span>

    <span class="annotation">@InjectView</span>(<span class="type">R</span>.id.tvRunId)
    <span class="type">TextView</span> tvRunId;

    public void setTvRunId(<span class="type">TextView</span> tvRunId) {
        <span class="type">Log</span>.i(<span class="string">"MainActivity"</span>,<span class="string">"-----setTvRunId------"</span>);
        <span class="keyword">this</span>.tvRunId = tvRunId;
    }

    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) {
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        setContentView(<span class="type">R</span>.layout.activity_main);
        <span class="type">ViewInject</span>.inject(<span class="keyword">this</span>);
        tvRunId.setText(<span class="string">"--------inject--------"</span>);
    }


}
</code></pre><p>至此一个非常简单的运行时注解就完成了,因为运行时注解有很多性能上的问题，所以一般而言只要是运行时态的注解都是需要进行缓存处理的，只处理一次，然后将处理结果都缓存到集合中，根据集合中是否有来决定是否需要再次调用耗时的处理操作。Retrofit这样的运行时注解框架也是按照这个核心来尽量减少性能损耗的。</p>
<pre><code> /**
 * 利用动态代理获取<span class="type">Service</span>类对象
 *
 * @param apiEndpointUrl <span class="type">BaseUrl</span>地址
 * @param serviceClass   <span class="type">ServiceAPI</span>
 */
public <span class="keyword">static</span> &lt;T&gt; T create(<span class="type">String</span> apiEndpointUrl, <span class="type">Class</span>&lt;T&gt; serviceClass) {

    <span class="type">RetrofitLog</span>.i(<span class="string">"------Retrofit------"</span>);

    T service;

    //<span class="type">Service</span>类必须是接口
    <span class="type">Utils</span>.checkServiceInter(serviceClass);

    //<span class="type">Service</span>类上必须有注解@<span class="type">RetrofitAPI</span>标记
    boolean mWithRetrofitMark = <span class="type">Utils</span>.checkHaveRetrofitAPI(serviceClass);

    <span class="type">RetrofitLog</span>.i(<span class="string">"------service--mWithRetrofitMark----="</span>+mWithRetrofitMark);

    <span class="keyword">if</span> (mWithRetrofitMark) {

        //先从缓存中取,key是service的name
        service = <span class="type">Utils</span>.getFromCache(serviceClass.getName());

        <span class="type">RetrofitLog</span>.i(<span class="string">"------service--getFromCache----="</span>+service);

        //<span class="type">TODO</span> 一不小心写成!=null,<span class="type">How</span> stupid I <span class="type">AM</span>!
        <span class="keyword">if</span> (service == null) {


            //动态代理去拿service类对象
            service = (T) <span class="type">Proxy</span>.newProxyInstance(serviceClass.getClassLoader(), new <span class="type">Class</span>[]{serviceClass},
                    new <span class="type">NoRetrofitHandler</span>(apiEndpointUrl)
            );



            //存入<span class="type">Service</span>-<span class="type">Map</span>集合中
            T found = <span class="type">Utils</span>.putInCache(serviceClass.getName(), service);

            //担心返回的是null,防止<span class="type">Null</span>指针异常
            <span class="keyword">if</span> (found != null) {
                service = found;
            }

            //然后分解service中的方法,存入另一个专门map集合中
            setMethodDataCache(serviceClass, new <span class="type">OkHttpClient</span>());


        }

    } <span class="keyword">else</span> {
        throw new <span class="type">IllegalArgumentException</span>(<span class="string">"need use @RetrofitAPI Mark service"</span>);
    }


    <span class="type">RetrofitLog</span>.i(<span class="string">"------service------"</span>+service);

    <span class="keyword">return</span> service;


}

private <span class="keyword">static</span> <span class="type">void</span> setMethodDataCache(<span class="type">Class</span> serviceClass, <span class="type">OkHttpClient</span> okHttpClient) {
    <span class="keyword">for</span>(<span class="type">Method</span> <span class="keyword">method</span> : serviceClass.getMethods()){

        //public abstract mlm.noretrofit.<span class="type">JsonBean</span> mlm.noretrofit.<span class="type">SnakeService</span>.getBean2(java.util.<span class="type">Map</span>,java.util.<span class="type">Map</span>,java.util.<span class="type">Map</span>)
        <span class="type">RetrofitLog</span>.i(<span class="string">"mMethod.setMethodDataCache()="</span>+<span class="keyword">method</span>);

        //有@<span class="type">GET</span>和@<span class="type">POST</span>
        <span class="keyword">if</span>(<span class="keyword">method</span>.isAnnotationPresent(<span class="type">GET</span>.class)||<span class="keyword">method</span>.isAnnotationPresent(<span class="type">POST</span>.class)){
            //存入<span class="type">MethodCache</span>中
            <span class="type">Utils</span>.putInMethodCache(<span class="keyword">method</span>,new <span class="type">RunTimeParser</span>(<span class="keyword">method</span>,okHttpClient));
        }
    }
}

 /**
 * proxy表示下面<span class="number">2</span>.<span class="number">3</span> 通过 <span class="type">Proxy</span>.newProxyInstance() 生成的代理类对象。
 * <span class="keyword">method</span>表示代理对象被调用的函数。
 * args表示代理对象被调用的函数的参数。
 *
 * @param proxy
 * @param <span class="keyword">method</span>
 * @param args
 * @<span class="keyword">return</span>
 * @throws <span class="type">Throwable</span>
 */
@<span class="type">Override</span>
public <span class="type">Object</span> invoke(<span class="type">Object</span> proxy, <span class="type">Method</span> <span class="keyword">method</span>, <span class="type">Object</span>[] args) throws <span class="type">Throwable</span> {

    //从<span class="type">MethodCache</span>拿
    <span class="type">RunTimeParser</span> runTimeParser = <span class="type">Utils</span>.getFromMethodCache(<span class="keyword">method</span>);


    <span class="keyword">try</span> {
        <span class="keyword">if</span> (runTimeParser != null) {
            //将
            <span class="keyword">return</span> runTimeParser.invoke(baseUrl, args);
        } <span class="keyword">else</span> {
            <span class="keyword">return</span> <span class="keyword">method</span>.invoke(this, args);
        }
    } catch (<span class="type">InvocationTargetException</span> e) {
        throw e.getCause();

    }


}
</code></pre><p><a href="https://github.com/xiaomeixw/NoRetrofit/blob/master/library/src/main/java/mlm/noretrofit/library/core/NoRetrofit.java#L30" target="_blank" rel="external">具体代码见NoRetrofit</a>。</p>
<p>但即便如此，我仍然还是建议在个人编撰自己公司的Android注解架构时，使用编译时注解(中国国内开源的所有DI框架基本都是基于运行时注解,这个有点~~~遗憾+囧!)。我在前面提到的三个著名的DI框架都是基于编译时注解处理.</p>
<ul>
<li><p>roboguice <a href="https://github.com/roboguice/roboguice/blob/bf9043c5af085408a5d26ea8e5f857e8d0a9bdab/roboblender/src/main/java/roboguice/roboblender/RoboGuiceAnnotationProcessor.java#L25" target="_blank" rel="external">https://github.com/roboguice/roboguice/blob/bf9043c5af085408a5d26ea8e5f857e8d0a9bdab/roboblender/src/main/java/roboguice/roboblender/RoboGuiceAnnotationProcessor.java#L25</a></p>
</li>
<li><p>dagger <a href="https://github.com/square/dagger/blob/master/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java#L72" target="_blank" rel="external">https://github.com/square/dagger/blob/master/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java#L72</a></p>
</li>
<li><p>dagger2 <a href="https://github.com/google/dagger/blob/master/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java#L47" target="_blank" rel="external">https://github.com/google/dagger/blob/master/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java#L47</a> </p>
</li>
<li><p>ButterKnife <a href="https://github.com/JakeWharton/butterknife/blob/master/butterknife-compiler/src/main/java/butterknife/compiler/ButterKnifeProcessor.java#L72" target="_blank" rel="external">https://github.com/JakeWharton/butterknife/blob/master/butterknife-compiler/src/main/java/butterknife/compiler/ButterKnifeProcessor.java#L72</a></p>
</li>
</ul>
<h2 id="三-编译时注解">三.编译时注解</h2><pre><code><span class="at_rule">@<span class="keyword">Retention(RetentionPolicy.CLASS)</span>
@<span class="function">Target</span>(</span>{ <span class="tag">ElementType</span><span class="class">.FIELD</span>, <span class="tag">ElementType</span><span class="class">.TYPE</span> })
<span class="tag">public</span> <span class="at_rule">@<span class="keyword">interface</span> InjectView</span>{
    <span class="tag">int</span> <span class="tag">value</span>();
}
</code></pre><p>相对于类似<a href="https://github.com/wyouflf/xUtils/blob/192c2a886c2d467e50718c6e469de63696f5cded/library/src/com/lidroid/xutils/ViewUtils.java#L89" target="_blank" rel="external">xUtils</a>、<a href="https://github.com/yanchenko/droidparts/blob/4382976a54e7ccd5c2c3a25c7acbd7cae2c6030e/droidparts/src/org/droidparts/Injector.java#L100" target="_blank" rel="external">Droidparts</a>、<a href="https://github.com/cymcsg/UltimateAndroid" target="_blank" rel="external">UltimateAndroid</a>这样开源了多年的框架集成的运行时注解模块而言，编译时注解由于是直接将代码在编译时期就生成，所以它完全不存在性能损耗上的问题,在很大程度上，我们应该避免使用任何运行时注解框架。</p>
<p>我们还是来以解决findViewById来处理编译时注解。在这之后我会给一些API的总结,以方便去攥写更大型的编译时注解框架。</p>
<h3 id="3-1_编译时注解包(类)的操作步骤：">3.1 编译时注解包(类)的操作步骤：</h3><p>1.新建java工程：new module—&gt;Java Library,该library主要是做编译时注解解读工作。</p>
<p><img src="http://i.imgur.com/9CcBl33.png" alt=""></p>
<p>2.继承AbstractProcessor:</p>
<p>类上加上这两个注解：</p>
<ul>
<li>@SupportedAnnotationTypes的值为当前类支持的注解的完整类路径，支持通配符。</li>
<li>@SupportedSourceVersion 标识该处理器支持的源码版本</li>
</ul>
<pre><code><span class="annotation">@SupportedAnnotationTypes</span>(<span class="string">"com.sabria.noinject.InjectView"</span>)
<span class="annotation">@SupportedSourceVersion</span>(<span class="type">SourceVersion</span>.<span class="type">RELEASE_6</span>)
public <span class="class"><span class="keyword">class</span> <span class="title">NoKnifeProcessor</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AbstractProcessor</span> {</span>            
    <span class="annotation">@Override</span>
    public boolean process(<span class="type">Set</span>&lt;? <span class="keyword">extends</span> <span class="type">TypeElement</span>&gt; annotations, <span class="type">RoundEnvironment</span> roundEnv) {
        <span class="keyword">return</span> <span class="literal">false</span>;
    }                
}
</code></pre><p>注:Eclipse如果找不到AbstractProcessor，记得右键build-path add library把jdk加进来.<br>AS中： import javax.annotation.processing.AbstractProcessor;</p>
<p>3.创建resources,然后在里面创建META-INF/services/javax.annotation.processing.Processor文件.</p>
<p>里面填上自己自定义注解解析器的全路径包类名</p>
<p><img src="http://i.imgur.com/2W3JfOi.png" alt=""></p>
<p><img src="http://i.imgur.com/RzqXI3a.png" alt=""></p>
<p>4.Eclipse需要把导出为Jar,AS的话就直接引用</p>
<p><img src="http://i.imgur.com/cK9ZeNh.png" alt=""></p>
<h3 id="3-2_编译时注解的分包架构">3.2 编译时注解的分包架构</h3><p>我将采用3包机制来处理,如果你研习过Butterknife，它采用的是四包机制.</p>
<p><img src="http://i.imgur.com/6YkMUsr.png" alt=""></p>
<p>Butterknife的四包架构：</p>
<ul>
<li><p>butterknife-annotations  注解包,包中是所有的注解类对象</p>
<pre><code><span class="variable">@Retention</span>(CLASS)
<span class="variable">@Target</span>(FIELD)
public <span class="variable">@interface</span> Unbinder {
}
</code></pre></li>
<li><p>butterknife-compiler  解析包,也就是通过javac生成的编译class类.</p>
</li>
</ul>
<pre><code><span class="annotation">@AutoService</span>(<span class="type">Processor</span>.<span class="keyword">class</span>)
public <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ButterKnifeProcessor</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AbstractProcessor</span> {</span>
}
</code></pre><ul>
<li><p>butterknife 绑定包 与Activity等生命周期绑定,注入Activity(以及它里面的注解标识)到解析器中。</p>
<pre><code><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ButterKnife</span> </span>{        
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">bind</span><span class="params">(@NonNull Activity <span class="keyword">target</span>)</span> </span>{
        bind(<span class="keyword">target</span>, <span class="keyword">target</span>, Finder.ACTIVITY);
      }        
}
</code></pre></li>
<li><p>butterknife-sample 自然就是使用注解的Application应用</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">SimpleActivity</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Activity</span> {</span>

    <span class="annotation">@Bind</span>(<span class="type">R</span>.id.title) <span class="type">TextView</span> title;

     <span class="annotation">@Override</span> <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) {
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        setContentView(<span class="type">R</span>.layout.simple_activity);

        <span class="type">ButterKnife</span>.bind(<span class="keyword">this</span>);

        title.setText(<span class="string">"Butter Knife"</span>);

      }
}
</code></pre></li>
</ul>
<p>那所谓的三包机制，其实就是将注解包和绑定包放在一个包架构中，我这里实行三包相比较于四包是因为彼此的依赖关系更简单些，但没四包机制清晰。具体你在做自己框架时是启用四包还是三包，看个人喜好。</p>
<p><img src="http://i.imgur.com/Edp17GW.png" alt=""></p>
<ul>
<li><p>no-inject-api 包中含有注解来InjectView 和 绑定类 NoKnife</p>
</li>
<li><p>no-inject-process 包中含有NoKnifeProcessor解析类</p>
</li>
<li><p>app 包就是使用运行时注解应用</p>
</li>
</ul>
<h3 id="3-3_攥写注解类和绑定类">3.3 攥写注解类和绑定类</h3><p>在讲述part2章节重点的攥写编译时注解类Processor前，我们先完成no-inject-api包的工作:</p>
<p>创建在com.sabria.noinject包InjectView注解类:指定RetentionPolicy为CLASS级别.</p>
<pre><code><span class="annotation">@Retention</span>(RetentionPolicy.CLASS)
<span class="annotation">@Target</span>(ElementType.FIELD)
<span class="keyword">public</span> <span class="annotation">@interface</span> InjectView {
    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;
}
</code></pre><p>然后再main下创建一个包api，该包中再创建com.sabria.noinject，NoKnife类</p>
<pre><code>public class <span class="type">NoKnife</span> {   

    public <span class="keyword">static</span> <span class="type">void</span> inject(<span class="type">Activity</span> target) {
        <span class="type">Log</span>.e(<span class="type">NoKnife</span>.class.getCanonicalName(), <span class="string">"I AM ON INJECT"</span>);
        <span class="keyword">try</span> {
            final <span class="type">Class</span> clazz = <span class="type">Class</span>.forName(target.getClass().getCanonicalName() + <span class="string">"$$NoKnife"</span>);
            final <span class="type">Method</span> <span class="keyword">method</span> = clazz.getDeclaredMethod(<span class="string">"inject"</span>, target.getClass());
            <span class="keyword">method</span>.setAccessible(<span class="literal">true</span>);
            <span class="keyword">method</span>.invoke(clazz.newInstance(), target);
        } catch (<span class="type">ClassNotFoundException</span> e) {
            e.printStackTrace();
        } catch (<span class="type">NoSuchMethodException</span> e) {
            e.printStackTrace();
        } catch (<span class="type">InvocationTargetException</span> e) {
            e.printStackTrace();
        } catch (<span class="type">IllegalAccessException</span> e) {
            e.printStackTrace();
        } catch (<span class="type">InstantiationException</span> e) {
            e.printStackTrace();
        }
    }
}
</code></pre><p>它的工作很简单，就是拿到一个叫:MainActivity$$NoKnife.calss,然后破解形态的拿类里面的一个叫inject()的方法，然后method.invoke(clazz.newInstance(), target)去执行这个inject()方法。</p>
<p>你会很奇怪,我怎么有个类叫MainActivity$$NoKnife.calss，然后我怎么知道这个类里面有个叫inject()的方法。保持住这个求知的疑问，我们在3.4中解读。</p>
<p>在实际开发中绑定类(包)一般是最后去完成的，这里放到最前面卖关子是为了更好的去理解3.4中的内容。</p>
<p>我们先来解决一个你在创建NoKnife时你会遇到的问题，因为AndroidStudio只是将在java包中创建的类为源代码类，非sources的包创建会直接无法被识别。所以将注解包和绑定包放在一个包结构中就需要指定绑定包的path路径为soruces：</p>
<pre><code><span class="name">sourceSets</span> {
    <span class="keyword">main</span>.java.srcDirs += [<span class="string">'src/main/api'</span>]
}
</code></pre><p><img src="http://i.imgur.com/jHtEqaw.png" alt=""></p>
<h3 id="3-4_攥写解析类Processor">3.4 攥写解析类Processor</h3><p>####3.4.1 基础解读</p>
<p><img src="http://i.imgur.com/ikidrvC.png" alt=""></p>
<p>3.1中已经描述了Processor类的创建过程，这里不再做说明,我们来详细解读下(Abstract)Processor类.</p>
<pre><code><span class="tag">public</span> <span class="tag">class</span> <span class="tag">MyProcessor</span> <span class="tag">extends</span> <span class="tag">AbstractProcessor</span> {

    <span class="variable">@Override</span>
    public synchronized void <span class="function">init</span>(ProcessingEnvironment env){ }

    <span class="variable">@Override</span>
    public boolean <span class="function">process</span>(Set&lt;? extends TypeElement&gt; annoations, RoundEnvironment env) { }

    <span class="variable">@Override</span>
    public Set&lt;String&gt; <span class="function">getSupportedAnnotationTypes</span>() { }

    <span class="variable">@Override</span>
    public SourceVersion <span class="function">getSupportedSourceVersion</span>() { }

}
</code></pre><p>讲解：</p>
<ul>
<li><p>1.init(ProcessingEnvironment env):ProcessingEnviroment提供很多有用的工具类Elements, Types和Filer。</p>
</li>
<li><p>2.process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env)：处理器的主函数main()，写你的扫描、评估和处理注解的代码，以及生成Java文件。输入参数RoundEnviroment，可以让你查询出包含特定注解的被注解元素。</p>
</li>
<li><p>3.getSupportedAnnotationTypes()：这个注解处理器是注册给哪个注解的。也就是自定义的那个注解类.</p>
</li>
<li><p>4.getSupportedSourceVersion()：用来指定你使用的Java版本。通常这里返回SourceVersion.latestSupported()。</p>
</li>
</ul>
<p>继承于AbstractProcessor，然后会必需要求实现process()方法，其他的三个方法非必需实现，且在Java1.7上有更简单的实现方式(注解实现)。</p>
<p>Java1.7:getSupportedSourceVersion和getSupportedAnnotationTypes可以使用注解来解决</p>
<pre><code><span class="variable">@SupportedSourceVersion</span>(SourceVersion.<span class="function">latestSupported</span>())
<span class="variable">@SupportedAnnotationTypes</span>({
   <span class="comment">// 合法注解全名的集合</span>
 })
public class MyProcessor extends AbstractProcessor {

    <span class="variable">@Override</span>
    public synchronized void <span class="function">init</span>(ProcessingEnvironment env){ }

    <span class="variable">@Override</span>
    public boolean <span class="function">process</span>(Set&lt;? extends TypeElement&gt; annoations, RoundEnvironment env) { }
}
</code></pre><p>所以范例：</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">LittleKnifeProcessor</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AbstractProcessor</span> {</span>

    <span class="annotation">@Override</span>
    public <span class="type">SourceVersion</span> getSupportedSourceVersion() {
        <span class="keyword">return</span> <span class="type">SourceVersion</span>.latestSupported();
    }

    <span class="annotation">@Override</span>
    public <span class="type">Set</span>&lt;<span class="type">String</span>&gt; getSupportedAnnotationTypes() {
        <span class="type">LinkedHashSet</span>&lt;<span class="type">String</span>&gt; annotataions = <span class="keyword">new</span> <span class="type">LinkedHashSet</span>&lt;&gt;();
        annotataions.add(<span class="type">InjectView</span>.<span class="keyword">class</span>.getCanonicalName());
        <span class="keyword">return</span> annotataions;
    }

    <span class="annotation">@Override</span>
    public boolean process(<span class="type">Set</span>&lt;? <span class="keyword">extends</span> <span class="type">TypeElement</span>&gt; annoations, <span class="type">RoundEnvironment</span> env) { }

}
</code></pre><p>或者：</p>
<pre><code><span class="annotation">@SupportedAnnotationTypes</span>(<span class="string">"com.sabria.noinject.InjectView"</span>)
<span class="annotation">@SupportedSourceVersion</span>(<span class="type">SourceVersion</span>.<span class="type">RELEASE_6</span>)
public <span class="class"><span class="keyword">class</span> <span class="title">LittleKnifeProcessor</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AbstractProcessor</span> {</span>

    <span class="annotation">@Override</span>
    public boolean process(<span class="type">Set</span>&lt;? <span class="keyword">extends</span> <span class="type">TypeElement</span>&gt; annoations, <span class="type">RoundEnvironment</span> env) { }

}
</code></pre><p>这也就代表着我们只需要处理init()和process()方法，而init()方法则相对比较固定，它一般提供工具类Elements, Types和Filer。</p>
<pre><code> <span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnv)</span> </span>{
    <span class="keyword">super</span>.init(processingEnv);
    Types typeUtils = processingEnv.getTypeUtils();
    Elements elementUtils = processingEnv.getElementUtils();
    Filer filer = processingEnv.getFiler();
    Messager messager = processingEnv.getMessager();
}
</code></pre><p>####3.4.2 Element解读</p>
<p>首先我们对一个概念做解读:<a href="http://www.apihome.cn/api/java/Element.html" target="_blank" rel="external">Element</a>，在javax.lang.model.element包下：</p>
<blockquote>
<p>public interface Element<br>表示一个程序元素，比如包、类或者方法。每个元素都表示一个静态的语言级构造（不表示虚拟机的运行时构造）。</p>
</blockquote>
<p>这个概念很难理解，是的，因为我们很少去开发会用到类似API，所以你先浅显的理解为它是包，或者是类，又可以是方法就行了，它是一个一个的程序元素。</p>
<p>同时正是因为Element涵盖了很广范畴意义的元素，所以我们以一个很常见的类来将Element进行划分</p>
<pre><code><span class="keyword">package</span> com.sabria.noinject.process;  <span class="comment">// PackageElement</span>

<span class="keyword">import</span> java.io.Serializable;

<span class="comment">/**
 * Created by xiongwei,An Android project Engineer.
 * Date:2016-01-12  14:44
 * Base on Meilimei.com (PHP Service)
 * Describe:
 * Version:1.0
 * Open source
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElementDemo</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>{ <span class="comment">//TypeElement</span>

    <span class="keyword">private</span> <span class="keyword">int</span> num;      <span class="comment">// VariableElement</span>

    <span class="function"><span class="keyword">public</span> <span class="title">ElementDemo</span><span class="params">()</span> </span>{   <span class="comment">//ExecuteableElement</span>
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>{<span class="comment">// ExecuteableElement   其中的int num 参数是TypeElement</span>
        <span class="keyword">this</span>.num = num;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span> </span>{<span class="comment">// ExecuteableElement</span>
        <span class="keyword">return</span> num;
    }
}
</code></pre><p>在Java的API文档中描述的比较清晰彼此的继承关系:</p>
<p><img src="http://i.imgur.com/erlX5Eo.png" alt=""></p>
<p><a href="http://www.oschina.net/uploads/doc/javase-6-doc-api-zh_CN/javax/lang/model/element/PackageElement.html" target="_blank" rel="external">javax.lang.model.element.PackageElement</a>：表示一个”包程序”元素。提供对有关”包”及其”成员”的信息的访问。(更简单点理解就是：package信息)</p>
<p><a href="http://www.oschina.net/uploads/doc/javase-6-doc-api-zh_CN/javax/lang/model/element/TypeElement.html" target="_blank" rel="external">javax.lang.model.element.TypeElement</a>：表示一个类或接口元素，提供对有关”类型及其成员”的信息的访问 (更简单点理解就是：类或者接口)</p>
<p><a href="http://www.oschina.net/uploads/doc/javase-6-doc-api-zh_CN/javax/lang/model/element/VariableElement.html" target="_blank" rel="external">javax.lang.model.element.VariableElement</a>：表示一个字段、enum 常量、方法或构造方法参数、局部变量或异常参数。(更简单点理解就是：Field字段)</p>
<p><a href="http://www.oschina.net/uploads/doc/javase-6-doc-api-zh_CN/javax/lang/model/element/ExecutableElement.html" target="_blank" rel="external">javax.lang.model.element.ExecutableElement</a>：表示某个类或接口的方法、构造方法或初始化程序（静态或实例），包括注释类型元素。(更简单点理解就是：方法或者构造函数)</p>
<p>####3.4.3 init()继续解读</p>
<p>我们来一个一个看这四个帮助类:</p>
<ul>
<li><p>TypeUtils 处理<a href="http://www.766.com/doc/javax/lang/model/type/class-use/TypeMirror.html" target="_blank" rel="external">TypeMirror</a>的帮助类，它有asElement()、isSubtype()等方法</p>
</li>
<li><p>ElementUtils 它包含很多Elements(一组Element)的帮助类信息，它有getPackageElement()、getTypeElement()、getPackageOf()方法。</p>
</li>
<li><p>Filer 创建文件</p>
</li>
<li><p>Messager 异常消息提醒</p>
</li>
</ul>
<p>何为TypeMirror：表示 Java 编程语言中的类型。这些类型包括基本类型、声明类型（类和接口类型）、数组类型、类型变量和 null 类型。还可以表示通配符类型参数、executable 的签名和返回类型，以及对应于包和关键字 void 的伪类型。</p>
<p>####3.4.4 process()方法中常用基础API解读</p>
<pre><code><span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? <span class="keyword">extends</span> TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>{
}
</code></pre><p>1.获取所有含有@InjectView注解的Elements.</p>
<pre><code>roundEnv.<span class="function"><span class="title">getElementsAnnotatedWith</span><span class="params">(InjectView.class)</span></span>
</code></pre><p>返回的结果:Element元素的Set集合Set&lt;? extends Element&gt; annotatedElements</p>
<p>2.判断被标注@InjectView的Element是否是Class</p>
<pre><code>annotatedElement.<span class="function"><span class="title">getKind</span><span class="params">()</span></span> != ElementKind.CLASS
</code></pre><p>3.如果annotatedElement是ElementKind.CLASS，那么在某种程度上我们就可以直接将它当成TypeElement(仔细看我上面给的3.4.2 关于Element的概念,我们的TypeElement的含义就是类或者接口,所以判断为ElementKind.CLASS后就可以强转)</p>
<pre><code>TypeElement typeElement = <span class="list">(<span class="keyword">TypeElement</span>)</span> annotatedElement<span class="comment">;</span>
</code></pre><p>4.判断classElement是否是被Public修饰</p>
<pre><code>classElement.<span class="function"><span class="title">getModifiers</span><span class="params">()</span></span>.<span class="function"><span class="title">contains</span><span class="params">(Modifier.PUBLIC)</span></span>
</code></pre><p>5.从Element元素的Set集合迭代出一个Element后,拿它的包名</p>
<pre><code>final String packageName = processingEnv.getElementUtils<span class="params">()</span>.getPackageOf<span class="params">(firstAnnotatedElement)</span>.toString<span class="params">()</span>;
</code></pre><p>API远不止5个,但对于这个findViewById已经足够了,在Part3中我会根据实践框架专门讲解其他的API。</p>
<p>####3.4.5 process()内部解读</p>
<pre><code>private <span class="literal">static</span> <span class="keyword">final</span> <span class="built_in">String</span> LITTLE_KNIFE_TAG = <span class="string">"$$NoKnife"</span>;

<span class="annotation">@Override</span>
public boolean process(<span class="built_in">Set</span>&lt;? <span class="keyword">extends</span> TypeElement&gt; annotations, RoundEnvironment roundEnv) {

    <span class="comment">//1.去拿所有的含有@InjectView的元素Element</span>
    <span class="keyword">final</span> <span class="built_in">Set</span>&lt;? <span class="keyword">extends</span> <span class="built_in">Element</span>&gt; annotatedElements = roundEnv
            .getElementsAnnotatedWith(InjectView.<span class="keyword">class</span>);

    <span class="comment">//2.判断size</span>
    <span class="keyword">if</span> (annotatedElements.size() &gt; <span class="number">0</span>) {

        <span class="comment">//迭代set</span>
        <span class="keyword">final</span> <span class="built_in">Element</span> firstAnnotatedElement = annotatedElements.iterator().next();

        <span class="comment">//获得Activity的包名称</span>
        <span class="keyword">final</span> <span class="built_in">String</span> packageName = processingEnv.getElementUtils().getPackageOf(firstAnnotatedElement).toString();

        <span class="comment">//获得Activity的名称          </span>
        <span class="keyword">final</span> <span class="built_in">String</span> hostActivityName = firstAnnotatedElement.getEnclosingElement().getSimpleName().toString();

        <span class="comment">//3.给compile-time 生成的 .java 文件 取一个名称 ： 比如 MainActivity$$NoKnife </span>
        <span class="keyword">final</span> <span class="built_in">String</span> newSourceName = hostActivityName + LITTLE_KNIFE_TAG;

        <span class="comment">//4.使用JavaWriter来攥写这个java文件    </span>
        <span class="keyword">try</span> {
            JavaWriter writer = createWriter(newSourceName);
            <span class="comment">//攥写这个.class的头部包有关信息</span>
            createHeader(annotatedElements, packageName, writer);
            <span class="comment">//攥写class名称</span>
            beginType(newSourceName, writer);
            <span class="comment">//攥写.class的方法</span>
            beginMethod(hostActivityName, writer);
            <span class="comment">//攥写findViewById()</span>
            emitStatements(annotatedElements, hostActivityName, writer);
            <span class="comment">//关闭JavaWrite</span>
            emitClose(writer);
        } <span class="keyword">catch</span> (IOException e) {
            e.printStackTrace();
        }

    }

    <span class="keyword">return</span> <span class="keyword">false</span>;
}
</code></pre><p>我们来看这个process()究竟在干什么：</p>
<p>第一步：这个process()会拿到编译时的所有的类文件去找这些类文件有哪些类文件里面有@InjectView注解；</p>
<p>第二步:迭代找到使用@InjectView注解的Activity,然后获取这个Activity的包名和class名;</p>
<p>第三步:给我们要生成的一个新的.class文件取个文件名，文件名我们命名为：hostActivityName + “$$NoKnife”; <strong>所以这一步就告诉了我们要生成一个新的class类，这个类名会比如为：MainActivity$$NoKnife 。 这就是为什么绑定类会让我去找一个类叫MainActivity$$NoKnife.class.</strong></p>
<pre><code><span class="keyword">final</span> <span class="keyword">Class</span> clazz = <span class="keyword">Class</span>.forName(<span class="type">target</span>.getClass().getCanonicalName() + <span class="string">"$$NoKnife"</span>);
</code></pre><p>第四步:使用JavaWriter来攥写这个java文件。</p>
<p>####3.4.6 JavaWriter</p>
<p><a href="https://github.com/square/javapoet/releases" target="_blank" rel="external">JavaWriter</a>由大神级公司<a href="https://github.com/square" target="_blank" rel="external">Square</a>开源,官网上的说明如下：</p>
<pre><code>A Java API <span class="keyword">for</span> generating <span class="class">.java</span> source files.
</code></pre><p>很直白的解读:专用于来生成.java文件.  很简单理解：就是你之前是自己一行一行的自己写.java代码，现在你已经预知你这个.java文件是怎么样的了(有哪些类，有哪些元素，有哪些方法)，那么你就让程序JavaWriter来帮你写这个.java文件.</p>
<p>在4 Dec 2014,Square公司发布完javawriter-2.5.1后.javawriter被重构并改名为<a href="https://github.com/square/javapoet" target="_blank" rel="external">javapoet</a>。截至到目前已发布到javapoet-1.5.1 。javapoet的使用在API上要相比较于javawriter简化很多。所以推荐你以后使用javapoet。</p>
<p>由于javawriter相关主页和API被撤换,在 javapoet上已经找不到API文档了，你可以访问如下路径去查看javawriter使用和源码。</p>
<p><a href="https://github.com/DirtyUnicorns/android_external_square_javawriter/tree/6cd498aeb47375a58bc2f3cb647d36edca647c90" target="_blank" rel="external">https://github.com/DirtyUnicorns/android_external_square_javawriter/tree/6cd498aeb47375a58bc2f3cb647d36edca647c90</a></p>
<pre><code>writer.emitPackage<span class="params">(<span class="string">"com.example"</span>)</span>       <span class="comment">//写包名</span>
    .beginType<span class="params">(<span class="string">"com.example.Person"</span>, <span class="string">"class"</span>, EnumSet.of<span class="params">(PUBLIC, FINAL)</span>)</span>   <span class="comment">//写class名</span>
    .emitField<span class="params">(<span class="string">"String"</span>, <span class="string">"firstName"</span>, EnumSet.of<span class="params">(PRIVATE)</span>)</span>    <span class="comment">//写字段</span>
    .emitField<span class="params">(<span class="string">"String"</span>, <span class="string">"lastName"</span>, EnumSet.of<span class="params">(PRIVATE)</span>)</span>     <span class="comment">//写字段</span>
    .emitJavadoc<span class="params">(<span class="string">"Returns the person's full name."</span>)</span>           <span class="comment">//写doc注释</span>
    .beginMethod<span class="params">(<span class="string">"String"</span>, <span class="string">"getName"</span>, EnumSet.of<span class="params">(PUBLIC)</span>)</span>     <span class="comment">//写方法</span>
    .emitStatement<span class="params">(<span class="string">"return firstName + \" \" + lastName"</span>)</span>     <span class="comment">//写返回</span>
    .endMethod<span class="params">()</span>                                              
    .endType<span class="params">()</span>;
</code></pre><p>攥写出来.java类内容为如下:</p>
<pre><code>package com.example;

public final class <span class="keyword">Person</span> {
  private String firstName;
  private String lastName;
  /**
   * Returns the <span class="keyword">person</span>'s full name.
   */
  public String getName() {
    return firstName + <span class="string">" "</span> + lastName;
  }
}
</code></pre><p>javawriter就是很简单的将你要写的每一行代码都转化成程序自己去写,一行一行对应。</p>
<p>所以我们继续回到原来的示例中来看process()里面的JavaWriter究竟做了什么：</p>
<pre><code><span class="comment">//创建JavaWriter</span>
 JavaWriter writer = createWriter<span class="params">(newSourceName)</span>;
<span class="comment">//攥写这个.class的头部包有关信息</span>
createHeader<span class="params">(annotatedElements, packageName, writer)</span>;
<span class="comment">//攥写class名称</span>
beginType<span class="params">(newSourceName, writer)</span>;
<span class="comment">//攥写.class的方法</span>
beginMethod<span class="params">(hostActivityName, writer)</span>;
<span class="comment">//攥写findViewById()</span>
emitStatements<span class="params">(annotatedElements, hostActivityName, writer)</span>;
<span class="comment">//关闭JavaWrite</span>
emitClose<span class="params">(writer)</span>;
</code></pre><p>1.创建JavaWriter： createWriter(.java文件的类名)</p>
<pre><code><span class="keyword">private</span> JavaWriter <span class="built_in">createWriter</span>(<span class="keyword">String</span> newSourceName) <span class="keyword">throws</span> IOException {
    <span class="keyword">final</span> JavaFileObject sourceFile = processingEnv.getFiler().createSourceFile(newSourceName);
    <span class="keyword">return</span> <span class="keyword">new</span> JavaWriter(sourceFile.openWriter());
}
</code></pre><p>2.createHeader写包写导入</p>
<pre><code>/
<span class="built_in">*</span> 最终写成的是如下内容:
<span class="built_in">*</span> 
<span class="built_in">*</span> package sabria.noinject;
<span class="built_in">*</span> 
<span class="built_in">*</span> <span class="built_in">import</span> android.widget.TextView;
<span class="built_in">*</span> <span class="built_in">import</span> sabria.noinject.MainActivity;
<span class="built_in">*</span>
<span class="built_in">*</span>/
private void createHeader<span class="params">(Set&lt;? extends Element&gt; annotatedElements, String packageName,
                          JavaWriter writer)</span>
        throws IOException {
    <span class="comment">//1.写PackageName</span>
    writer.emitPackage<span class="params">(packageName)</span>;              
    Map&lt;String, Element&gt; nonRepeatedImports = new HashMap&lt;&gt;<span class="params">()</span>;

    <span class="keyword">for</span> <span class="params">(Element element : annotatedElements)</span> {
        TypeMirror elementType = element.asType<span class="params">()</span>;         
        <span class="keyword">if</span> <span class="params">(isSubtypeOfType<span class="params">(elementType, <span class="string">"android.view.View"</span>)</span>)</span> {
            nonRepeatedImports.put<span class="params">(element.asType<span class="params">()</span>.toString<span class="params">()</span>, element)</span>;
        } <span class="keyword">else</span> {
            processingEnv.getMessager<span class="params">()</span>
                    .printMessage<span class="params">(Diagnostic.Kind.ERROR, String.format<span class="params">(
                            <span class="string">"Variable: %s, is not of a type that subclasses android.view.View. @%s can only be used with Views"</span>,
                            element.getSimpleName<span class="params">()</span>.toString<span class="params">()</span>,
                            InjectView.class.getSimpleName<span class="params">()</span>)</span>)</span>;
        }
    }
    <span class="keyword">for</span> <span class="params">(String importString : nonRepeatedImports.keySet<span class="params">()</span>)</span> {
        <span class="comment">//2.写导包</span>
        writer.emitImports<span class="params">(importString)</span>;
    }
}
</code></pre><p>3.beginType写class名称</p>
<pre><code>/**
* 最终写成的是如下内容:
* public class MainActivity$<span class="variable">$LittleKnife</span> {}
*/
private void beginType(String newSourceName, JavaWriter writer) throws IOException {
    writer.beginType(newSourceName, <span class="string">"class"</span>, EnumSet.of(Modifier.PUBLIC));
}
</code></pre><p>4.beginMethod写method名称</p>
<pre><code><span class="comment"><span class="markdown">/**
<span class="bullet">* </span>最终写成的是如下内容:
<span class="bullet">* </span>public void inject(MainActivity target) {}
*/</span></span>
private <span class="keyword">void</span> beginMethod(<span class="built_in">String</span> hostActivityname, JavaWriter writer) throws IOException {
    writer.beginMethod(<span class="string">"void"</span>, <span class="string">"inject"</span>, EnumSet.of(Modifier.PUBLIC), hostActivityname,
            <span class="string">"target"</span>);
}
</code></pre><p>注意这里: 我们在beginMethod方法中给方法的命名就是inject()。这也就能解释为什么要找MainActivity$$NoKnife.calss，然后通过反射去执行这个类里面有个叫inject()的方法。</p>
<p>5.emitStatements写method中内容</p>
<pre><code><span class="comment">/**
* 最终写成的是如下内容:
* target.textView = (TextView)target.findViewById(2131492944);
*/</span>
private void emitStatements(<span class="operator"><span class="keyword">Set</span>&lt;? extends <span class="keyword">Element</span>&gt; annotatedElements, <span class="keyword">String</span> hostActivityname,
                            JavaWriter writer) throws IOException {
    <span class="keyword">for</span> (<span class="keyword">Element</span> <span class="keyword">element</span> : annotatedElements) {
        writer.emitStatement(<span class="string">"(("</span> + hostActivityname + <span class="string">")target)."</span> + <span class="keyword">element</span>
                .getSimpleName().toString() + <span class="string">" = "</span> + <span class="string">"("</span> + <span class="keyword">element</span>.asType()
                .toString() + <span class="string">")target.findViewById("</span> + <span class="keyword">element</span>.getAnnotation(InjectView.<span class="keyword">class</span>)
                .<span class="keyword">value</span>() + <span class="string">")"</span>);</span>
    }
}
</code></pre><p>6.关闭JavaWrite</p>
<pre><code><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">emitClose</span><span class="params">(JavaWriter writer)</span> <span class="keyword">throws</span> IOException </span>{
    writer.endMethod();
    writer.endType();
    writer.close();
}
</code></pre><p>####3.4.7 生成.class</p>
<p>首先我们先去搞清楚编译时注解完成后，生成的.class文件究竟在哪里？</p>
<p>关于这个问题我曾在<a href="https://github.com/JakeWharton/butterknife/issues/408" target="_blank" rel="external">GitHub</a>上询问过JakeWharton,他表示根据java开发环境和操作系统不同而有所不同(It depends on which Java compiler you are using and which build system you are using).如果你使用的是AndroidStudio你其实可以在如下的路径中找到该.class文件:</p>
<p><img src="http://i.imgur.com/iwWyKbV.png" alt=""></p>
<p>比如我的路径:<br>C:\Users\win7\Documents\GitHub\NoInject\app\build\intermediates\classes\debug\sabria\noinject</p>
<p>我们来做比对：</p>
<p><img src="http://i.imgur.com/V4gyEuf.png" alt=""></p>
<h4 id="3-4-8_流程再走一遍">3.4.8 流程再走一遍</h4><p>经过上面的几个过程，我们已经完成了findViewById的编译时注解代码部分，我们接着以“最终代码流向”的方式总结下整体的流程,并对本质做解读.</p>
<p><img src="http://i.imgur.com/5ZTOlQR.png" alt=""></p>
<p>其实在流程图中我们其实很明显的看到，NoKnife.inject(this)其实只是去执行了所有View的findViewById()操作,经过这样一个流程简化了形式上的书写，其实我们回归到本质去看ButterKnife：</p>
<blockquote>
<p>其实只是把以前findViewById()这行代码隐藏到了编译时生成的一个新的.class文件中,在onCreate()的NoKnife.inject(this)时去执行这个新的.class文件中生成的一批findViewById()代码。</p>
</blockquote>
<h4 id="3-4-9_一些小细节和技巧">3.4.9 一些小细节和技巧</h4><p>1.技巧1：让工具帮你自动创建META-INF/services/javax.annotation.processing.Processor文件</p>
<blockquote>
<p>答:使用谷歌的注解帮助类：<a href="https://github.com/google/auto/tree/master/service" target="_blank" rel="external">@AutoService</a>.你只需要引入该类，然后再Processor类上打注解@AutoService即可自己帮你生成javax.annotation.processing.Processor文件。</p>
</blockquote>
<p>2.技巧2：注解中Processor类中尽量不能有GBK的中文注释,具体你自己在实际操作中会遇到该情况的.</p>
<p>3.技巧3：尽量使用@SupportedSourceVersion和@SupportedAnnotationTypes代替继承后要覆写的方法</p>
<p>4.技巧4：包结构的划分</p>
<p>建议四包结构,如果你熟练了,三包也是比较推荐的.<br>我将我的三包的build.gradle文件展示下，你好清楚彼此的依存关系：</p>
<ul>
<li><p>no-inject-api 包（它是android - library类型module）的build.gradle:</p>
<pre><code>apply plugin: <span class="string">'com.android.library'</span>

android {
    compileSdkVersion <span class="number">23</span>
    buildToolsVersion <span class="string">"23.0.1"</span>

    defaultConfig {
        minSdkVersion <span class="number">15</span>
        targetSdkVersion <span class="number">23</span>
        versionCode <span class="number">1</span>
        versionName <span class="string">"1.0"</span>
    }
    buildTypes {
        release {
            minifyEnabled <span class="keyword">false</span>
            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span>
        }
    }

    <span class="keyword">sourceSets</span> {
        main.java.srcDirs += [<span class="string">'src/main/api'</span>]
    }
}

<span class="keyword">dependencies</span> {
    <span class="keyword">compile</span> <span class="keyword">fileTree</span>(dir: <span class="string">'libs'</span>, <span class="keyword">include</span>: [<span class="string">'*.jar'</span>])
    <span class="keyword">compile</span> <span class="string">'com.squareup:javawriter:2.5.0'</span>
}
</code></pre></li>
<li><p>no-inject-process 包(它是java代码类型module)的build.gradle:</p>
<pre><code><span class="title">apply</span> plugin: <span class="string">'java'</span>

sourceSets {
    <span class="title">main</span> {
        <span class="title">java</span> {
            <span class="title">srcDirs</span> =  [<span class="string">'src/main/java'</span>, <span class="string">'../no-inject-api/src/main/java'</span>]
        }

    }
}
</code></pre></li>
</ul>
<pre><code><span class="keyword">dependencies</span> {
    <span class="keyword">compile</span> <span class="keyword">fileTree</span>(dir: <span class="string">'libs'</span>, <span class="keyword">include</span>: [<span class="string">'*.jar'</span>])
    <span class="keyword">compile</span> <span class="keyword">project</span>(<span class="string">':no-inject-api'</span>)
}
</code></pre><p>注意这里指定了no-inject-api/src/main/java 为 source root.</p>
<ul>
<li>app 包(它是Android应用module类型)的build.gradle:</li>
</ul>
<pre><code><span class="keyword">buildscript</span> {
    <span class="keyword">repositories</span> {
        mavenCentral()
    }
    <span class="keyword">dependencies</span> {
        <span class="keyword">classpath</span> <span class="string">'com.android.tools.build:gradle:1.2.3'</span>
        <span class="keyword">classpath</span> <span class="string">'com.neenbedankt.gradle.plugins:android-apt:1.+'</span>
    }
}
apply plugin: <span class="string">'android'</span>
apply plugin: <span class="string">'android-apt'</span>


<span class="keyword">buildscript</span> {
    <span class="keyword">repositories</span> {
        jcenter()
    }
    <span class="keyword">dependencies</span> {
        <span class="comment">// the latest version of the android-apt plugin</span>
        <span class="keyword">classpath</span> <span class="string">'com.neenbedankt.gradle.plugins:android-apt:1.4'</span>
    }
}


android {
    compileSdkVersion <span class="number">23</span>
    buildToolsVersion <span class="string">"23.0.1"</span>

    defaultConfig {
        applicationId <span class="string">"sabria.noinject"</span>
        minSdkVersion <span class="number">15</span>
        targetSdkVersion <span class="number">23</span>
        versionCode <span class="number">1</span>
        versionName <span class="string">"1.0"</span>
    }
}

<span class="keyword">dependencies</span> {
    <span class="keyword">compile</span> <span class="keyword">fileTree</span>(dir: <span class="string">'libs'</span>, <span class="keyword">include</span>: [<span class="string">'*.jar'</span>])
    <span class="keyword">compile</span> <span class="string">'com.android.support:appcompat-v7:23.1.0'</span>
    <span class="keyword">compile</span> <span class="keyword">project</span>(<span class="string">':no-inject-api'</span>)
    apt  <span class="keyword">project</span>(<span class="string">':no-inject-process'</span>)
}
</code></pre><p>5.技巧5：注解生成的类文件在</p>
<p>比如:SimpleActivity$$ViewBinder.class文件在：<br>C:\AndroidStudio\opensource\butterknife-master\butterknife-sample\build\intermediates\classes\debug\com\example\butterknife</p>
<p>6.技巧6: 异常报错的处理？</p>
<p>答:首先我们需要明白,在process()中抛出一个异常，那么运行注解处理器的JVM将会崩溃（就像其他Java应用一样）。因此在init()中，我们会获得了一个Messager对象的引用。这个Messager对象提供给注解处理器一个报告错误、警告以及提示信息的途径。</p>
<pre><code>public void error(Element e, String msg) {
    messager.printMessage(Diagnostic.<span class="keyword">Kind</span>.ERROR, msg, e);
  }
</code></pre><p>7.技巧7：如果我有多个Processor解析类,javax.annotation.processing.Processor要怎么写:</p>
<p>答:我们以dagger的为例,直接在该文件中依次换行排布.</p>
<p><img src="http://i.imgur.com/sXFa1PU.png" alt=""></p>
<p>8.你可能会遇到的一个BUG:</p>
<pre><code>java.lang.IllegalAccessException: access <span class="keyword">to</span> <span class="type">class</span> <span class="keyword">not</span> allowed 
</code></pre><p>从而导致textView.setText(“SUCCESS”)的空指针异常。</p>
<p>这种情况一般是发生在反射时访问了一个private修饰的类或字段或方法,或者类、字段或方法上没有修饰符，此时的包层级就是属于defalut，只允许同一包中的类可以访问。</p>
<p>谈到这里就引深下:</p>
<p><img src="http://i.imgur.com/Kleyttb.png" alt=""></p>
<p>注意：Java的访问控制是停留在编译层的，也就是它不会在.class文件中留下任何的痕迹，只在编译的时候进行访问控制的检查。其实，通过反射的手段，是可以访问任何包下任何类中的成员，例如，访问类的私有成员也是可能的。</p>
<p>区别：</p>
<p>-（1）public：可以被所有其他类所访问。</p>
<p>-（2）private：只能被自己访问和修改。</p>
<p>-（3）protected：自身，子类及同一个包中类可以访问。</p>
<p>-（4）default（默认）：同一包中的类可以访问，声明时没有加修饰符，认为是friendly。</p>
<p>然后探究下反射的权限问题:</p>
<ul>
<li><p>public的static的方法：没有任何权限问题，getMethod()就可以满足，根本不用getDeclaredMethod出马，更不用setAccessiable(true)</p>
</li>
<li><p>public的非静态的方法：没有任何权限问题，getMethod()就可以满足，根本不用getDeclaredMethod出马，更不用setAccessiable(true)，但是，在invoke时，第一个参数必须是具体的某一个对象，static的可要可不要</p>
</li>
<li><p>protected的非静态方法：必须使用getDeclaredMethod，不能使用getMethod，不用设置setAccessiable(true)</p>
</li>
<li><p>friendly的非静态方法：必须使用getDeclaredMethod，不能使用getMethod，不用设置setAccessiable(true)</p>
</li>
<li><p>private的非静态方法：必须使用getDeclaredMethod，不能使用getMethod，必须设置setAccessiable(true)</p>
</li>
</ul>
<p>然后我们回归到我发生这个bug的问题上来:</p>
<p>首先：textView.setText(“SUCCESS”)报空指针，肯定是textView为null,也就是说findViewById都没有执行，经过断点调试,发觉在执行NoKnife.inject(activity)时</p>
<pre><code><span class="keyword">final</span> <span class="keyword">Class</span> clazz = <span class="keyword">Class</span>.forName(<span class="type">target</span>.getClass().getCanonicalName() + <span class="string">"$$NoKnife"</span>);
</code></pre><p>报了IllegalAccessException异常。</p>
<p>然后我去分析生成的MainActivity$$LittleKnife.class发现</p>
<pre><code>class MainActivity$<span class="variable">$LittleKnife</span> {
}
</code></pre><p>MainActivity$$LittleKnife.class默认的是修饰属性defalut,也就是同一包中类才可以访问。</p>
<p>此时我才觉悟到这很可能是包名的问题导致的：</p>
<p>app的包名: sabria.noinject</p>
<p>no-inject-api的包名： com.sabria.noinject</p>
<p>no-inject-process的包名: com.sabria.noinject.process</p>
<p>三个包的包名完全不同，也就表示这三个包中的类是完全不能互相访问defalut修饰类的，解决方案有两种：</p>
<p>1.将三个包的包名修改为相同；</p>
<p>2.javaWrite在write class名时给个PUBLIC的修饰:</p>
<pre><code>writer.<span class="keyword">begin</span><span class="variable">Type</span>(new<span class="variable">SourceName</span>, <span class="string">"class"</span>);
</code></pre><p>修改为了:</p>
<pre><code><span class="tag">writer</span><span class="class">.beginType</span>(<span class="tag">newSourceName</span>, "<span class="tag">class</span>", <span class="tag">EnumSet</span><span class="class">.of</span>(<span class="tag">Modifier</span><span class="class">.PUBLIC</span>));
</code></pre><p>最后生成的MainActivity$$LittleKnife也就是public修饰的了。</p>
<pre><code>public class MainActivity$<span class="variable">$LittleKnife</span> {
}
</code></pre><p>BUG解决.</p>
<hr>
<p>至此注解范式编程的Part2章节攥写完成,如果你对part3很有兴趣，希望你可以好好自己在代码层面上去操作今天part2的”编译时注解的部分代码”,你会发觉这是一个很有趣的过程。《注解范式编程Part3部分-解构大型注解框架<a href="https://github.com/JoanZapata/android-asyncservice" target="_blank" rel="external">android-asyncservice</a>》waiting…..</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/01/11/ZTN01_3/" itemprop="url">
                【正谈1月】Android注解范式编程Part1
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-01-11T21:32:09+08:00" content="2016-01-11">
            2016-01-11
          </time>
        </span>

        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>Android注解范式编程Part1</p>
<h2 id="一-概念">一.概念</h2><h3 id="1-1_含义:">1.1 含义:</h3><p>Android的注解是来源于Java本身,它相当于一种标记,加上这种标记后就等于给程序打上了一种“注释和解读”。java编译器和程序可以通过反射来获取此标记,然后根据定义的这个注解的“动作代码”去执行相应的操作。</p>
<h3 id="1-2_注解的定义格式：">1.2 注解的定义格式：</h3><pre><code>@头注释
<span class="variable">@interface</span>自定义{
    属性元素...
}
</code></pre><p>注解的格式由三个部分组成:</p>
<ul>
<li><em>1.@头注释：说明该注解的使用标注环境和场景；</em></li>
<li><em>2.@interface修饰：定义为该对象为自定义注解对象；</em></li>
<li><em>3.属性元素 ： 类似于参数(对象)量概念。</em></li>
</ul>
<p>比如下面的一个最简单的注解格式：</p>
<pre><code><span class="keyword">public</span> @<span class="class"><span class="keyword">interface</span> <span class="title">MyAnnotation</span> </span>{
    <span class="comment">//......</span>
}
</code></pre><p>或者一个更复杂的:</p>
<pre><code><span class="annotation">@Retention</span>(RetentionPolicy.RUNTIME)
<span class="annotation">@Target</span>(ElementType.METHOD)
<span class="annotation">@Documented</span>
<span class="keyword">public</span> <span class="annotation">@interface</span> GET {
    String value() <span class="keyword">default</span> <span class="string">""</span>;
}
</code></pre><h3 id="1-3_注解的书写格式：">1.3 注解的书写格式：</h3><p>也就是如何去用注解：</p>
<pre><code><span class="decorator">@ + 英文关键词</span>
</code></pre><p>比如Java提供给我们覆写方法的注解“@Override”，上面示例的使用为@MyAnnotation和@GET.</p>
<h3 id="1-4_系统提供的三个标准注解">1.4 系统提供的三个标准注解</h3><ul>
<li><em>@Override，表示当前的方法定义将覆盖超类中的方法。</em>    </li>
<li><em>@Deprecated，使用了注解为它的元素编译器将发出警告，因为注解@Deprecated是不赞成使用的代码，被弃用的代码。</em></li>
<li><em>@SuppressWarnings，关闭不当编译器警告信息。</em></li>
</ul>
<h2 id="二-自定义注解">二.自定义注解</h2><p>系统提供的三个标准注解是无法满足Android开发的生产环境的,所以我们必须自定义注解,然后解析该注解标识的对象(类、方法、字段等),完成相应业务逻辑.</p>
<p>Java为我们提供了一个元注解的概念,它的作用就是负责标注其他注解,去自定义该注解的工作范围和使用场景.</p>
<h3 id="2-1_元注解">2.1 元注解</h3><p>Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对自定义的annotation类型作说明。</p>
<ul>
<li>1.@Target ： 告知注解可以用于什么地方;</li>
<li>2.@Retention : </li>
<li>3.@Documented</li>
<li>4.@Inherited</li>
</ul>
<h4 id="2-1-1_@Target">2.1.1 @Target</h4><p>作用:告知注解可以用于什么地方.</p>
<p>书写格式:</p>
<pre><code>@<span class="function"><span class="title">Target</span><span class="params">(ElementType.METHOD)</span></span>
</code></pre><p>可选的ElementType参数有：</p>
<pre><code>ElemenetType<span class="class">.CONSTRUCTOR</span>      构造器声明 
ElemenetType<span class="class">.FIELD</span>          　域声明（包括 enum 实例） 
ElemenetType<span class="class">.LOCAL_VARIABLE</span>   局部变量声明 
ElemenetType<span class="class">.METHOD</span>           方法声明 
ElemenetType<span class="class">.PACKAGE</span>          包声明 
ElemenetType<span class="class">.PARAMETER</span>        参数声明 
ElemenetType<span class="class">.TYPE</span>          　 类，接口（包括注解类型）或enum声明
</code></pre><h4 id="2-1-2_@Retention">2.1.2 @Retention</h4><p>作用:表示需要在什么级别保存该注解信息.</p>
<p>书写格式:</p>
<pre><code>@<span class="function"><span class="title">Retention</span><span class="params">(RetentionPolicy.RUNTIME)</span></span>
</code></pre><p>可选的RetentionPolicy参数包括：</p>
<pre><code>RetentionPolicy<span class="class">.SOURCE</span> 　　　   注解将被编译器丢弃 
RetentionPolicy<span class="class">.CLASS</span> 　　　　　 注解在class文件中可用，但会被VM丢弃 
RetentionPolicy<span class="class">.RUNTIME</span> 　　　  VM将在运行期也保留注释，因此可以通过反射机制读取注解的信息。
</code></pre><p>同时根据级别的不同我们也将产生两种不同的注解时处理模式:</p>
<pre><code>RetentionPolicy               |<span class="string"> Describe                          </span>|<span class="string"> Chinese     </span>|<span class="string">  Example
------------------------------</span>|<span class="string"> --------------------------------- </span>|<span class="string"> ---------   </span>|<span class="string"> ---------- 
RetentionPolicy.RUNTIME       </span>|<span class="string"> Run Time Annotation Processor     </span>|<span class="string"> 运行时注解   </span>|<span class="string"> Retrofit
RetentionPolicy.CLASS         </span>|<span class="string"> Compile Time Annotation Processor </span>|<span class="string"> 编译时注解   </span>|<span class="string"> ButterKnife</span>
</code></pre><p>两者最大的区别在于:RTAP是运行时才会去操作注解,而CTAP是编译时就根据注解生成新的类对象或者完成了注解操作.<br>所以CTAP的性能十分优良,而RTAP则由于大量反射的使用导致性能受限.但CTAP的代码书写要相对于RTAP复杂很多,两者各有优势,具体的范例我为在Part2中提供出来，会做专门的比较。</p>
<h4 id="2-1-3_@Document">2.1.3 @Document</h4><p>作用:表示需要在什么级别保存该注解信息.</p>
<p>书写格式:</p>
<pre><code><span class="annotation">@Document</span>
</code></pre><h4 id="2-1-4_@Inherited">2.1.4 @Inherited</h4><p>作用:允许子类继承父类中的注解(class级别).</p>
<p>书写格式:</p>
<pre><code><span class="annotation">@Inherited</span>
</code></pre><h3 id="2-2_注解的元素(属性)">2.2 注解的元素(属性)</h3><p>注解的元素看起来就像接口的方法，唯一的区别在于可以为其制定默认值。没有元素的注解称为标记注解。</p>
<p>注解属性的类型只能是如下类型：</p>
<ul>
<li>String类型</li>
<li>8大基本数据类型</li>
<li>Class类型</li>
<li>枚举类型</li>
<li>注解类型</li>
<li>以上类型的一维数组</li>
</ul>
<p>示例:</p>
<pre><code><span class="annotation">@Target</span>(ElementType.METHOD)
<span class="annotation">@Retention</span>(RetentionPolicy.RUNTIME)
<span class="keyword">public</span> <span class="annotation">@interface</span> User {
      <span class="keyword">public</span> <span class="function">String <span class="title">id</span><span class="params">()</span></span>;
      <span class="keyword">public</span> String description() <span class="keyword">default</span> <span class="string">"defalut description"</span>;
}
</code></pre><p>或者:</p>
<pre><code><span class="annotation">@Retention</span>(RetentionPolicy.RUNTIME)
<span class="annotation">@Target</span>(ElementType.METHOD)
<span class="keyword">public</span> <span class="annotation">@interface</span> Subscribe {

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Mode</span></span>{
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Main = <span class="number">0</span>;
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Backgroud = <span class="number">1</span>;
    }

    <span class="function"><span class="keyword">int</span> <span class="title">mode</span><span class="params">()</span> <span class="keyword">default</span> Mode.Main</span>;
    <span class="function">String <span class="title">queue</span><span class="params">()</span> <span class="keyword">default</span> "GLOBAL"</span>;
}
</code></pre><p>使用:</p>
<pre><code><span class="at_rule">@<span class="keyword">Subscribe(mode=</span> Subscribe.Mode.Backgroud)
public void <span class="function">onProcessData</span>(ProcessData data) </span>{
    <span class="tag">mGlobalBus</span><span class="class">.post</span>(<span class="tag">new</span> <span class="tag">ProgressStatusEvent</span>(<span class="tag">i</span> + 1, <span class="tag">data</span><span class="class">.totalSteps</span>,<span class="tag">data</span><span class="class">.rank</span>));            
}
</code></pre><p>关于注解的元素,不一定在使用注解时都必须赋值,甚至可以标注注解时一个元素都不赋值.比如:</p>
<pre><code> @<span class="function">Subscribe
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onProgressStatusEvent</span>(<span class="params">ProgressStatusEvent <span class="keyword">event</span></span>) </span>{
    mProgressStatusEvent = <span class="keyword">event</span>;
    <span class="keyword">int</span> rank = <span class="keyword">event</span>.rank;
    mProgressBar0.setMax(<span class="keyword">event</span>.totalSteps);
    mProgressBar0.setProgress(<span class="keyword">event</span>.step);        
}
</code></pre><h2 id="3-设置注解并解析注解">3.设置注解并解析注解</h2><p>所谓设置注解也就是使用和标注自定义注解</p>
<p>比如自定义的注解:</p>
<pre><code><span class="annotation">@Target</span>(ElementType.METHOD)
<span class="annotation">@Retention</span>(RetentionPolicy.RUNTIME)
<span class="keyword">public</span> <span class="annotation">@interface</span> UserInfo {
      <span class="keyword">public</span> <span class="function">String <span class="title">id</span><span class="params">()</span></span>;
      <span class="keyword">public</span> String description() <span class="keyword">default</span> <span class="string">"defalut description"</span>;
}
</code></pre><p>使用它如下：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PasswordUtils</span> </span>{    

    <span class="annotation">@UserInfo</span>(id = <span class="number">47</span>, description = <span class="string">"Passwords must contain at least one numeric"</span>)
    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validatePassword</span><span class="params">(String password)</span> </span>{
           <span class="keyword">return</span> (password.matches(<span class="string">"\\w*\\d\\w*"</span>));
    }    

}
</code></pre><p>那么我们如何去解析这段注解：</p>
<blockquote>
<p>解决方案 : 通过注解处理器得到注解。<br>从原理上讲，注解处理器就是通过反射机制获取被检查方法上的注解信息，然后根据注解元素的值进行特定的处理。</p>
</blockquote>
<p>四个核心API:</p>
<p><img src="http://i.imgur.com/ldqqewB.png" width="80%"> </p>
<p>示例:</p>
<pre><code><span class="keyword">private</span> <span class="keyword">void</span> getAnno() {
    <span class="comment">//拿被注解方法上的</span>
    <span class="keyword">for</span> (Method m : PasswordUtils.<span class="keyword">class</span>.getDeclaredMethods()) {
        <span class="keyword">boolean</span> hasAnnotation = m.isAnnotationPresent(UserInfo.<span class="keyword">class</span>);
        <span class="comment">/**
         * 判断方法中是否有指定注解类型的注解
         */</span>
        <span class="keyword">if</span> (hasAnnotation) {
            <span class="comment">//拿到注解类</span>
            UserInfo annotation = m.getAnnotation(UserInfo.<span class="keyword">class</span>);
            <span class="keyword">if</span> (annotation != <span class="keyword">null</span>) {
                <span class="comment">//这样就拿到了定义的值:47</span>
                String id = annotation.id();
                String <span class="keyword">description</span> = annotation.<span class="keyword">description</span>();
                Toast.makeText(MainActivity.<span class="keyword">this</span>,<span class="string">"id="</span>+id+<span class="string">"/description="</span>+<span class="keyword">description</span>,Toast.LENGTH_LONG).show();
            }
        }
    }
}
</code></pre><p>代码见:<a href="https://github.com/xiaomeixw/AndroidDemo/blob/master/annotationdemo/src/main/java/sabria/demo/annotationdemo/MainActivity.java#L18" target="_blank" rel="external">AndroidDemo</a></p>
<h2 id="4-不同类型的拿法(运行时注解)">4.不同类型的拿法(运行时注解)</h2><p>这里特指运行时注解的处理方案,关于编译时注解我会给专门的part内容进行描述</p>
<p>定义注解：</p>
<pre><code><span class="annotation">@Target</span>({ElementType.TYPE,ElementType.METHOD,ElementType.FIELD,ElementType.CONSTRUCTOR})
<span class="annotation">@Retention</span>(RetentionPolicy.RUNTIME)
<span class="keyword">public</span> <span class="annotation">@interface</span> MyAnno {
    <span class="function">String <span class="title">name</span><span class="params">()</span> </span>;
    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;
    <span class="function">Class&lt;Long&gt; <span class="title">gid</span><span class="params">()</span></span>;
}
</code></pre><p>使用注解：</p>
<pre><code><span class="annotation">@MyAnno</span>(name=<span class="string">"type"</span>,gid=Long.<span class="keyword">class</span>)
使用了类注解
public <span class="class"><span class="keyword">class</span> <span class="title">UserAnnotation</span> </span>{

    <span class="comment">//字段</span>
    <span class="annotation">@TestA</span>(name=<span class="string">"param"</span>,id=<span class="number">1</span>,gid=Long.<span class="keyword">class</span>) <span class="comment">// 使用了类成员注解</span>
    private Integer age;

    <span class="comment">//构造器</span>
    <span class="annotation">@TestA</span>(name=<span class="string">"construct"</span>,id=<span class="number">2</span>,gid=Long.<span class="keyword">class</span>)<span class="comment">// 使用了构造方法注解</span>
    public UserAnnotation() {
    }

    <span class="comment">//方法a，b，c</span>
    <span class="annotation">@TestA</span>(name=<span class="string">"public method"</span>, id=<span class="number">3</span>, gid=Long.<span class="keyword">class</span>)<span class="comment">// 使用了 public 方法注解</span>
    public <span class="keyword">void</span> a() {
        <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; m = <span class="keyword">new</span> HashMap&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;(<span class="number">0</span>);
    }

    <span class="annotation">@TestA</span>(name=<span class="string">"protected method"</span>, id=<span class="number">4</span>, gid=Long.<span class="keyword">class</span>)<span class="comment">//protected 方法注解</span>
    protected <span class="keyword">void</span> b() { 
        <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; m = <span class="keyword">new</span> HashMap&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;(<span class="number">0</span>);
    }

    <span class="annotation">@TestA</span>(name=<span class="string">"private method "</span> , id = <span class="number">5</span>, gid=Long.<span class="keyword">class</span>) <span class="comment">// private 方法注解</span>
    private <span class="keyword">void</span> c(){
        <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; m = <span class="keyword">new</span> HashMap&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;(<span class="number">0</span>);
    }

    public <span class="keyword">void</span> b(Integer a){ 
    }
}
</code></pre><p>解析注解:</p>
<h3 id="4-1_解析类上注解">4.1 解析类上注解</h3><pre><code>private void parseTypeAnnotation<span class="params">()</span> throws ClassNotFoundException{
    <span class="comment">//先找到类</span>
    Class clazz = Class.forName<span class="params">(<span class="string">"sabria.demo.annotationdemo.getanno.UserAnnotation"</span>)</span>;
    <span class="comment">//拿到注解器</span>
    Annotation[] annotations = clazz.getAnnotations<span class="params">()</span>;
    <span class="keyword">for</span> <span class="params">(Annotation annotation : annotations)</span> {
        <span class="comment">//拿到类上的注解对象</span>
        MyAnno testA = <span class="params">(MyAnno)</span> annotation;
        say<span class="params">(<span class="string">"type name = "</span> + clazz.getName<span class="params">()</span> + <span class="string">"  |  id = "</span> + testA.id<span class="params">()</span> + <span class="string">"  |  name = "</span> + testA.name<span class="params">()</span> + <span class="string">"  |  　　　　　　　　　　　　　　　　　　　　gid = "</span> + testA.gid<span class="params">()</span>)</span>;
    }
}
</code></pre><p>打印如下:</p>
<blockquote>
<p>01-11 15:24:57.414  25515-25515/sabria.demo.annotationdemo I/MainActivity﹕ type name = sabria.demo.annotationdemo.getanno.UserAnnotation  |  id = 0  |  name = type  | gid = class java.lang.Long</p>
</blockquote>
<h3 id="4-2_解析方法上注解">4.2 解析方法上注解</h3><pre><code>private <span class="type">void</span> parseMethodAnnotation() {
    //拿到<span class="type">UserAnnotation</span>类中的所有方法
    <span class="type">Method</span>[] methods = <span class="type">UserAnnotation</span>.class.getDeclaredMethods();
    //一个一个方法判断
    <span class="keyword">for</span> (<span class="type">Method</span> <span class="keyword">method</span> : methods) {
         /*
         * 判断方法中是否有指定注解类型的注解
         * 方法上面是否有@<span class="type">MyAnno</span>
         */
        boolean hasAnnotation = <span class="keyword">method</span>.isAnnotationPresent(<span class="type">MyAnno</span>.class);
        <span class="keyword">if</span>(hasAnnotation){
            //有的话,拿注解器
            <span class="type">MyAnno</span> annotation = <span class="keyword">method</span>.getAnnotation(<span class="type">MyAnno</span>.class);
            say(<span class="string">"method name = "</span> + <span class="keyword">method</span>.getName() + <span class="string">"  |  id = "</span> +
                    annotation.id() + <span class="string">"  |  description = "</span> + annotation.name() + <span class="string">"  |  gid = "</span> + annotation.gid());
        }
    }
}
</code></pre><p>打印如下:</p>
<blockquote>
<p>01-11 15:24:57.424  25515-25515/sabria.demo.annotationdemo I/MainActivity﹕ method name = a  |  id = 3  |  description = public method  |  gid = class java.lang.Long</p>
<p>01-11 15:24:57.434  25515-25515/sabria.demo.annotationdemo I/MainActivity﹕ method name = b  |  id = 4  |  description = protected method  |  gid = class java.lang.Long</p>
<p>01-11 15:24:57.434  25515-25515/sabria.demo.annotationdemo I/MainActivity﹕ method name = c  |  id = 5  |  description = private method   |  gid = class java.lang.Long</p>
</blockquote>
<h3 id="4-3_解析构造器上注解">4.3 解析构造器上注解</h3><pre><code><span class="keyword">private</span> <span class="built_in">void</span> parseConstructAnnotation() {
    Constructor[] constructors = UserAnnotation.class.getConstructors();
    <span class="keyword">for</span> (Constructor <span class="constructor"><span class="keyword">constructor</span> : constructors) </span>{
            <span class="comment">/*
             * 判断构造方法中是否有指定注解类型的注解
             */</span>
        <span class="built_in">boolean</span> hasAnnotation = <span class="constructor"><span class="keyword">constructor</span>.isAnnotationPresent(MyAnno.class);
        if(hasAnnotation)</span>{
                 <span class="comment">/*
                 * 根据注解类型返回方法的指定类型注解
                 */</span>
            MyAnno annotation = (MyAnno) <span class="constructor"><span class="keyword">constructor</span>.getAnnotation(MyAnno.class);
            say("<span class="keyword">constructor</span> = " + <span class="keyword">constructor</span>.getName()
                    + "   |   id = " + annotation.id() + "  |  description = "
                    + annotation.name() + "  |   gid= "+annotation.gid());
        }
    }
}</span>
</code></pre><p>打印如下:</p>
<blockquote>
<p>01-11 15:30:08.984  30046-30046/sabria.demo.annotationdemo I/MainActivity﹕ constructor = sabria.demo.annotationdemo.getanno.UserAnnotation   |   id = 2  |  description = construct  |   gid= class java.lang.Long</p>
</blockquote>
<h3 id="4-4_解析字段上注解">4.4 解析字段上注解</h3><pre><code>private void parseFieldAnnotation<span class="params">()</span> {

    <span class="comment">//1.拿这个类上的所有字段</span>
    Field[] fields = UserAnnotation.class.getDeclaredFields<span class="params">()</span>;
    <span class="keyword">for</span> <span class="params">(Field field : fields)</span> {
        <span class="comment">//2.该字段上是否有注解</span>
        boolean hasAnnotation = field.isAnnotationPresent<span class="params">(MyAnno.class)</span>;
        <span class="keyword">if</span><span class="params">(hasAnnotation)</span>{
            <span class="comment">//3.拿到注解器对象</span>
            MyAnno annotation = field.getAnnotation<span class="params">(MyAnno.class)</span>;
            say<span class="params">(<span class="string">"Field = "</span> + field.getName<span class="params">()</span>
                    + <span class="string">"  |  id = "</span> + annotation.id<span class="params">()</span> + <span class="string">"  |  description = "</span>
                    + annotation.name<span class="params">()</span> + <span class="string">"  |  gid= "</span>+annotation.gid<span class="params">()</span>)</span>;
        }
    }

}
</code></pre><p>打印如下:</p>
<blockquote>
<p>01-11 15:30:08.994  30046-30046/sabria.demo.annotationdemo I/MainActivity﹕ Field = age  |  id = 1  |  description = param  |  gid= class java.lang.Long</p>
</blockquote>
<p>代码见:</p>
<p>总结:</p>
<ul>
<li>1.拿这个类上的方法或字段;</li>
<li>2.判断方法或者字段上是否有给注解;</li>
<li>3.拿到注解对象,获取值</li>
</ul>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/01/06/ZTN01_2/" itemprop="url">
                【杂谈1月】JobSchedule即将开源
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-01-06T23:47:48+08:00" content="2016-01-06">
            2016-01-06
          </time>
        </span>

        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>即将重磅开源Android后台线程调度类库:JobSchedule</p>
<p>先上一张1个月前画的Jobschedule草图流程.为了这个开源框架准备了1个多月的时间,希望可以为android开源做出贡献.</p>
<p><img src="http://7xn9yd.com1.z0.glb.clouddn.com/766556IMG_0085.JPG" alt=""></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/03/ZTN01_1/" itemprop="url">
                【正谈1月】Java线程范式编程 Part-1
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-03T22:57:48+08:00" content="2015-12-03">
            2015-12-03
          </time>
        </span>

        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>Java线程范式编程 Part-1</p>
<h2 id="1-_创建线程三方案">1. 创建线程三方案</h2><ul>
<li><p><em>通过扩展Thread类来创建多线程:</em></p>
<p>  new MyThread(Runnable).start();</p>
</li>
<li><p><em>通过实现Runnable接口来创建多线程:</em></p>
<p>  new Thread(new MyRunnable()).start();</p>
</li>
<li><p><em>通过实现callable<t>接口</t></em></p>
<p>  class MyTask implements Callable<t><br>  executor.submit(MyTask);</t></p>
</li>
</ul>
<p>方案一和方案二都是没有返回值的,方案三有返回值.</p>
<blockquote>
<p>扩展Thread类:</p>
</blockquote>
<p>1.匿名方案</p>
<pre><code><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        Utils.runContent(MainActivity.<span class="keyword">this</span>);
    }
}).start();
</code></pre><p>2.class方案</p>
<pre><code><span class="keyword">new</span> <span class="type">RunnerThread</span>().start();

<span class="class"><span class="keyword">class</span> <span class="title">RunnerThread</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Thread</span> {</span>
    <span class="annotation">@Override</span>
    public void run() {
        <span class="type">Utils</span>.runContent(<span class="type">MainActivity</span>.<span class="keyword">this</span>);
    }
}
</code></pre><blockquote>
<p>实现Runnable接口</p>
</blockquote>
<pre><code><span class="keyword">new</span> Thread(<span class="keyword">new</span> RunnerRunnable()).start();

<span class="class"><span class="keyword">class</span> <span class="title">RunnerRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        Utils.runContent(MainActivity.<span class="keyword">this</span>);
    }
}
</code></pre><blockquote>
<p>实现callable<t>接口</t></p>
</blockquote>
<pre><code>ExecutorService pool = Executors.newCachedThreadPool();
WorkCallable workCallable = <span class="keyword">new</span> WorkCallable();
Future&lt;Integer&gt; future = pool.submit(workCallable);
Utils.log(<span class="string">"Future运行结果:="</span>+integer);

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>{
    @Override
    <span class="keyword">public</span> Integer call() throws Exception {
        Thread.sleep(<span class="number">1000</span>);
        <span class="keyword">int</span> <span class="keyword">sum</span> = <span class="number">0</span>;
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {
            <span class="keyword">sum</span> = <span class="keyword">sum</span> + i;
        }
        <span class="keyword">return</span> <span class="keyword">sum</span>;
    }
}
</code></pre><h2 id="2-_关键字volatile">2. 关键字volatile</h2><blockquote>
<p>它访问的是原数据而不是拷贝的变量数据</p>
</blockquote>
<p> 线程为了提高效率，将某成员变量(如A)拷贝了一份（如B），线程中对A的访问其实访问的是B。<br> 只在某些动作时才进行A和B的同步。因此存在A和B不一致的情况。volatile就是用来避免这种情况的。<br> volatile告诉jvm， 它所修饰的变量不保留拷贝，直接访问主内存中的（也就是上面说的A)</p>
<p>使用环境场景:主要用在判断变量线程安全方面.</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">volatileKeyWord</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Thread</span> {</span>

    <span class="keyword">private</span>  volatile boolean isRunning = <span class="literal">true</span>;

    <span class="annotation">@Override</span>
    public void run() {
        <span class="keyword">while</span> (isRunning) {
            <span class="type">Log</span>.i(<span class="type">TAG</span>,<span class="string">"Running"</span>+<span class="type">Thread</span>.currentThread().getName());             
            <span class="keyword">try</span> {
                <span class="type">Thread</span>.sleep(<span class="number">50</span>);
            } <span class="keyword">catch</span> (<span class="type">InterruptedException</span> e) {
                e.printStackTrace();
            }
        }
    }

    public  void shutDown() {
        isRunning = <span class="literal">false</span>;
    }
}
</code></pre><h2 id="3-_关键字join">3. 关键字join</h2><blockquote>
<p>3.1 概念:</p>
</blockquote>
<p>thread.Join把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。</p>
<blockquote>
<p>3.2 使用:</p>
</blockquote>
<p>join是Thread类的一个方法，启动线程后直接调用.</p>
<pre><code><span class="type">Thread</span> t = <span class="keyword">new</span> <span class="type">AThread</span><span class="literal">()</span>; 
t.start<span class="literal">()</span>; 
t.join<span class="literal">()</span>;
</code></pre><blockquote>
<p>3.3 为什么要用join()方法:</p>
</blockquote>
<p>在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。</p>
<p>“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行。</p>
<blockquote>
<p>3.4 Code:</p>
</blockquote>
<pre><code><span class="keyword">private</span> <span class="keyword">int</span> count =<span class="number">0</span>;
<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ThreadJoin</span><span class="params">()</span> </span>{
    Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
        @<span class="function">Override
        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
            <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span> ; i &lt;<span class="number">10</span> ; i ++){
                increment(Thread.currentThread().getName());
            }
        }
    });
    thread1.start();

    Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
        @<span class="function">Override
        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
            <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span> ; i &lt;<span class="number">10</span> ; i ++){
                increment(Thread.currentThread().getName());
            }
        }
    });


    <span class="keyword">try</span> {
        thread1.join();
        thread2.start();
        thread2.join();
    } <span class="keyword">catch</span> (InterruptedException e) {
        e.printStackTrace();
    }

    Utils.<span class="built_in">log</span>(<span class="string">"Count is: "</span> + count);

}
</code></pre><p>LogCat：</p>
<pre><code><span class="number">12</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">37.478</span>  <span class="number">24623</span>-<span class="number">24661</span>/sabria.demo.threadpractice I/MainActivity﹕ Thread in Progress: Thread-<span class="number">37224</span> and count is: <span class="number">1</span>
<span class="number">12</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">37.478</span>  <span class="number">24623</span>-<span class="number">24661</span>/sabria.demo.threadpractice I/MainActivity﹕ Thread in Progress: Thread-<span class="number">37224</span> and count is: <span class="number">2</span>
<span class="number">12</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">37.478</span>  <span class="number">24623</span>-<span class="number">24661</span>/sabria.demo.threadpractice I/MainActivity﹕ Thread in Progress: Thread-<span class="number">37224</span> and count is: <span class="number">3</span>
<span class="number">12</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">37.478</span>  <span class="number">24623</span>-<span class="number">24661</span>/sabria.demo.threadpractice I/MainActivity﹕ Thread in Progress: Thread-<span class="number">37224</span> and count is: <span class="number">4</span>
<span class="number">12</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">37.478</span>  <span class="number">24623</span>-<span class="number">24661</span>/sabria.demo.threadpractice I/MainActivity﹕ Thread in Progress: Thread-<span class="number">37224</span> and count is: <span class="number">5</span>
<span class="number">12</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">37.478</span>  <span class="number">24623</span>-<span class="number">24661</span>/sabria.demo.threadpractice I/MainActivity﹕ Thread in Progress: Thread-<span class="number">37224</span> and count is: <span class="number">6</span>
<span class="number">12</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">37.478</span>  <span class="number">24623</span>-<span class="number">24661</span>/sabria.demo.threadpractice I/MainActivity﹕ Thread in Progress: Thread-<span class="number">37224</span> and count is: <span class="number">7</span>
<span class="number">12</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">37.478</span>  <span class="number">24623</span>-<span class="number">24661</span>/sabria.demo.threadpractice I/MainActivity﹕ Thread in Progress: Thread-<span class="number">37224</span> and count is: <span class="number">8</span>
<span class="number">12</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">37.478</span>  <span class="number">24623</span>-<span class="number">24661</span>/sabria.demo.threadpractice I/MainActivity﹕ Thread in Progress: Thread-<span class="number">37224</span> and count is: <span class="number">9</span>
<span class="number">12</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">37.478</span>  <span class="number">24623</span>-<span class="number">24661</span>/sabria.demo.threadpractice I/MainActivity﹕ Thread in Progress: Thread-<span class="number">37224</span> and count is: <span class="number">10</span>
<span class="number">12</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">37.478</span>  <span class="number">24623</span>-<span class="number">24662</span>/sabria.demo.threadpractice I/MainActivity﹕ Thread in Progress: Thread-<span class="number">37225</span> and count is: <span class="number">11</span>
<span class="number">12</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">37.478</span>  <span class="number">24623</span>-<span class="number">24662</span>/sabria.demo.threadpractice I/MainActivity﹕ Thread in Progress: Thread-<span class="number">37225</span> and count is: <span class="number">12</span>
<span class="number">12</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">37.478</span>  <span class="number">24623</span>-<span class="number">24662</span>/sabria.demo.threadpractice I/MainActivity﹕ Thread in Progress: Thread-<span class="number">37225</span> and count is: <span class="number">13</span>
<span class="number">12</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">37.478</span>  <span class="number">24623</span>-<span class="number">24662</span>/sabria.demo.threadpractice I/MainActivity﹕ Thread in Progress: Thread-<span class="number">37225</span> and count is: <span class="number">14</span>
<span class="number">12</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">37.478</span>  <span class="number">24623</span>-<span class="number">24662</span>/sabria.demo.threadpractice I/MainActivity﹕ Thread in Progress: Thread-<span class="number">37225</span> and count is: <span class="number">15</span>
<span class="number">12</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">37.478</span>  <span class="number">24623</span>-<span class="number">24662</span>/sabria.demo.threadpractice I/MainActivity﹕ Thread in Progress: Thread-<span class="number">37225</span> and count is: <span class="number">16</span>
<span class="number">12</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">37.478</span>  <span class="number">24623</span>-<span class="number">24662</span>/sabria.demo.threadpractice I/MainActivity﹕ Thread in Progress: Thread-<span class="number">37225</span> and count is: <span class="number">17</span>
<span class="number">12</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">37.478</span>  <span class="number">24623</span>-<span class="number">24662</span>/sabria.demo.threadpractice I/MainActivity﹕ Thread in Progress: Thread-<span class="number">37225</span> and count is: <span class="number">18</span>
<span class="number">12</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">37.478</span>  <span class="number">24623</span>-<span class="number">24662</span>/sabria.demo.threadpractice I/MainActivity﹕ Thread in Progress: Thread-<span class="number">37225</span> and count is: <span class="number">19</span>
<span class="number">12</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">37.478</span>  <span class="number">24623</span>-<span class="number">24662</span>/sabria.demo.threadpractice I/MainActivity﹕ Thread in Progress: Thread-<span class="number">37225</span> and count is: <span class="number">20</span>
<span class="number">12</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">37.478</span>  <span class="number">24623</span>-<span class="number">24623</span>/sabria.demo.threadpractice I/MainActivity﹕ Count is: <span class="number">20</span>
</code></pre><h2 id="4-_LockObject_加锁机制">4. LockObject 加锁机制</h2><blockquote>
<p>4.1 锁机制目的:</p>
</blockquote>
<p>保证了同步代码在同一时刻只有一个线程在执行。<br>类比于:厕所,在同一时刻只有一个人在使用，多人想进入,里面有一个人在用,其他人必需排队.那个在使用的人,通过厕所门的锁来保证只有自己在使用.</p>
<p>4.2 锁机制方案</p>
<ul>
<li><p><em>1. 在需要同步的方法的方法签名中加入synchronized关键字。</em></p>
<pre><code> <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">synMethod</span><span class="params">()</span> </span>{
    <span class="comment">//方法体</span>
}
</code></pre></li>
<li><p><em>2. 使用synchronized块对需要进行同步的代码段进行同步。</em></p>
<pre><code><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">synMethod</span><span class="params">()</span></span>{
    <span class="keyword">synchronized</span>(syncObject) {
      <span class="comment">//一次只能有一个线程进入</span>
    }
}
</code></pre></li>
<li><p><em>3. 使用JDK 5中提供的java.util.concurrent.lock包中的Lock对象。</em></p>
<pre><code><span class="keyword">private</span> Lock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();
<span class="keyword">private</span> Condition notFull = <span class="keyword">lock</span>.newCondition();
</code></pre></li>
</ul>
<p>4.3 线程安全就是说多线程访问同一代码，不会产生不确定的结果。</p>
<p>并行和并发区别</p>
<p>1、并行是指两者同时执行一件事，比如赛跑，两个人都在不停的往前跑；<br>2、并发是指资源有限的情况下，两者交替轮流使用资源，比如一段路(单核CPU资源)同时只能过一个人，A走一段后，让给B，B用完继续给A ，交替使用，目的是提高效率</p>
<h2 id="5-_ThreadPool线程池">5. ThreadPool线程池</h2><pre><code>ExecutorService executor = Executors.newFixedThreadPool(5)<span class="comment">;</span>
pool.execute(workRunnable)<span class="comment">;</span>
</code></pre><blockquote>
<p>固定大小的线程池:</p>
</blockquote>
<pre><code>ExecutorService executor = Executors.newFixedThreadPool(<span class="number">5</span>);
</code></pre><p>我们创建了包含5个工作线程的固定大小线程池。然后，我们向线程池提交10个任务。由于线程池的大小是5，因此首先会启动5个工作线程，其他任务将进行等待。一旦有任务结束，工作线程会从等待队列中挑选下一个任务并开始执行。</p>
<blockquote>
<p>单任务线程池:</p>
</blockquote>
<pre><code>ExecutorService pool = Executors.newSingleThreadExecutor()<span class="comment">;</span>
</code></pre><p>我们创建了包含1个工作线程的固定大小线程池.由于线程池的大小是1，因此首先会启动1个工作线程，其他任务将进行等待。一旦有任务结束，工作线程会从等待队列中挑选下一个任务并开始执行。</p>
<blockquote>
<p>可变尺寸的线程池:</p>
</blockquote>
<pre><code>ExecutorService pool = Executors.newCachedThreadPool()<span class="comment">;</span>
</code></pre><p>execute多少个runnable就运行多少个任务</p>
<blockquote>
<p>延迟连接池:</p>
</blockquote>
<pre><code>ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">2</span>);
pool.schedule(runnable, <span class="number">10</span>, TimeUnit.MILLISECONDS);

延迟多久后执行任务
</code></pre><blockquote>
<p>自定义线程池:</p>
</blockquote>
<pre><code>ThreadPoolExecutor
<span class="keyword">public</span> ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize,
                          <span class="keyword">int</span> maximumPoolSize,
                          <span class="keyword">long</span> keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&lt;Runnable&gt; workQueue)
</code></pre><p>用给定的初始参数和默认的线程工厂及处理程序创建新的 ThreadPoolExecutor。使用 Executors 工厂方法之一比使用此通用构造方法方便得多。<br>参数：</p>
<pre><code>corePoolSize - 池中所保存的线程数，包括空闲线程。
maximumPoolSize - 池中允许的最大线程数。
keepAliveTime - 当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。
unit - keepAliveTime 参数的时间单位。
workQueue - 执行前用于保持任务的队列。此队列仅保持由<span class="instruction"> execute </span>方法提交的 Runnable 任务。
</code></pre><p>抛出：<br>IllegalArgumentException - 如果 corePoolSize 或 keepAliveTime 小于零，或者 maximumPoolSize 小于或等于零，或者 corePoolSize 大于 maximumPoolSize。</p>
<p>NullPointerException - 如果 workQueue 为 null</p>
<p>AsyncTask的线程池:</p>
<pre><code><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CPU_COUNT = Runtime.getRuntime().availableProcessors();
<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = CPU_COUNT + <span class="number">1</span>;
<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_POOL_SIZE = CPU_COUNT * <span class="number">2</span> + <span class="number">1</span>;
<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEEP_ALIVE = <span class="number">1</span>;
<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadFactory sThreadFactory = <span class="keyword">new</span> ThreadFactory() {
    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger mCount = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);

    <span class="keyword">public</span> <span class="function">Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>{
        <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">"AsyncTask #"</span> + mCount.getAndIncrement());
    }
};
<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; sPoolWorkQueue =
        <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">128</span>);
</code></pre><h2 id="6-1_ExecutorService的生命周期">6-1 ExecutorService的生命周期</h2><p>ExecutorService的生命周期有3种状态:运行、关闭和已终止.</p>
<ul>
<li><p><em>void shutdown()</em> ： 平缓的关闭,不再接收新任务,同时等待已经提交的任务执行完成–包括那些还未开始执行的任务.</p>
</li>
<li><p><em>List<runnable> shutdownNow()</runnable></em> ： 执行粗暴的关闭,将尝试取消所有运行中的任务,并且不再启动队列中尚未开始开始执行的任务.</p>
</li>
<li><p><em>boolean awaitTermination(timeout,unit)</em> : 这个方法有两个参数，一个是timeout即超时时间，另一个是unit即时间单位。这个方法会使线程等待timeout时长，当超过timeout时间后，会监测ExecutorService是否已经关闭，若关闭则返回true，否则返回false。一般情况下会和shutdown方法组合使用。</p>
<pre><code> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> throws IOException, InterruptedException </span>{   
    ExecutorService executor = Executors.newFixedThreadPool(<span class="number">2</span>);   
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {   
        Runnable run = <span class="keyword">new</span> Runnable() {   
            @<span class="function">Override  
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{   
                System.out.println(<span class="string">"thread start"</span>);   
            }   
        };   
        executor.execute(run);   
    }   
    executor.shutdown();   
    <span class="keyword">try</span> {
        executor.awaitTermination(Long.MAX_VALUE, TimeUnit.DAYS); 
    } <span class="keyword">catch</span> (InterruptedException ignored) {
    }        
    System.out.println(<span class="string">"all thread complete"</span>);   
} 
</code></pre></li>
<li><p><em>boolean isShutdown()</em> ： 这个方法在ExecutorService关闭后返回true，否则返回false.</p>
</li>
<li><p><em>boolean isTerminated()</em> ： 这个方法会校验ExecutorService当前的状态是否为“TERMINATED”即关闭状态，当为“TERMINATED”时返回true否则返回false</p>
</li>
</ul>
<p>所以我们在执行完成submit()/execute()后,最好显示的调用shutdown():</p>
<pre><code>executor.submit/execute(worker)<span class="comment">;</span>
executor.shutdown()<span class="comment">;</span>
executor.awaitTermination(1, TimeUnit.DAYS)<span class="comment">;</span>
</code></pre><h2 id="6-2-_pool-execute_和_pool-submit">6-2. pool.execute 和 pool.submit</h2><p>pool.execute(workRunnable); 和 pool.submit(callback/workRunnable)区别</p>
<ul>
<li><em>a.接收的参数不一样</em></li>
<li><em>b.submit有返回值，而execute没有</em></li>
<li><em>c.submit方便Exception处理</em></li>
</ul>
<p>code:</p>
<pre><code><span class="keyword">Future</span>&lt;?&gt; <span class="keyword">future</span> = THREAD_POOL_EXECUTOR.submit(workRunnable);
<span class="keyword">future</span>.get();<span class="comment">//获取任务执行结果</span>
</code></pre><h2 id="7-_Callable、Future和FutureTask">7. Callable、Future和FutureTask</h2><p>创建线程的2种方式，一种是直接继承Thread，另外一种就是实现Runnable接口.<br>这2种方式都有一个缺陷就是：在执行完任务之后无法获取执行结果.</p>
<blockquote>
<p>7.1 callbakc</p>
</blockquote>
<p>//call()函数返回的类型就是传递进来的V类型<br>public interface Callable<v> {<br>    V call() throws Exception;<br>}</v></p>
<p>怎么使用Callable呢？一般情况下是配合ExecutorService来使用的，在ExecutorService接口中声明了若干个submit方法的重载版本.</p>
<p><t> Future<t> submit(Callable<t> task);</t></t></t></p>
<blockquote>
<p>7.2 future</p>
</blockquote>
<p>Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。</p>
<p>1）判断任务是否完成；<br>2）能够中断任务；<br>3）能够获取任务执行结果。</p>
<p>因为Future只是一个接口，所以是无法直接用来创建对象使用的，因此就有了下面的FutureTask。FutureTask是Future接口的一个唯一实现类.</p>
<blockquote>
<p>7.3 futureTask</p>
</blockquote>
<p>FutureTask类实现了RunnableFuture接口</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span><span class="inheritance">&lt;<span class="parent">V</span></span>&gt; <span class="title">implements</span> <span class="title">RunnableFuture</span><span class="inheritance">&lt;<span class="parent">V</span></span>&gt;</span>
</code></pre><p>RunnableFuture继承了Runnable接口和Future接口，而FutureTask实现了RunnableFuture接口。所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>{
    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;
}
</code></pre><p>FutureTask提供了2个构造器：</p>
<pre><code>public <span class="type">FutureTask</span>(<span class="type">Callable</span>&lt;V&gt; callable) {
}
public <span class="type">FutureTask</span>(<span class="type">Runnable</span> runnable, V <span class="literal">result</span>) {
}
</code></pre><blockquote>
<p>7.4 使用</p>
</blockquote>
<p>Callable+Future获取执行结果：</p>
<pre><code><span class="type">ExecutorService</span> executor = <span class="type">Executors</span>.newCachedThreadPool();
<span class="type">Future</span>&lt;<span class="type">Integer</span>&gt; <span class="literal">result</span> = executor.submit(task);
<span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"task运行结果"</span>+<span class="literal">result</span>.get());
</code></pre><p>使用Callable+FutureTask获取执行结果：</p>
<pre><code>ExecutorService executor = Executors.newCachedThreadPool<span class="params">()</span>;
FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;<span class="params">(task)</span>;
executor.submit<span class="params">(futureTask)</span>;
System.out.println<span class="params">(<span class="string">"task运行结果"</span>+futureTask.get<span class="params">()</span>)</span>;
</code></pre><p>或者：</p>
<pre><code>FutureTask&lt;<span class="built_in">Integer</span>&gt; futureTask = <span class="literal">new</span> FutureTask&lt;<span class="built_in">Integer</span>&gt;(task);
<span class="keyword">Thread</span> <span class="keyword">thread</span> = <span class="literal">new</span> <span class="keyword">Thread</span>(futureTask);
<span class="keyword">thread</span><span class="built_in">.</span>start();
</code></pre><p>注意这种方式和第一种方式效果是类似的，只不过一个使用的是ExecutorService，一个使用的是Thread</p>
<p>System.out.println(“task运行结果”+futureTask.get());</p>
<p>其中的task代码：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>{
    @Override
    <span class="keyword">public</span> Integer call() throws Exception {
        System.out.println(<span class="string">"子线程在进行计算"</span>);
        Thread.sleep(<span class="number">3000</span>);
        <span class="keyword">int</span> <span class="keyword">sum</span> = <span class="number">0</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)
            <span class="keyword">sum</span> += i;
        <span class="keyword">return</span> <span class="keyword">sum</span>;
    }
}
</code></pre><h2 id="8-_队列Queue">8. 队列Queue</h2><blockquote>
<p>8.1 概念:</p>
</blockquote>
<p>多数生产消费模型的首选数据结构就是队列(先进先出)。Java提供的线程安全的Queue可以分为阻塞队列和非阻塞队列，<br>其中阻塞队列的典型例子是BlockingQueue，非阻塞队列的典型例子是ConcurrentLinkedQueue，<br>在实际应用中要根据实际需要选用阻塞队列BlockingQueue或者非阻塞队列ConcurrentLinkedQueue。</p>
<p>Queue是什么就不需要多说了吧，一句话：队列是先进先出。相对的，栈是后进先出。</p>
<p>BlockingQueue 一个接口，Java5提供了不同的现实，如ArrayBlockingQueue和LinkedBlockingQueue，两者都是先进先出（FIFO）顺序。<br>而ArrayLinkedQueue是自然有界的，LinkedBlockingQueue可选的边界。</p>
<p>LinkedBlockingQueue<br>由于LinkedBlockingQueue实现是线程安全的，实现了先进先出等特性，是作为生产者消费者的首选，<br>LinkedBlockingQueue 可以指定容量，也可以不指定，不指定的话，默认最大是Integer.MAX_VALUE，<br>其中主要用到put和take方法，put方法在队列满的时候会阻塞直到有队列成员被消费，take方法在队列空的时候会阻塞，直到有队列成员被放进来。</p>
<p>ConcurrentLinkedQueue<br>ConcurrentLinkedQueue是Queue的一个安全实现．Queue中元素按FIFO原则进行排序．采用CAS操作，来保证元素的一致性。<br>LinkedBlockingQueue是一个线程安全的阻塞队列，它实现了BlockingQueue接口，<br>BlockingQueue接口继承自java.util.Queue接口，并在这个接口的基础上增加了take和put方法，这两个方法正是队列操作的阻塞版本。</p>
<p>ArrayBlockingQueue是一个由数组支持的有界阻塞队列。此队列按 FIFO（先进先出）原则对元素进行排序。队列的头部 是在队列中存在时间最长的元素.<br>队列的尾部 是在队列中存在时间最短的元素。新元素插入到队列的尾部，队列获取操作则是从队列头部开始获得元素。</p>
<p>Queue:</p>
<p>1.ArrayDeque, （数组双端队列）<br>2.PriorityQueue, （优先级队列）<br>3.ConcurrentLinkedQueue, （基于链表的并发队列）<br>4.DelayQueue, （延期阻塞队列）（阻塞队列实现了BlockingQueue接口）<br>5.ArrayBlockingQueue, （基于数组的并发阻塞队列）<br>6.LinkedBlockingQueue, （基于链表的FIFO阻塞队列）<br>7.LinkedBlockingDeque, （基于链表的FIFO双端阻塞队列）<br>8.PriorityBlockingQueue, （带优先级的无界阻塞队列）<br>9.SynchronousQueue （并发同步阻塞队列）</p>
<p><a href="http://blog.csdn.net/tayanxunhua/article/details/20962307" target="_blank" rel="external">http://blog.csdn.net/tayanxunhua/article/details/20962307</a></p>
<h2 id="9-_消费者生产者模式">9. 消费者生产者模式</h2><p>一个线程生产,另一个线程消费.</p>
<h3 id="何为生产消费者模式:">何为生产消费者模式:</h3><p>某个模块负责产生数据，这些数据由另一个模块来负责处理（此处的模块是广义的，可以是类、函数、线程、进程等）。产生数据的模块，就形象地称为生产者；而处理数据的模块，就称为消费者。该模式还需要有一个缓冲区处于生产者和消费者之间，作为一个中介。生产者把数据放入缓冲区，而消费者从缓冲区取出数据。</p>
<p>作用:生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。</p>
<p>这个阻塞队列就是用来给生产者和消费者解耦的。</p>
<p><img src="http://i.imgur.com/WHpT8Md.png" alt=""></p>
<p>阻塞指的是暂停一个线程的执行以等待某个条件发生.</p>
<p>基于阻塞队列构建的消费者-生成者模式中,当数据生成时,生成者将数据放入队列,而当消费者准备处理数据时，将从队列中取出数据.<br>生成者和消费者都不需要知道对方的标识或数量，他们只与队列或者缓冲区打交道.</p>
<p><img src="http://i.imgur.com/m0w8V3G.png" alt="一个工作队列"></p>
<p>洗盘工将洗好的盘子放在盘架上,而烘盘工从盘架上取出盘子并把他们烘干。盘架相当于阻塞队列:如果盘架上没有盘子，那么消费者(烘盘工)会一直等到，直到有盘子需要烘干.如果盘架满了,那么那么生成者(洗盘工)会停止清洗直到盘架上有更多的空间。<br>在这里每个工人只需要与盘架打交道,不需要知道有多少生产者或消费者,或者谁生成了某个指定的工作项.</p>
<p>生成者和消费者的角色是相对的,在某个环境中的消费者在另一个环境中可能会成为生成者。</p>
<p><img src="http://i.imgur.com/XlyzjrH.png" alt=""></p>
<p>烘盘工匠消费洗干净的盘子，而产生烘干的盘子，第三人“放盘工”将会把所有烘干的盘子放入厨房橱柜中。在这种情况下烘干盘子的工人既是消费者，也是生成者，从而产生了两个共享的工作队列.每个队列都可能阻塞烘干工作的运行.</p>
<p>生产者与消费者模型中，要保证以下几点： </p>
<ul>
<li>1 同一时间内只能有一个生产者生产     生产方法加锁sychronized </li>
<li>2 同一时间内只能有一个消费者消费     消费方法加锁sychronized </li>
<li>3 生产者生产的同时消费者不能消费     生产方法加锁sychronized </li>
<li>4 消费者消费的同时生产者不能生产     消费方法加锁sychronized </li>
<li>5 共享空间空时消费者不能继续消费     消费前循环判断是否为空，空的话将该线程wait，释放锁允许其他同步方法执行 </li>
<li>6 共享空间满时生产者不能继续生产     生产前循环判断是否为满，满的话将该线程wait，释放锁允许其他同步方法执行    </li>
</ul>
<p>a.经典的方法是使用wait和notify方法在生产者和消费者线程中合作；</p>
<p>b.使用阻塞队列。支持阻塞的方法put()和take()</p>
<p><a href="http://www.cnblogs.com/linjiqin/archive/2013/05/30/3108188.html" target="_blank" rel="external">http://www.cnblogs.com/linjiqin/archive/2013/05/30/3108188.html</a></p>
<p><a href="http://www.cnblogs.com/dolphin0520/p/3920385.html" target="_blank" rel="external">http://www.cnblogs.com/dolphin0520/p/3920385.html</a></p>
<blockquote>
<p>9.1 使用 wait和notify 模拟生产消费者模式</p>
</blockquote>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> waitNotifyPC {

    <span class="keyword">private</span> <span class="keyword">int</span> queueSize = <span class="number">10</span>;
    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; <span class="built_in">queue</span> = <span class="keyword">new</span> PriorityQueue&lt;&gt;(queueSize);


    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startwaitNoticyPC</span><span class="params">()</span></span>{
        <span class="keyword">new</span> Producer().start();
        <span class="keyword">new</span> Consumer().start();
    }

    <span class="keyword">class</span> Consumer extends Thread{
        @<span class="function">Override
        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
            consume();
        }

        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>{
            <span class="keyword">while</span> (<span class="literal">true</span>){
                synchronized (<span class="built_in">queue</span>){
                    <span class="keyword">while</span> (<span class="built_in">queue</span>.size()==<span class="number">0</span>){
                        <span class="keyword">try</span> {
                            Utils.<span class="built_in">log</span>(<span class="string">"队列空，等待数据"</span>);
                            <span class="built_in">queue</span>.wait();
                        } <span class="keyword">catch</span> (InterruptedException e) {
                            e.printStackTrace();
                            <span class="built_in">queue</span>.notify();
                        }
                    }
                    <span class="comment">//每次都移走首元素</span>
                    <span class="built_in">queue</span>.poll();
                    <span class="built_in">queue</span>.notify();
                    Utils.<span class="built_in">log</span>(<span class="string">"从队列取走一个元素，队列剩余"</span> + <span class="built_in">queue</span>.size() + <span class="string">"个元素"</span>);
                }
            }
        }
    }

    <span class="keyword">class</span> Producer extends Thread{
        @<span class="function">Override
        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
            produce();
        }

        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>{
            <span class="keyword">while</span> (<span class="literal">true</span>){
                synchronized (<span class="built_in">queue</span>){
                    <span class="keyword">while</span> (<span class="built_in">queue</span>.size() == queueSize){
                        <span class="keyword">try</span> {
                            Utils.<span class="built_in">log</span>(<span class="string">"队列满，等待有空余空间"</span>);
                            <span class="built_in">queue</span>.wait();
                        } <span class="keyword">catch</span> (InterruptedException e) {
                            e.printStackTrace();
                            <span class="built_in">queue</span>.notify();
                        }
                    }
                    <span class="built_in">queue</span>.offer(<span class="number">1</span>);<span class="comment">//每次插入一个元素</span>
                    <span class="built_in">queue</span>.notify();
                    Utils.<span class="built_in">log</span>(<span class="string">"向队列取中插入一个元素，队列剩余空间："</span> + (queueSize - <span class="built_in">queue</span>.size()));

                }
            }
        }
    }




}
</code></pre><p>LogCat:</p>
<pre><code><span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">59</span>:<span class="number">28.929</span>    <span class="number">4438</span>-<span class="number">4497</span>/sabria.demo.threadpractice I/MainActivity﹕ 队列空，等待数据
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">59</span>:<span class="number">28.929</span>    <span class="number">4438</span>-<span class="number">4495</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">9</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">59</span>:<span class="number">28.929</span>    <span class="number">4438</span>-<span class="number">4497</span>/sabria.demo.threadpractice I/MainActivity﹕ 从队列取走一个元素，队列剩余<span class="number">0</span>个元素
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">59</span>:<span class="number">28.929</span>    <span class="number">4438</span>-<span class="number">4497</span>/sabria.demo.threadpractice I/MainActivity﹕ 队列空，等待数据
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">59</span>:<span class="number">28.929</span>    <span class="number">4438</span>-<span class="number">4495</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">9</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">59</span>:<span class="number">28.929</span>    <span class="number">4438</span>-<span class="number">4495</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">8</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">59</span>:<span class="number">28.929</span>    <span class="number">4438</span>-<span class="number">4495</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">7</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">59</span>:<span class="number">28.929</span>    <span class="number">4438</span>-<span class="number">4495</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">6</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">59</span>:<span class="number">28.929</span>    <span class="number">4438</span>-<span class="number">4495</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">5</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">59</span>:<span class="number">28.929</span>    <span class="number">4438</span>-<span class="number">4495</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">4</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">59</span>:<span class="number">28.929</span>    <span class="number">4438</span>-<span class="number">4497</span>/sabria.demo.threadpractice I/MainActivity﹕ 从队列取走一个元素，队列剩余<span class="number">5</span>个元素
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">59</span>:<span class="number">28.929</span>    <span class="number">4438</span>-<span class="number">4497</span>/sabria.demo.threadpractice I/MainActivity﹕ 从队列取走一个元素，队列剩余<span class="number">4</span>个元素
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">59</span>:<span class="number">28.929</span>    <span class="number">4438</span>-<span class="number">4497</span>/sabria.demo.threadpractice I/MainActivity﹕ 从队列取走一个元素，队列剩余<span class="number">3</span>个元素
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">59</span>:<span class="number">28.929</span>    <span class="number">4438</span>-<span class="number">4497</span>/sabria.demo.threadpractice I/MainActivity﹕ 从队列取走一个元素，队列剩余<span class="number">2</span>个元素
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">59</span>:<span class="number">28.929</span>    <span class="number">4438</span>-<span class="number">4497</span>/sabria.demo.threadpractice I/MainActivity﹕ 从队列取走一个元素，队列剩余<span class="number">1</span>个元素
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">59</span>:<span class="number">28.929</span>    <span class="number">4438</span>-<span class="number">4497</span>/sabria.demo.threadpractice I/MainActivity﹕ 从队列取走一个元素，队列剩余
</code></pre><p>9.2 使用Condition模拟生产消费者模式</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> conditionPC {

    <span class="keyword">private</span> <span class="keyword">int</span> queueSize = <span class="number">10</span>;
    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; <span class="built_in">queue</span> = <span class="keyword">new</span> PriorityQueue&lt;&gt;(queueSize);
    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();
    <span class="keyword">private</span> Condition notFull = lock.newCondition();
    <span class="keyword">private</span> Condition notEmpty = lock.newCondition();


    <span class="comment">/**
     *

     */</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startConditionPC</span><span class="params">()</span> </span>{
        <span class="keyword">new</span> Product().start();

        <span class="keyword">new</span> Consumer().start();

    }


    <span class="keyword">class</span> Product extends Thread {
        @<span class="function">Override
        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
            produce();
        }

        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>{
            <span class="keyword">while</span> (<span class="literal">true</span>) {
                lock.lock();

                <span class="keyword">try</span> {
                    <span class="keyword">while</span> (<span class="built_in">queue</span>.size() == queueSize) {

                        <span class="keyword">try</span> {
                            Utils.<span class="built_in">log</span>(<span class="string">"队列满，等待有空余空间"</span>);
                            notFull.await();
                        } <span class="keyword">catch</span> (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }

                    <span class="built_in">queue</span>.offer(<span class="number">1</span>);<span class="comment">//每次插入一个元素</span>
                    notEmpty.signal();<span class="comment">//对应Object的notify()</span>
                    Utils.<span class="built_in">log</span>(<span class="string">"向队列取中插入一个元素，队列剩余空间："</span> + (queueSize - <span class="built_in">queue</span>.size()));
                } finally {
                    lock.unlock();
                }


            }


        }
    }

    <span class="keyword">class</span> Consumer extends Thread{

        @<span class="function">Override
        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
            consume();
        }

        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>{

            <span class="keyword">while</span> (<span class="literal">true</span>){
                lock.lock();


                <span class="keyword">try</span> {

                    <span class="comment">//队列不为空,就取poll,为空就await</span>
                    <span class="keyword">while</span> (<span class="built_in">queue</span>.size()==<span class="number">0</span>){

                        <span class="keyword">try</span> {

                            Utils.<span class="built_in">log</span>(<span class="string">"队列满，等待有空余空间"</span>);
                            notEmpty.await();

                        } <span class="keyword">catch</span> (InterruptedException e) {
                            e.printStackTrace();
                        }


                    }

                    <span class="built_in">queue</span>.poll();
                    notFull.signal();

                    Utils.<span class="built_in">log</span>(<span class="string">"从队列取走一个元素，队列剩余"</span>+<span class="built_in">queue</span>.size()+<span class="string">"个元素"</span>);

                }finally {
                    lock.unlock();
                }
            }
        }
    }


}
</code></pre><p>LogCat:</p>
<pre><code><span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">9</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">8</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">7</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">6</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">5</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">4</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">3</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">2</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">1</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">0</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 队列满，等待有空余空间
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">813</span>/sabria.demo.threadpractice I/MainActivity﹕ 从队列取走一个元素，队列剩余<span class="number">9</span>个元素
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">813</span>/sabria.demo.threadpractice I/MainActivity﹕ 从队列取走一个元素，队列剩余<span class="number">8</span>个元素
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">813</span>/sabria.demo.threadpractice I/MainActivity﹕ 从队列取走一个元素，队列剩余<span class="number">7</span>个元素
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">813</span>/sabria.demo.threadpractice I/MainActivity﹕ 从队列取走一个元素，队列剩余<span class="number">6</span>个元素
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">813</span>/sabria.demo.threadpractice I/MainActivity﹕ 从队列取走一个元素，队列剩余<span class="number">5</span>个元素
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">813</span>/sabria.demo.threadpractice I/MainActivity﹕ 从队列取走一个元素，队列剩余<span class="number">4</span>个元素
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">813</span>/sabria.demo.threadpractice I/MainActivity﹕ 从队列取走一个元素，队列剩余<span class="number">3</span>个元素
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">813</span>/sabria.demo.threadpractice I/MainActivity﹕ 从队列取走一个元素，队列剩余<span class="number">2</span>个元素
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">813</span>/sabria.demo.threadpractice I/MainActivity﹕ 从队列取走一个元素，队列剩余<span class="number">1</span>个元素
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">813</span>/sabria.demo.threadpractice I/MainActivity﹕ 从队列取走一个元素，队列剩余<span class="number">0</span>个元素
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">813</span>/sabria.demo.threadpractice I/MainActivity﹕ 队列满，等待有空余空间
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">9</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">8</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">7</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">6</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">5</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">4</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">3</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">2</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">1</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 向队列取中插入一个元素，队列剩余空间：<span class="number">0</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">26.759</span>      <span class="number">774</span>-<span class="number">812</span>/sabria.demo.threadpractice I/MainActivity﹕ 队列满，等待有空余空间
......
</code></pre><blockquote>
<p>9.3 使用阻塞队列模式模拟生成消费者模式:</p>
</blockquote>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> PCMechanism {

    BlockingQueue&lt;Integer&gt; <span class="built_in">queue</span> = <span class="keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(<span class="number">10</span>);

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startPcM</span><span class="params">()</span></span>{

        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
            @<span class="function">Override
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                <span class="keyword">try</span> {
                    producer();
                } <span class="keyword">catch</span> (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
            @<span class="function">Override
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                <span class="keyword">try</span> {
                    consumer();
                } <span class="keyword">catch</span> (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        thread1.start();
        thread2.start();


    }



    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> throws InterruptedException </span>{
        Random random = <span class="keyword">new</span> Random();
        <span class="keyword">while</span> (<span class="literal">true</span>){
            <span class="built_in">queue</span>.put(random.nextInt(<span class="number">100</span>));
        }

    }

    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> throws InterruptedException </span>{
        Random random = <span class="keyword">new</span> Random();
        <span class="keyword">while</span> (<span class="literal">true</span>){
            Thread.sleep(<span class="number">100</span>);
            <span class="keyword">if</span> (random.nextInt(<span class="number">10</span>) == <span class="number">0</span>) {
                Integer value =  <span class="built_in">queue</span>.take();
                Utils.<span class="built_in">log</span>(<span class="string">"Taken value: "</span> + value + <span class="string">"; Queue size is: "</span> + <span class="built_in">queue</span>.size());
            }
        }
    }


}
</code></pre><p>LogCat:</p>
<pre><code><span class="number">12</span>-<span class="number">17</span> <span class="number">17</span>:<span class="number">07</span>:<span class="number">50.499</span>    <span class="number">9132</span>-<span class="number">9220</span>/sabria.demo.threadpractice I/MainActivity﹕ Taken value: <span class="number">37</span>; Queue size is: <span class="number">10</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">17</span>:<span class="number">07</span>:<span class="number">50.699</span>    <span class="number">9132</span>-<span class="number">9220</span>/sabria.demo.threadpractice I/MainActivity﹕ Taken value: <span class="number">2</span>; Queue size is: <span class="number">9</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">17</span>:<span class="number">07</span>:<span class="number">50.999</span>    <span class="number">9132</span>-<span class="number">9220</span>/sabria.demo.threadpractice I/MainActivity﹕ Taken value: <span class="number">77</span>; Queue size is: <span class="number">10</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">17</span>:<span class="number">07</span>:<span class="number">51.199</span>    <span class="number">9132</span>-<span class="number">9220</span>/sabria.demo.threadpractice I/MainActivity﹕ Taken value: <span class="number">47</span>; Queue size is: <span class="number">10</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">17</span>:<span class="number">07</span>:<span class="number">52.909</span>    <span class="number">9132</span>-<span class="number">9220</span>/sabria.demo.threadpractice I/MainActivity﹕ Taken value: <span class="number">40</span>; Queue size is: <span class="number">9</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">17</span>:<span class="number">07</span>:<span class="number">53.699</span>    <span class="number">9132</span>-<span class="number">9220</span>/sabria.demo.threadpractice I/MainActivity﹕ Taken value: <span class="number">57</span>; Queue size is: <span class="number">9</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">17</span>:<span class="number">07</span>:<span class="number">56.319</span>    <span class="number">9132</span>-<span class="number">9220</span>/sabria.demo.threadpractice I/MainActivity﹕ Taken value: <span class="number">76</span>; Queue size is: <span class="number">9</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">17</span>:<span class="number">07</span>:<span class="number">56.519</span>    <span class="number">9132</span>-<span class="number">9220</span>/sabria.demo.threadpractice I/MainActivity﹕ Taken value: <span class="number">39</span>; Queue size is: <span class="number">10</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">17</span>:<span class="number">07</span>:<span class="number">57.029</span>    <span class="number">9132</span>-<span class="number">9220</span>/sabria.demo.threadpractice I/MainActivity﹕ Taken value: <span class="number">70</span>; Queue size is: <span class="number">10</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">17</span>:<span class="number">07</span>:<span class="number">58.019</span>    <span class="number">9132</span>-<span class="number">9220</span>/sabria.demo.threadpractice I/MainActivity﹕ Taken value: <span class="number">13</span>; Queue size is: <span class="number">10</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">17</span>:<span class="number">07</span>:<span class="number">59.829</span>    <span class="number">9132</span>-<span class="number">9220</span>/sabria.demo.threadpractice I/MainActivity﹕ Taken value: <span class="number">51</span>; Queue size is: <span class="number">9</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">17</span>:<span class="number">08</span>:<span class="number">00.229</span>    <span class="number">9132</span>-<span class="number">9220</span>/sabria.demo.threadpractice I/MainActivity﹕ Taken value: <span class="number">48</span>; Queue size is: <span class="number">9</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">17</span>:<span class="number">08</span>:<span class="number">00.539</span>    <span class="number">9132</span>-<span class="number">9220</span>/sabria.demo.threadpractice I/MainActivity﹕ Taken value: <span class="number">76</span>; Queue size is: <span class="number">9</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">17</span>:<span class="number">08</span>:<span class="number">01.839</span>    <span class="number">9132</span>-<span class="number">9220</span>/sabria.demo.threadpractice I/MainActivity﹕ Taken value: <span class="number">54</span>; Queue size is: <span class="number">10</span>
<span class="number">12</span>-<span class="number">17</span> <span class="number">17</span>:<span class="number">08</span>:<span class="number">02.949</span>    <span class="number">9132</span>-<span class="number">9220</span>/sabria.demo.threadpractice I/MainActivity﹕ Taken value: <span class="number">34</span>; Queue size is: <span class="number">9</span>
......
</code></pre></span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/03/ZT12_2/" itemprop="url">
                【正谈12月】动态代理范式编程-Part1
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-03T21:32:48+08:00" content="2015-12-03">
            2015-12-03
          </time>
        </span>

        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="一-代理模式">一.代理模式</h2><p>###1.1 概念</p>
<p><img src="http://i.imgur.com/FBNavuM.jpg" alt=""></p>
<p>对其他对象提供一种代理以控制对这个对象的访问</p>
<p>浅显理解一下：  </p>
<pre><code><span class="literal">A</span> 需要访问 C 
</code></pre><p>—&gt;  </p>
<pre><code>A 通过 <span class="keyword">B </span>间接访问 到C
</code></pre><p>其中的代理B和目标对象C都是实现同一个接口，因此他们可以都彼此了解。</p>
<p>在某些情况下，一个客户不想或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。表面上客户是在访问代理对象，实际代理对象中访问中调用的是目标对象的方法。</p>
<h3 id="2-操作方案：">2.操作方案：</h3><p><img src="http://i.imgur.com/UZEHkFf.png" alt=""></p>
<p>1.定义一个共同型接口</p>
<pre><code><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">CommonInter</span>{                    
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSting</span>(<span class="params"></span>)</span>;        
} 
</code></pre><p>2.实际目标对象</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonInterImp</span>  <span class="keyword">implements</span> <span class="title">CommonInter</span></span>{  

    <span class="annotation">@Override</span>  
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSting</span><span class="params">()</span> </span>{  
        System.out.println(<span class="string">"CommonInterImp"</span>);                
    }  

}      
</code></pre><p>3.创建代理对象</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommProxy</span> <span class="keyword">implements</span> <span class="title">CommonInter</span> </span>{  

    <span class="comment">//多态--持有接口实现对象的引用</span>
    <span class="keyword">private</span> CommonInter commonInter;  

    <span class="function"><span class="keyword">public</span> <span class="title">CommProxy</span><span class="params">()</span></span>{
        <span class="comment">//默认是实现类commonInterImp</span>
        <span class="keyword">this</span>.commonInter = <span class="keyword">new</span> commonInterImp();  
    }  

    <span class="function"><span class="keyword">public</span> <span class="title">CommProxy</span><span class="params">(CommonInter commonInter)</span></span>{ 
        <span class="comment">//其他的任何一个实现类 </span>
        <span class="keyword">this</span>.commonInter = commonInter;  
    }  

    <span class="annotation">@Override</span>  
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSting</span><span class="params">()</span> </span>{  
        <span class="comment">//实际调用的是目标对象的doSting();              </span>
        <span class="keyword">this</span>.commonInter.doSting();  

    }        
}
</code></pre><p>4.调用</p>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
     <span class="comment">//创建代理对象  </span>
     CommProxy proxy = <span class="keyword">new</span> CommProxy();  
     <span class="comment">//表面调用代理对象的方法，实际上代理中是调用的目标对象的方法  </span>
     proxy.doSting();  
}
</code></pre><h2 id="二-动态代理">二.动态代理</h2><h3 id="2-1_概念">2.1 概念</h3><p>在某些情况下，我们A不希望或是不能直接访问对象 C，而是通过访问一个中介对象 B，由 B 去访问 C 达成目的，这种方式我们就称为代理。</p>
<ul>
<li><em>A：工作对象(Client)</em></li>
<li><em>B：代理类(Proxy)</em></li>
<li><em>C：被代理类，委托类，目标对象(RealObject)</em></li>
</ul>
<p>代理优点有：</p>
<pre><code><span class="number">1.</span>隐藏目标对象的实现
<span class="number">2.</span>解耦，不改变目标对象代码情况下做一些额外处理，比如添加初始判断及其他公共操作.
</code></pre><p>一个非常典型的使用场景比如：<br>代理类：</p>
<pre><code><span class="keyword">class</span> <span class="title">CommProxy</span> <span class="title">implements</span> <span class="title">CommInter</span>  {  
    <span class="keyword">private</span> CommonInter impl;

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSting</span>(<span class="params"></span>)  </span>{  
        <span class="keyword">if</span> (impl==<span class="keyword">null</span>)  {  
            impl = <span class="keyword">new</span> commonInterImp();  
        }  
        doBefore();  
        impl.doSting();  
        doAfter();  
    }  
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span>(<span class="params"></span>)  </span>{  
        System.<span class="keyword">out</span>.println(<span class="string">"前置处理！"</span>);  
    }  
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span>(<span class="params"></span>)  </span>{  
        System.<span class="keyword">out</span>.println(<span class="string">"后置处理！"</span>);  
    }  
}
</code></pre><p>静态代理：代理类在程序运行前已经存在的代理方式称为静态代理。</p>
<p>动态代理：代理类在程序运行前不存在、运行时由程序动态生成的代理方式称为动态代理。</p>
<h3 id="2-2_实现动态代理包括三步：">2.2 实现动态代理包括三步：</h3><p>(1). 新建目标对象；</p>
<p>(2). 实现InvocationHandler接口，这是负责连接代理类和目标对象的中间类必须实现的接口；</p>
<p>(3). 通过Proxy类新建代理类对象。</p>
<p>本质：<br>动态代理实现实际是双层的静态代理，开发者提供了目标对象C，程序动态生成了代理类 A：$Proxy。开发者还需要提供一个实现了InvocationHandler的子类 B。B它其实是连接程序自动生成的动态代理类 A 和目标对象 C</p>
<p>工作对象—》调用程序生成的动态代理A—》调用链接子类B—》目标对象C</p>
<h3 id="2-3_几个API参数的含义：">2.3 几个API参数的含义：</h3><p>1.public Object invoke(Object proxy, Method method, Object[] args)  </p>
<pre><code>* <span class="variable">@param</span> proxy 在其上调用方法的代理实例,通过 Proxy.<span class="function">newProxyInstance</span>() 生成的代理类对象：&amp;Proxy
* <span class="variable">@param</span> method 对应于在代理对象&amp;Proxy上调用的接口方法的 Method 实例
* <span class="variable">@param</span> args &amp;Proxy对象的method的参数，如果没有，设为null
</code></pre><p>2.Object result = method.invoke(obj,args);  </p>
<pre><code>* <span class="variable">@param</span> Object receiver 执行这个方法的对象owner,一般创建动态代理时指定的目标对象
* <span class="variable">@param</span> Object... args 方法上的参数
</code></pre><p>3.Proxy.newProxyInstance(cls.getClassLoader(),cls.getInterfaces(),new ProxyInvocationHandler(obj));  </p>
<pre><code>* <span class="variable">@param</span> ClassLoader loader loader表示目标对象的类加载器
* <span class="variable">@param</span> Class&lt;?&gt;[] interfaces interfaces表示目标对象的接口，生成代理类时需要实现这些接口
* <span class="variable">@param</span> InvocationHandler h是InvocationHandler实现类对象，负责连接动态代理类和目标对象的中间类
</code></pre><h3 id="2-4_动态代理范例：">2.4 动态代理范例：</h3><p>1.新建目标对象：</p>
<pre><code><span class="comment">//共同接口对象</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CommonInter</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doString</span><span class="params">()</span></span>;
}

<span class="comment">//目标对象</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonInterImp</span> <span class="keyword">implements</span> <span class="title">CommonInter</span></span>{
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doString</span><span class="params">()</span> </span>{
        System.out.print(<span class="string">"CommonInterImp---doString()"</span>);

    }
}    
</code></pre><p>2.动态角色实现InvocationHandler 接口，它将动态生成代理类。</p>
<pre><code>public class <span class="type">ProxyInvocationHandler</span> implements <span class="type">InvocationHandler</span>{

    private <span class="type">Object</span> obj;

    /**
     * 这里传进来的就是目标对象,它要去调用invoke方法
     * @param obj
     */
    <span class="type">ProxyInvocationHandler</span>(<span class="type">Object</span> obj){
        this.obj=obj;
    }


    /**
     *
     * @param proxy   在其上调用方法的代理实例,通过 <span class="type">Proxy</span>.newProxyInstance() 生成的代理类对象
     * @param <span class="keyword">method</span>  代理对象被调用的函数
     * @param args    代理对象被调用的函数的参数，如果没有，设为null
     * @<span class="keyword">return</span>
     * @throws <span class="type">Throwable</span>
     */
    @<span class="type">Override</span>
    public <span class="type">Object</span> invoke(<span class="type">Object</span> proxy, <span class="type">Method</span> <span class="keyword">method</span>, <span class="type">Object</span>[] args) throws <span class="type">Throwable</span> {
        //前置操作
        doBefore();
        /**
         * @param <span class="type">Object</span> receiver 执行这个方法的对象owner,一般创建动态代理时指定的目标对象
         * @param <span class="type">Object</span>... args 方法上的参数
         */
        <span class="type">Object</span> <span class="literal">result</span>=<span class="keyword">method</span>.invoke(obj,args);
        //后置操作
        doAfter();
        <span class="keyword">return</span> <span class="literal">result</span>;
    }

    /**
     * 工厂
     * @param obj
     * @<span class="keyword">return</span>
     */
    public <span class="keyword">static</span>  <span class="type">Object</span> factory(<span class="type">Object</span> obj){
        <span class="type">Class</span>&lt;?&gt; cls = obj.getClass();
        /**
         * @param <span class="type">ClassLoader</span> loader loader表示类加载器
         * @param <span class="type">Class</span>&lt;?&gt;[] interfaces 表示委托类的接口，生成代理类时需要实现这些接口
         * @param <span class="type">InvocationHandler</span> invocationHandler h是<span class="type">InvocationHandler</span>实现类对象，负责连接代理类和委托类的中间类
         */
        <span class="keyword">return</span> <span class="type">Proxy</span>.newProxyInstance(cls.getClassLoader(),cls.getInterfaces(),new <span class="type">ProxyInvocationHandler</span>(obj));
    }


    private <span class="type">void</span> doBefore() {
        <span class="type">System</span>.<span class="keyword">out</span>.print(<span class="string">"doBefore"</span>);
    }

    private <span class="type">void</span> doAfter() {
        <span class="type">System</span>.<span class="keyword">out</span>.print(<span class="string">"doAfter"</span>);
    }
}
</code></pre><p>3.通过 Proxy 类静态函数生成代理对象</p>
<pre><code>/<span class="keyword">*</span><span class="keyword">*</span>
 <span class="keyword">*</span> 工厂
 <span class="keyword">*</span> <span class="comment">@param obj</span>
 <span class="keyword">*</span> <span class="comment">@return</span>
 <span class="keyword">*</span>/
public static  Object factory(Object obj){
    Class<span class="variable">&lt;?&gt;</span> cls = obj.getClass();
    /<span class="keyword">*</span><span class="keyword">*</span>
    <span class="keyword">*</span> <span class="comment">@param ClassLoader loader loader表示目标对象的类加载器</span>
    <span class="keyword">*</span> <span class="comment">@param Class&lt;?&gt;[] interfaces 表示目标对象的接口，生成代理类时需要实现这些接口</span>
    <span class="keyword">*</span> <span class="comment">@param InvocationHandler invocationHandler h是InvocationHandler实现类对象，负责连接代理类和委托类的中间类</span>
    <span class="keyword">*</span>/
    return Proxy.newProxyInstance(cls.getClassLoader(),cls.getInterfaces(),new ProxyInvocationHandler(obj));
}
</code></pre><p>4.调用：</p>
<pre><code><span class="keyword">private</span> void getDynamicProxy<span class="literal">()</span> {
    <span class="type">CommonInterImp</span> commonInterImp = <span class="keyword">new</span> <span class="type">CommonInterImp</span><span class="literal">()</span>;
    <span class="type">CommonInter</span> tiny = (<span class="type">CommonInter</span>)<span class="type">ProxyInvocationHandler</span>.factory(commonInterImp);
    tiny.doString<span class="literal">()</span>;
}
</code></pre><h3 id="2-5_动态代理在Android中应用的本质">2.5 动态代理在Android中应用的本质</h3><p>所接触到的开源项目中,动态代理都是为封装代码而存在，它将我们需求完成的操作，都通过一句话调用完成：</p>
<p>比如原始HTTP请求Retrofit</p>
<blockquote>
<p>拼接请求 —URL发送HTTP请求—获取JSON —解析JSON为Bean对象 —&gt;显示数据</p>
</blockquote>
<p>Retrofit的动态代理封装了:</p>
<blockquote>
<p>URL发送HTTP请求—&gt; 获取JSON —&gt; 解析JSON为Bean对象</p>
</blockquote>
<p>变成:</p>
<blockquote>
<p>拼接请求 — Retrofit 动态代理 invoke() 完成 通用操作 —&gt;显示数据</p>
</blockquote>
<p>当你调用Retrofit时你要完成的只不过是拼接请求,而后Retrofit的动态代理invoke中完成<br>“使用OKHttp完成网络请求，获取JSON并解析为Bean对象返回”的操作.</p>
<p>最终目的是为了：“代码结构的简化,封装优良调用”的目的.</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/02/ZT12_1/" itemprop="url">
                【正谈12月】取之于开源,必回归于开源
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-02T22:32:48+08:00" content="2015-12-02">
            2015-12-02
          </time>
        </span>

        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>优雅的开源代码到Github,并提供Jcenter下载</p>
<p>##一. 发布项目到Github<br>你会看到无数的如何开源代码到GitHub文章，他们极度强调装逼般的使用命名行配合Git工具的方案来处理代码的上传.不评价这种方案，但在我的理解中,上传代码究竟目的是什么,难道不是为了更方便的维护代码和更新和管理代码吗,Git命令行的方式,很难直观的感知文件的各种Git状态，和选择上传具体哪个文件。并且操作极度麻烦。所以,我们究竟是应该把开源放在秀技术上，还是放在有效优雅的管理代码上.这是个值得深思的问题.本文不会告知你如何装逼的命令行开源代码到GitHub,自己有兴趣去百度吧.<br>我仍然希望我们一定要知道自己要做的这件事的目的是什么,不要本末倒置的来发现和处理问题.</p>
<p><a href="http://blog.csdn.net/deng0zhaotai/article/details/38760883?utm_source=tuicool&amp;utm_medium=referral" title="http://blog.csdn.net/deng0zhaotai/article/details/38760883?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">命令行装逼型文章,请移步此</a></p>
<h3 id="方案_1-1-_通过GitHub配合GitHub-Desktop">方案 1.1. 通过GitHub配合GitHub-Desktop</h3><p>该方案旨在不通过AndroidStudio实现上传代码到GitHub<br>此方法虽然操作比方案2复杂，但通用性强,C代码,python代码,或者任何一门语言的代码都可以这样上传.并可以自己控制目录层级.</p>
<p>操作步骤一：<br>1.在GitHub中New Repositories</p>
<p><img src="http://i.imgur.com/8JR2S9S.png" alt=""></p>
<p><img src="http://i.imgur.com/YHZtZ9X.png" alt=""></p>
<p>注意指定Languages为Android,然后开源许可授权可以指定你希望的授权模式,一般选Apcahe License2.0</p>
<p><a href="http://www.apache.org/licenses/LICENSE-2.0.html" title="Apcahe License2.0" target="_blank" rel="external">Apcahe License2.0协议见此</a></p>
<p><img src="http://i.imgur.com/cFwn08C.png" alt=""></p>
<p>生成的library是空白的,只有需求initialize的README.md.</p>
<p>2.下载并获取GitHub-Desktop软件</p>
<p><a href="https://desktop.github.com/" title="https://desktop.github.com/" target="_blank" rel="external">https://desktop.github.com/</a></p>
<p>3.clone library 到 GitHub-Desktop.</p>
<p><img src="http://i.imgur.com/D7ynkwj.png" alt=""></p>
<p><img src="http://i.imgur.com/pRpUPeh.png" alt=""></p>
<p><img src="http://i.imgur.com/qzMr4gn.png" alt=""></p>
<p>4.在AndroidStudio中完成library</p>
<p><img src="http://i.imgur.com/9xHsFPG.png" alt=""></p>
<p>5.将library的整个文件包复制粘贴到clone library下来的地址中</p>
<p><img src="http://i.imgur.com/T3sVUwr.png" alt=""></p>
<p><img src="http://i.imgur.com/P4E0iXc.png" alt=""></p>
<p><img src="http://i.imgur.com/UANZiA4.png" alt=""></p>
<p>6.此时GitHub-Desktop就会自动感知有文件发生了”Change”</p>
<p><img src="http://i.imgur.com/YGhbiFo.png" alt=""></p>
<p>7.提交并同步到GitHub</p>
<p><img src="http://i.imgur.com/bauziZK.png" alt=""></p>
<p><img src="http://i.imgur.com/O8n8v0X.png" alt=""></p>
<p>自此你就完成了第一次同步代码到GitHub.</p>
<p><img src="http://i.imgur.com/m9oYczn.png" alt=""></p>
<p>若想更新，可以使用Android Stuido import project的方式，这样的话,就将Android Stuido和library的git状态关联起来了.<br>然后每次修改后,在GitHub-Desktop中都会将修改文件状态关联到”Change”,然后更新并同步GitHub就行了.</p>
<h3 id="方案_1-2-_通过AndroidStudio配合GitHub-Desktop">方案 1.2. 通过AndroidStudio配合GitHub-Desktop</h3><p>1.在AndroidStudio中创建一个项目,并选择share 到 GitHub</p>
<p><img src="http://i.imgur.com/Bp5rjkm.png" alt=""></p>
<p>2.初次会让你登陆GitHub</p>
<p><img src="http://i.imgur.com/XjEZhcZ.png" alt=""></p>
<p>3.初次会创建主分支的密码</p>
<p><img src="http://i.imgur.com/Q1L5DRr.png" alt=""></p>
<p>4.初次提交填写描述</p>
<p><img src="http://i.imgur.com/d6Rg2Eu.png" alt=""></p>
<p>此时提交后,就直接发布到了GitHub,同时,在AndroidStudio中就能直接关联到git文件的几种信息状态了.</p>
<p><img src="http://i.imgur.com/dyFX5zZ.png" alt=""></p>
<p>更新的话,就直接在AndroidStuido更新了(就和你平时做项目git管理一样:Add-Commit-Pull)，或者通过GitHub-Desktop,它也会感知”Change”.</p>
<p><img src="http://i.imgur.com/wHZ4GO6.png" alt=""></p>
<p>##二. 上传代码到 Jcenter</p>
<p>我们开源项目后，需要提供Maven或者Gradle compile 地址,比如：</p>
<pre><code><span class="keyword">compile</span> <span class="string">'com.squareup.retrofit:retrofit:2.0.0-beta2'</span>
</code></pre><p>这样其他开放者就可以直接在Build.gradle中导入并编译我们的library.使用bintray将会非常方便的帮助我们完成这项工作.</p>
<p>1.使用github登录<a href="https://bintray.com" target="_blank" rel="external">https://bintray.com</a>;</p>
<p>2.获取：bintray.user  和 bintray.apikey;</p>
<p><img src="http://i.imgur.com/D7HO6Tf.png" alt=""></p>
<p>3.根目录的 local.properties,填写bintray.user和 bintray.apikey.注意请勿上传该文件到github(gitignore忽略这个文件到git );</p>
<p><img src="http://i.imgur.com/4hJmxaK.png" alt=""></p>
<p>4.根目录的 build:gradle 装载bintray插件</p>
<pre><code><span class="keyword">classpath</span> <span class="string">'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.0'</span>
<span class="keyword">classpath</span> <span class="string">'com.github.dcendents:android-maven-gradle-plugin:1.3'</span>
</code></pre><p><img src="http://i.imgur.com/oPpcFm0.png" alt=""></p>
<p>5.在library的build:gradle中  配置library参数,指定项目名称版本号等信息</p>
<p>操作步骤1:引入library plugin</p>
<pre><code><span class="tag">apply</span> <span class="rule"><span class="attribute">plugin</span>:<span class="value"> <span class="string">'com.jfrog.bintray'</span></span></span>
</code></pre><p>操作步骤2：读取local.properties文件中的user和appkey信息</p>
<pre><code><span class="comment">//important</span>
Properties properties = <span class="keyword">new</span> Properties()
properties.load(<span class="keyword">project</span>.rootProject.<span class="keyword">file</span>(<span class="string">'local.properties'</span>).newDataInputStream())

version = <span class="string">"1.0.0"</span><span class="comment">//发布的library的版本号,这个比较关键！！！</span>

<span class="keyword">def</span> siteUrl = <span class="string">'https://github.com/meilishenqi/GradeBar'</span>      <span class="comment">// 项目的主页(可随意，建议填library的github地址)</span>
<span class="keyword">def</span> gitUrl = <span class="string">'https://github.com/meilishenqi/GradeBar'</span>      <span class="comment">// Git仓库的url(可随意，建议填library的github地址)</span>
<span class="keyword">group</span> = <span class="string">"com.mlm.gradebar"</span>    <span class="comment">// 这里是groupId ,必须填写(建议填唯一的包名)</span>

bintray {
    user = properties.getProperty(<span class="string">"bintray.user"</span>) <span class="comment">//读取 local.properties 文件里面的 bintray.user</span>
    key = properties.getProperty(<span class="string">"bintray.apikey"</span>)

    <span class="keyword">configurations</span> = [<span class="string">'archives'</span>]
    pkg {
        repo = <span class="string">"maven"</span>
        <span class="keyword">group</span> = <span class="keyword">group</span>
        name = <span class="string">"gradebar"</span><span class="comment">//发布到JCenter上的项目名字，必须填写</span>
        websiteUrl = siteUrl
        vcsUrl = gitUrl
        licenses = [<span class="string">"Apache-2.0"</span>]
        publish = <span class="keyword">true</span>
    }
}
</code></pre><p><img src="http://i.imgur.com/EIdKKYQ.png" alt=""></p>
<p>操作步骤三(可选):执行install-task<br>如果不执行,不能自动生成pom.xml文件，注意需要装载插件apply plugin: ‘com.github.dcendents.android-maven’，否则无法运行install();</p>
<pre><code><span class="operator"><span class="keyword">install</span> {
    repositories.mavenInstaller {
        // This generates POM.<span class="keyword">xml</span> <span class="keyword">with</span> proper <span class="keyword">parameters</span>
        pom {
            <span class="keyword">project</span> {
                packaging <span class="string">'aar'</span>
                // <span class="keyword">Add</span> your description here
                <span class="keyword">name</span> <span class="string">'The library is a custom view about "Personal center consumption points" in our old version app'</span>     //项目描述
                <span class="keyword">url</span> siteUrl
                // <span class="keyword">Set</span> your license
                licenses {
                    license {
                        <span class="keyword">name</span> <span class="string">'The Apache Software License, Version 2.0'</span>
                        <span class="keyword">url</span> <span class="string">'http://www.apache.org/licenses/LICENSE-2.0.txt'</span>
                    }
                }
                developers {
                    developer {
                        <span class="keyword">id</span> <span class="string">'xiaomeixw'</span>        //开发者的基本信息(建议填自己名称)
                        <span class="keyword">name</span> <span class="string">'xiaomeixw'</span>    //开发者基本信息(建议填自己名称)
                        email <span class="string">'jpxw007@gmail.com'</span>   //开发者基本信息(建议填自己名称)
                    }
                }
                scm {
                    <span class="keyword">connection</span> gitUrl
                    developerConnection gitUrl
                    <span class="keyword">url</span> siteUrl
                }
            }
        }
    }
}</span>
</code></pre><p>5.通过命令行上传项目上传到Bintray</p>
<pre><code>gradlew <span class="keyword">install</span>
</code></pre><p><img src="http://i.imgur.com/8VHsif4.png" alt=""></p>
<pre><code><span class="label">gradlew</span> <span class="keyword">bintrayUpload </span>
</code></pre><p><img src="http://i.imgur.com/oslP3wf.png" alt=""></p>
<p>然后在bintray中查看：</p>
<p><img src="http://i.imgur.com/t2Ojkon.png" alt=""></p>
<p>6.点击Add to JCenter 添加到JCenter,然后填写信息</p>
<p><img src="http://i.imgur.com/FzNLPWu.png" alt=""></p>
<p>问题：1 在bintray点击添加到Add to JCenter</p>
<p>Please fix the following before submitting a JCenter inclusion request</p>
<p><img src="http://i.imgur.com/VcsEvHW.png" alt=""></p>
<p>解决方案一：</p>
<p>Use the non-zipped output or select “explode output” checkbox in the JCenter UI if you are using it.</p>
<p><a href="https://github.com/blundell/release-android-library/issues/3" target="_blank" rel="external">https://github.com/blundell/release-android-library/issues/3</a></p>
<p>其实这种情况产生的原因在于：你gradlew install时没有成功,没有自动生成pom.xml文件,所以导致在bintray中无法正常添加到Jcenter.</p>
<p>解决方案二:在library的build.gradle中添加install-task<br>同时需要添加插件：apply plugin: ‘com.github.dcendents.android-maven’，要不然找不到install().</p>
<pre><code>apply plugin: 'com.github.dcendents.android-maven'

<span class="operator"><span class="keyword">install</span> {
    repositories.mavenInstaller {
        // This generates POM.<span class="keyword">xml</span> <span class="keyword">with</span> proper <span class="keyword">parameters</span>
        pom {
            <span class="keyword">project</span> {
                packaging <span class="string">'aar'</span>
                // <span class="keyword">Add</span> your description here
                <span class="keyword">name</span> <span class="string">'The library is a custom view about "Personal center consumption points" in our old version app'</span>     //项目描述
                <span class="keyword">url</span> siteUrl
                // <span class="keyword">Set</span> your license
                licenses {
                    license {
                        <span class="keyword">name</span> <span class="string">'The Apache Software License, Version 2.0'</span>
                        <span class="keyword">url</span> <span class="string">'http://www.apache.org/licenses/LICENSE-2.0.txt'</span>
                    }
                }
                developers {
                    developer {
                        <span class="keyword">id</span> <span class="string">'xiaomeixw'</span>        //开发者基本信息
                        <span class="keyword">name</span> <span class="string">'xiaomeixw'</span>    //开发者基本信息
                        email <span class="string">'jpxw007@gmail.com'</span>   //开发者基本信息
                    }
                }
                scm {
                    <span class="keyword">connection</span> gitUrl
                    developerConnection gitUrl
                    <span class="keyword">url</span> siteUrl
                }
            }
        }
    }
}</span>
</code></pre><p>然后命令行重新：</p>
<pre><code>gradlew <span class="keyword">install</span>
</code></pre><p>问题：2 在cmd或者Android的命令行中运行gradlew install</p>
<p>FAILURE: Build failed with an exception.  提示出现编码问题</p>
<p><img src="http://i.imgur.com/wmxE2dP.png" alt=""></p>
<p>解决方案：library的build.gradle中添加：</p>
<pre><code><span class="comment">//</span>
<span class="keyword">task</span> javadoc(type: Javadoc) {
    <span class="keyword">source</span> = android.<span class="keyword">sourceSets</span>.main.java.srcDirs
    <span class="keyword">classpath</span> += <span class="keyword">project</span>.files(android.getBootClasspath().<span class="keyword">join</span>(<span class="keyword">File</span>.pathSeparator))
}
javadoc {
    <span class="keyword">options</span>{
        encoding <span class="string">"UTF-8"</span>
        charSet <span class="string">'UTF-8'</span>
        author <span class="keyword">true</span>
        version <span class="keyword">true</span>
        links <span class="string">"http://docs.oracle.com/javase/7/docs/api"</span>
    }
}
</code></pre><p>问题：3 Add To JCenter被拒绝<br>bintray需要四个基本文件才可以提供上传到JCenter服务：</p>
<p><img src="http://i.imgur.com/8qv5q7v.png" alt=""></p>
<ul>
<li><em>pom.xml</em></li>
<li><em>.aar file</em></li>
<li><em>sources jar</em></li>
<li><em>javadoc jar</em></li>
</ul>
<p><img src="http://i.imgur.com/ojjA6ZW.png" alt=""><br>但我第一个上传的版本只有2个文件，还需要sources.jar和javadoc.jar</p>
<p>解决方案在library的build.gradle中添加相关gradle的任务：</p>
<p><a href="http://stackoverflow.com/questions/11474729/how-to-build-sources-jar-with-gradle" target="_blank" rel="external">http://stackoverflow.com/questions/11474729/how-to-build-sources-jar-with-gradle</a></p>
<p>添加生成source.jar 任务：</p>
<pre><code><span class="keyword">task</span> sourcesJar(type: Jar) {
    <span class="keyword">from</span> android.<span class="keyword">sourceSets</span>.main.java.srcDirs
    classifier = <span class="string">'sources'</span>
}
</code></pre><p>添加生成javadoc.jar 任务：</p>
<pre><code><span class="keyword">task</span> javadocJar(type: Jar, dependsOn: javadoc) {
    classifier = <span class="string">'javadoc'</span>
    <span class="keyword">from</span> javadoc.<span class="keyword">destinationDir</span>
}
</code></pre><p>最后：</p>
<pre><code><span class="title">artifacts</span> {
    <span class="title">archives</span> javadocJar
    archives sourcesJar
}
</code></pre><p>再次重新 </p>
<pre><code>gradlew <span class="keyword">install</span>
</code></pre><p>然后上传</p>
<pre><code><span class="label">gradlew</span> <span class="keyword">bintrayUpload </span>
</code></pre><p>如果这次运行提示：</p>
<ul>
<li>What went wrong:<br>Execution failed for task ‘:library:bintrayUpload’.<br>org.apache.http.conn.HttpHostConnectException: Connection to <a href="https://api.bintray.com" target="_blank" rel="external">https://api.bintray.com</a> refused</li>
</ul>
<p>很简单,删除bintray上第一次上传的，然后重新上传运行一次.</p>
<p><img src="http://i.imgur.com/ekharB3.png" alt=""></p>
<p>然后Add To JCenter就可以了</p>
<p>最后附录library的完整build.gradle</p>
<pre><code>apply plugin: <span class="string">'com.android.library'</span>
apply plugin: <span class="string">'com.jfrog.bintray'</span><span class="comment">//improtant</span>
apply plugin: <span class="string">'com.github.dcendents.android-maven'</span><span class="comment">//for javadoc-task</span>


android {
    compileSdkVersion <span class="number">22</span>
    buildToolsVersion <span class="string">"22.0.1"</span>

    defaultConfig {
        minSdkVersion <span class="number">14</span>
        targetSdkVersion <span class="number">22</span>
        versionCode <span class="number">1</span>
        versionName <span class="string">"1.0"</span>
    }
    buildTypes {
        release {
            minifyEnabled <span class="keyword">false</span>
            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span>
        }
    }
}

<span class="keyword">dependencies</span> {
    <span class="keyword">compile</span> <span class="keyword">fileTree</span>(dir: <span class="string">'libs'</span>, <span class="keyword">include</span>: [<span class="string">'*.jar'</span>])
}

<span class="comment">//important</span>
<span class="keyword">task</span> javadoc(type: Javadoc) {
    <span class="keyword">source</span> = android.<span class="keyword">sourceSets</span>.main.java.srcDirs
    <span class="keyword">classpath</span> += <span class="keyword">project</span>.files(android.getBootClasspath().<span class="keyword">join</span>(<span class="keyword">File</span>.pathSeparator))
}
javadoc {
    <span class="keyword">options</span>{
        encoding <span class="string">"UTF-8"</span>
        charSet <span class="string">'UTF-8'</span>
        author <span class="keyword">true</span>
        version <span class="keyword">true</span>
        links <span class="string">"http://docs.oracle.com/javase/7/docs/api"</span>
    }
}

<span class="comment">//important 自动生成pom.xml文件</span>
version = <span class="string">"1.0.0"</span><span class="comment">//发布的library的版本号</span>

<span class="keyword">def</span> siteUrl = <span class="string">'https://github.com/meilishenqi/GradeBar'</span>      <span class="comment">// 项目的主页(可随意)</span>
<span class="keyword">def</span> gitUrl = <span class="string">'https://github.com/meilishenqi/GradeBar'</span>      <span class="comment">// Git仓库的url(可随意)</span>
<span class="keyword">group</span> = <span class="string">"com.mlm.gradebar"</span>    <span class="comment">// 这里是groupId ,必须填写(建议填包名)</span>

install {
    <span class="keyword">repositories</span>.mavenInstaller {
        <span class="comment">// This generates POM.xml with proper parameters</span>
        pom {
            <span class="keyword">project</span> {
                packaging <span class="string">'aar'</span>
                <span class="comment">// Add your description here</span>
                name <span class="string">'The library is a custom view about "Personal center consumption points" in our old version app'</span>     <span class="comment">//项目描述</span>
                url siteUrl
                <span class="comment">// Set your license</span>
                licenses {
                    license {
                        name <span class="string">'The Apache Software License, Version 2.0'</span>
                        url <span class="string">'http://www.apache.org/licenses/LICENSE-2.0.txt'</span>
                    }
                }
                developers {
                    developer {
                        id <span class="string">'xiaomeixw'</span>        <span class="comment">//开发者基本信息</span>
                        name <span class="string">'xiaomeixw'</span>    <span class="comment">//开发者基本信息</span>
                        email <span class="string">'jpxw007@gmail.com'</span>   <span class="comment">//开发者基本信息</span>
                    }
                }
                scm {
                    connection gitUrl
                    developerConnection gitUrl
                    url siteUrl
                }
            }
        }
    }
}

<span class="comment">//生成source.jar</span>
<span class="keyword">task</span> sourcesJar(type: Jar) {
    <span class="keyword">from</span> android.<span class="keyword">sourceSets</span>.main.java.srcDirs
    classifier = <span class="string">'sources'</span>
}

<span class="comment">//生成javadocJar</span>
<span class="keyword">task</span> javadocJar(type: Jar, dependsOn: javadoc) {
    classifier = <span class="string">'javadoc'</span>
    <span class="keyword">from</span> javadoc.<span class="keyword">destinationDir</span>
}

<span class="keyword">artifacts</span> {
    archives sourcesJar
    archives javadocJar
}



<span class="comment">//important读取 local.properties 文件里面的 bintray.user和bintray.apikey</span>
Properties properties = <span class="keyword">new</span> Properties()
properties.load(<span class="keyword">project</span>.rootProject.<span class="keyword">file</span>(<span class="string">'local.properties'</span>).newDataInputStream())


bintray {
    user = properties.getProperty(<span class="string">"bintray.user"</span>)
    key = properties.getProperty(<span class="string">"bintray.apikey"</span>)

    <span class="keyword">configurations</span> = [<span class="string">'archives'</span>]
    pkg {
        repo = <span class="string">"maven"</span>
        <span class="keyword">group</span> = <span class="keyword">group</span>
        name = <span class="string">"gradebar"</span><span class="comment">//发布到JCenter上的项目名字，必须填写</span>
        websiteUrl = siteUrl
        vcsUrl = gitUrl
        licenses = [<span class="string">"Apache-2.0"</span>]
        publish = <span class="keyword">true</span>
    }
}
</code></pre><p>问题四：gradlew install 和 gradlew bintrayUpload 每次都要运行吗？</p>
<p>不是，gradlew install只在第一次运行,如果你提供了完整了四个文件，就无需再运行.</p>
<p>如果要更新version,只需要修改library的build.grade的</p>
<pre><code><span class="keyword">version</span> = <span class="string">"1.0.0"</span><span class="comment">//发布的library的版本号</span>
</code></pre><p>为</p>
<pre><code><span class="keyword">version</span> = <span class="string">"1.0.1"</span><span class="comment">//发布的library的版本号</span>
</code></pre><p>然后</p>
<pre><code><span class="label">gradlew</span> <span class="keyword">bintrayUpload </span>
</code></pre><p>就可以了，发布完成，也不需要 add jcenter, bintray会自动帮你更新version.</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/11/16/ZT11_2/" itemprop="url">
                【正谈11月】链式调用模式封装
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-11-16T22:32:48+08:00" content="2015-11-16">
            2015-11-16
          </time>
        </span>

        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>链式调用模式封装</p>
<p>链式调用以点链形态表现API,最大的优势在于封装接口,API接口简单、使用方便,能够快速的记忆以及快速的拓展API。</p>
<pre><code><span class="tag">Tom</span><span class="class">.with</span>(<span class="tag">context</span>)
      <span class="class">.analyze</span>(<span class="tag">image</span>)
          <span class="class">.perform</span>(<span class="tag">calculus</span>)
                  <span class="class">.showMe</span>(<span class="tag">answer</span>);
</code></pre><blockquote>
<p>It’s like saying: “Tom, analyze this image, perform some calculus and give me the answer!”</p>
</blockquote>
<p>链式调用又分为：</p>
<ul>
<li><p><em>单类链式调用</em>：链式调用的元素都在单个类中完成操作.</p>
</li>
<li><p><em>多类间链式调用</em>：链式调用的元素分布在多个类之间跳转完成.</p>
</li>
<li><p><em>Bilder链式调用</em>：以Builder模式的API风格完成调用.</p>
</li>
</ul>
<h2 id="一-_Single-Chain单类链式调用">一. Single-Chain单类链式调用</h2><p><a href="https://github.com/jcmore2/BannerTime/blob/master/bannertime/src/main/java/com/jcmore2/bannertime/BannerTime.java" title="https://github.com/jcmore2/BannerTime/blob/master/bannertime/src/main/java/com/jcmore2/bannertime/BannerTime.java" target="_blank" rel="external">https://github.com/jcmore2/BannerTime/blob/master/bannertime/src/main/java/com/jcmore2/bannertime/BannerTime.java</a></p>
<pre><code>BannerTime.init<span class="params">(this)</span>
             .shownTime<span class="params">(<span class="number">4000</span>)</span>
             .hiddenTime<span class="params">(<span class="number">3000</span>)</span>
             .imageBanner<span class="params">(<span class="string">"http://pre03.deviantart.net/2aa0/th/pre/f/2012/321/d/1/african_landscape_by_dasflon-d5l9t7c.jpg"</span>)</span>
             .withKOButton<span class="params">()</span>
             .withKOButton<span class="params">()</span>
                        .show<span class="params">()</span>;
</code></pre><p>Single-Chain是指单个类中完成链式调用的构建,它的核心元素就在于:</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MainClass <span class="title">doString</span>(<span class="params">String <span class="keyword">value</span></span>) </span>{
    <span class="keyword">return</span> sInstance;
}
</code></pre><p>返回该类的对象实体.然后通过该对象实体不断的调用里面的方法.每个方法都返回的是对象的实体.</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SingleChain</span> {

    <span class="keyword">private</span> <span class="keyword">static</span> SingleChain sInstance;
    <span class="keyword">private</span> <span class="keyword">static</span> Context mContext;

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> shownTime ;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> hiddenTime ;
    <span class="keyword">private</span> <span class="keyword">static</span> String imageBanner ;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> okVisibility;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> koVisibility;

    <span class="function"><span class="keyword">private</span> <span class="title">SingleChain</span>(<span class="params">Context context</span>) </span>{
        <span class="keyword">try</span> {
            <span class="keyword">if</span> (context == <span class="keyword">null</span>) {
                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cant init, context must not be null"</span>);
            }
        } <span class="keyword">catch</span> (Exception e) {
            e.printStackTrace();
        }
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleChain <span class="title">with</span>(<span class="params">Context context</span>)</span>{
        <span class="keyword">if</span>(sInstance == <span class="keyword">null</span>){
            sInstance = <span class="keyword">new</span> SingleChain(context);
        }
        mContext=context;
        <span class="keyword">return</span> sInstance;
    }


    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleChain <span class="title">shownTime</span>(<span class="params"><span class="keyword">int</span> time</span>) </span>{
        shownTime=time;
        <span class="keyword">return</span> sInstance;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleChain <span class="title">hiddenTime</span>(<span class="params"><span class="keyword">int</span> time</span>) </span>{
        hiddenTime=time;
        <span class="keyword">return</span> sInstance;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleChain <span class="title">imageBanner</span>(<span class="params">String url</span>) </span>{
        imageBanner=url;
        <span class="keyword">return</span> sInstance;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleChain <span class="title">withOKButton</span>(<span class="params"></span>) </span>{
        okVisibility= View.VISIBLE;
        <span class="keyword">return</span> sInstance;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleChain <span class="title">withKOButton</span>(<span class="params"></span>) </span>{
        koVisibility = View.VISIBLE;
        <span class="keyword">return</span> sInstance;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span>(<span class="params"></span>) </span>{

        <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"It´ necessary call '.with()' method"</span>);


        createDialog();
    }

    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createDialog</span>(<span class="params"></span>) </span>{
        <span class="comment">//......</span>
        hanlder content；
        <span class="comment">//......</span>
    }

}
</code></pre><h2 id="二-_multi-Chain单类链式调用">二. multi-Chain单类链式调用</h2><p><a href="https://github.com/xiaomeixw/HappyKandy" title="https://github.com/xiaomeixw/HappyKandy" target="_blank" rel="external">https://github.com/xiaomeixw/HappyKandy</a></p>
<pre><code><span class="tag">HappyKandy</span>
        <span class="class">.load</span>(<span class="tag">bean</span><span class="class">.getImage</span>())
                <span class="class">.setAspectRatio</span>(1<span class="class">.68f</span>)
                        <span class="class">.setGifTrue</span>()
                            <span class="class">.into</span>(<span class="tag">draweeView</span>);
</code></pre><p>multi-Chain是指多个类中之间完成链式调用的构建,它的核心元素就在于:</p>
<pre><code><span class="keyword">Class</span> A  ---&gt;  <span class="keyword">Class</span> B ---&gt; <span class="keyword">Class</span> C
</code></pre><p>其中Class A 和 Class B 都只是封装,真正起代码处理作用的还是Class C:</p>
<p>FrescoManager:</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> FrescoManager {


    /**
     * Initialize Fresco <span class="keyword">in</span> Application
     */
    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> initFresco(Application application){
        Fresco.initialize(application);
    }


    /**
     * Fresco not support relative path,should Absolute path need URI's scheme like <span class="string">"http://"</span> <span class="keyword">or</span> <span class="string">"file://"</span>
     * @param url  (web_image)            http:<span class="comment">//</span>
     *             (local_image)            file:<span class="comment">//</span>
     *             (Content provider)   content:<span class="comment">//</span>
     *             (asset_image)   asset:<span class="comment">//</span>
     *             (res_iamge)     res:<span class="comment">//package/R.drawable.ic_launcher</span>
     * @<span class="keyword">return</span>
     */
    <span class="keyword">public</span> <span class="keyword">static</span> FrescoCreator load(String url){

        FrescoRetriever retriever = FrescoRetriever.get();
        <span class="keyword">return</span> retriever.get(url);
    }

}
</code></pre><p>FrescoRetriever:</p>
<pre><code>public class FrescoRetriever {

   <span class="keyword"> private</span><span class="keyword"> static</span><span class="keyword"> final</span> FrescoRetriever<span class="instruction"> instance </span>=<span class="instruction"> new </span>FrescoRetriever(<span class="function">)</span>;

   <span class="keyword"> private</span> volatile FrescoCreator frescoCreator;

   <span class="keyword"> public</span><span class="keyword"> static</span> FrescoRetriever<span class="function"> get(</span><span class="function">)</span> {
       <span class="instruction"> return </span>instance;
    }

   <span class="keyword"> public</span> FrescoCreator<span class="function"> get(</span>String url<span class="function">)</span> {
       <span class="instruction"> return </span>getFrescoUrl(url<span class="function">)</span>;
    }

   <span class="keyword"> private</span> FrescoCreator<span class="function"> getFrescoUrl(</span>String url<span class="function">)</span> {
       <span class="instruction"> return </span>new<span class="function"> FrescoCreator(</span>url<span class="function">)</span>;
    }

}
</code></pre><p>FrescoCreator：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> FrescoCreator {

    <span class="comment">/**
     * Http or File Url，must begin with http:// or file://
     */</span>
    <span class="keyword">private</span> String mUrl;
    <span class="comment">/**The image control*/</span>
    <span class="comment">//private SimpleDraweeView mImageView;</span>
    <span class="comment">/**
     * Aspect ratio
     */</span>
    <span class="keyword">private</span> <span class="keyword">float</span> mRatio = <span class="number">0.0f</span>;
    <span class="comment">/**
     * whether show gif
     */</span>
    <span class="keyword">private</span> boolean mGif = <span class="literal">false</span>;
    <span class="comment">/**
     * whether set JPEG Progressive shows
     */</span>
    <span class="keyword">private</span> boolean mProJpeg = <span class="literal">false</span>;
    <span class="comment">/**
     * whether set crop
     */</span>
    <span class="keyword">private</span> boolean mCenterCrop = <span class="literal">false</span>;
    <span class="comment">/**
     * whether  set  Aspect ratio
     */</span>
    <span class="keyword">private</span> boolean mRsize = <span class="literal">false</span>;


    <span class="keyword">private</span> <span class="keyword">int</span> mWidth;
    <span class="keyword">private</span> <span class="keyword">int</span> mHeight;

    FrescoCreator(String url) {
        <span class="keyword">this</span>.mUrl = url;
    }


    <span class="function"><span class="keyword">public</span> FrescoCreator <span class="title">setAspectRatio</span><span class="params">(<span class="keyword">float</span> ratio)</span> </span>{
        <span class="keyword">this</span>.mRatio = ratio;
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }

    <span class="function"><span class="keyword">public</span> FrescoCreator <span class="title">setGifTrue</span><span class="params">()</span> </span>{
        <span class="keyword">this</span>.mGif = <span class="literal">true</span>;
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }

    <span class="function"><span class="keyword">public</span> FrescoCreator <span class="title">setProgressiveJPEGTrue</span><span class="params">()</span> </span>{
        <span class="keyword">this</span>.mProJpeg = <span class="literal">true</span>;
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }

    <span class="function"><span class="keyword">public</span> FrescoCreator <span class="title">placeholder</span><span class="params">(<span class="keyword">int</span> drawable)</span> </span>{
        <span class="keyword">this</span>.mPlaceholder = drawable;
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }

    <span class="function"><span class="keyword">public</span> FrescoCreator <span class="title">fail</span><span class="params">(<span class="keyword">int</span> drawable)</span> </span>{
        <span class="keyword">this</span>.mFailImg = drawable;
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }


    <span class="function"><span class="keyword">public</span> FrescoCreator <span class="title">error</span><span class="params">(<span class="keyword">int</span> drawable)</span> </span>{
        <span class="keyword">this</span>.mErrorImg = drawable;
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }

    <span class="function"><span class="keyword">public</span> FrescoCreator <span class="title">centerCrop</span><span class="params">()</span> </span>{
        <span class="keyword">this</span>.mCenterCrop = <span class="literal">true</span>;
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }


    <span class="function"><span class="keyword">public</span> FrescoCreator <span class="title">resize</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>{
        <span class="keyword">this</span>.mRsize = <span class="literal">true</span>;
        <span class="keyword">this</span>.mWidth = width;
        <span class="keyword">this</span>.mHeight = height;
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }


    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">into</span><span class="params">(SimpleDraweeView imageView)</span> </span>{
        Uri uri = getCommonUri(imageView);
        <span class="keyword">if</span> (!mGif) {
            <span class="keyword">if</span> (mRsize) {

                ImageRequest request = ImageRequestBuilder.newBuilderWithSource(uri)
                        .setResizeOptions(<span class="keyword">new</span> ResizeOptions(mWidth, mHeight))
                        .build();
                DraweeController controller = Fresco.newDraweeControllerBuilder()
                        .setImageRequest(request)
                        .build();
                imageView.setController(controller);


            } <span class="keyword">else</span> {
                imageView.setImageURI(uri);
            }

        } <span class="keyword">else</span> {
            DraweeController controller = getGifController(imageView, uri);
            imageView.setController(controller);
        }

    }
}
</code></pre><h2 id="三-_Builder模式链式调用">三. Builder模式链式调用</h2><p>构造器和静态工厂的问题在于无法友善的拓展大量的可选参数.<br>对于参数，一般采用重叠构造器的方法处理，这种过多的参数面临代码难于编写和维护.</p>
<p>构造器多参</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> People {

    <span class="keyword">private</span> <span class="built_in">String</span> mName;<span class="comment">// required</span>
    <span class="keyword">private</span> <span class="built_in">String</span> mSex;<span class="comment">// required</span>

    <span class="keyword">private</span> <span class="built_in">String</span> mAddress;<span class="comment">// optional</span>
    <span class="keyword">private</span> <span class="built_in">String</span> mAge;<span class="comment">// optional</span>
    <span class="keyword">private</span> <span class="built_in">String</span> mProject;<span class="comment">// optional</span>
    <span class="keyword">private</span> <span class="built_in">String</span> mFat;<span class="comment">// optional</span>

    <span class="keyword">public</span> People(<span class="built_in">String</span> name, <span class="built_in">String</span> sex) {
        <span class="keyword">this</span>(name, sex, <span class="string">"USA"</span>);
    }

    <span class="keyword">public</span> People(<span class="built_in">String</span> name, <span class="built_in">String</span> sex, <span class="built_in">String</span> address) {
        <span class="keyword">this</span>(name, sex, address, <span class="string">"20"</span>);
    }

    <span class="keyword">public</span> People(<span class="built_in">String</span> name, <span class="built_in">String</span> sex, <span class="built_in">String</span> address, <span class="built_in">String</span> age) {
        <span class="keyword">this</span>(name, sex, address, age, <span class="string">"shopping,movie,travel"</span>);
    }

    <span class="keyword">public</span> People(<span class="built_in">String</span> name, <span class="built_in">String</span> sex, <span class="built_in">String</span> address, <span class="built_in">String</span> age, 
                    <span class="built_in">String</span> project) {
        <span class="keyword">this</span>(name, sex, address, age, project, <span class="string">"0"</span>);
    }

    <span class="keyword">public</span> People(<span class="built_in">String</span> name, <span class="built_in">String</span> sex, <span class="built_in">String</span> address, <span class="built_in">String</span> age, 
                    <span class="built_in">String</span> project, <span class="built_in">String</span> fat) {
        <span class="keyword">this</span>.mName = name;
        <span class="keyword">this</span>.mSex = sex;
        <span class="keyword">this</span>.mAddress = address;
        <span class="keyword">this</span>.mAge = age;
        <span class="keyword">this</span>.mProject = project;
        <span class="keyword">this</span>.mFat = fat;
    }

}   
</code></pre><p>调用：</p>
<pre><code>People people = <span class="keyword">new</span> People(<span class="string">"Tony"</span>, <span class="string">"man"</span>, <span class="string">" 13 Liverpool Road, 
</span>            Islington, London, London, N1 <span class="number">0</span>RW<span class="string">", "</span><span class="number">32</span><span class="string">", "</span><span class="keyword">read</span><span class="string">", "</span><span class="number">50</span>kg");
</code></pre><p>构造器和静态工厂的问题在于无法友善的拓展大量的可选参数.</p>
<p>所以Builder模式应运而生：</p>
<ul>
<li><em>1.它主要在于将参数分成两种类型，一种是必须的参数，一种是非必需参数;</em></li>
<li><em>2.必需型参数，要做null值判断，同事如果用户外部没有传入，那么就会builder中启用默认型参数;</em></li>
<li><em>3.非必需型可以有也可以无.</em></li>
</ul>
<h2 id="3-1_ExportBuilder">3.1 ExportBuilder</h2><p>不在class中封装Builder,new Builder的操作是在外部(引用API时)直接处理</p>
<h2 id="3-2_PcakageBuilder">3.2 PcakageBuilder</h2><p>直接在calss中封装builder,外部直接不在处理new Builder操作</p>
<p><a href="https://github.com/square/picasso/blob/master/picasso/src/main/java/com/squareup/picasso/Picasso.java" title="https://github.com/square/picasso/blob/master/picasso/src/main/java/com/squareup/picasso/Picasso.java" target="_blank" rel="external">https://github.com/square/picasso/blob/master/picasso/src/main/java/com/squareup/picasso/Picasso.java</a></p>
<pre><code>Picasso.<span class="function"><span class="title">with</span><span class="params">(context)</span></span>
  .<span class="function"><span class="title">load</span><span class="params">(url)</span></span>
  .<span class="function"><span class="title">resize</span><span class="params">(<span class="number">50</span>, <span class="number">50</span>)</span></span>
  .<span class="function"><span class="title">centerCrop</span><span class="params">()</span></span>
  .<span class="function"><span class="title">into</span><span class="params">(imageView)</span></span>
</code></pre><blockquote>
<p>Picasso.with—&gt;new Builder(context)中进行必要参数的非空判断—&gt;.build()进行非必要参数的null赋值—&gt;new Picasso()—&gt;load(url)—&gt;new RequestCreator();</p>
</blockquote>
<p><img src="http://i.imgur.com/WiG5Hdh.png" alt=""></p>
<p>Picasso.class:</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Picasso</span> </span>{

    <span class="keyword">static</span> <span class="keyword">volatile</span> Picasso singleton = <span class="keyword">null</span>;

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Picasso <span class="title">with</span><span class="params">(Context context)</span> </span>{
        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) {
          <span class="keyword">synchronized</span> (Picasso.class) {
            <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) {
              singleton = <span class="keyword">new</span> Builder(context).build();              
            }
          }
        }
        <span class="keyword">return</span> singleton;
      }

     <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>{
        <span class="keyword">private</span> <span class="keyword">final</span> Context context;<span class="comment">// required 必须型参数</span>

        <span class="keyword">private</span> Downloader downloader;<span class="comment">// optional 非必须型参数</span>
        <span class="keyword">private</span> ExecutorService service;<span class="comment">// optional 非必须型参数</span>

        ......

        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(Context context)</span> </span>{
          <span class="comment">//对必须型参数进行null值报错</span>
          <span class="keyword">if</span> (context == <span class="keyword">null</span>) {
            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Context must not be null."</span>);
          }

          <span class="keyword">this</span>.context = context.getApplicationContext();
        }

        <span class="function"><span class="keyword">public</span> Builder <span class="title">downloader</span><span class="params">(Downloader downloader)</span> </span>{
          <span class="keyword">if</span> (downloader == <span class="keyword">null</span>) {
            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Downloader must not be null."</span>);
          }
          <span class="keyword">if</span> (<span class="keyword">this</span>.downloader != <span class="keyword">null</span>) {
            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Downloader already set."</span>);
          }
          <span class="keyword">this</span>.downloader = downloader;
          <span class="keyword">return</span> <span class="keyword">this</span>;
        }

        .......

        <span class="function"><span class="keyword">public</span> Picasso <span class="title">build</span><span class="params">()</span> </span>{
          Context context = <span class="keyword">this</span>.context;

          <span class="comment">//对于非必须性参数进行null赋值</span>
          <span class="keyword">if</span> (downloader == <span class="keyword">null</span>) {
            downloader = Utils.createDefaultDownloader(context);
          }

          <span class="keyword">if</span> (service == <span class="keyword">null</span>) {
            service = <span class="keyword">new</span> PicassoExecutorService();
          }

          .....

          <span class="keyword">return</span> <span class="keyword">new</span> Picasso(context, dispatcher, cache, listener, transformer, requestHandlers, stats,
              defaultBitmapConfig, indicatorsEnabled, loggingEnabled);
        }
      }

    <span class="function"><span class="keyword">public</span> RequestCreator <span class="title">load</span><span class="params">(String path)</span> </span>{
        <span class="keyword">if</span> (path == <span class="keyword">null</span>) {
          <span class="keyword">return</span> <span class="keyword">new</span> RequestCreator(<span class="keyword">this</span>, <span class="keyword">null</span>, <span class="number">0</span>);
        }
        <span class="keyword">if</span> (path.trim().length() == <span class="number">0</span>) {
          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Path must not be empty."</span>);
        }
        <span class="keyword">return</span> load(Uri.parse(path));
      }

}  
</code></pre></span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/10/23/LB_D/" itemprop="url">
                【杂谈10月】Library-Everyday-Gitbook上线
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-10-23T23:45:48+08:00" content="2015-10-23">
            2015-10-23
          </time>
        </span>

        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <p>&emsp;&emsp;其实准确的说应该是今天凌晨1点钟完成上线，今天又用了一天时间完善了昨天(10/22)、今天(10/23)和明天(10/24)三天的library.</p>
<h2 id="1-为什么要做这个gitbook">1.为什么要做这个gitbook</h2><p>&emsp;&emsp;其实之前一直都想把自己每天学习和浏览的印记记录下来，一方面是有时经常fork 优秀的library,隔一段时间就忘记了。二是想做一个不同于其他网站或者博客的library库。</p>
<p>&emsp;&emsp;国内有很多优秀的开源和共享主义者都会经常分享一些优秀的library，但他们的library一般都只分享给中国开发者。我想尝试的是站在中国开发者的角度为老外们来点咱中国人的干货。</p>
<h2 id="2-这个gitbook主要是给中国开发者看的吗，为什么有中文的释义">2.这个gitbook主要是给中国开发者看的吗，为什么有中文的释义</h2><p>&emsp;&emsp;说实话，不是，主要是给老外看的。<br>&emsp;&emsp;中文释义一方面是方便我自己最快速的查看库的内容【苦笑】(谁让我中文这么好)。另一方面是给“英文不比我好”的中国Android开发同仁看的。</p>
<h2 id="3-听说你更新一个AndroidEveryday要花2个小时，不就几个libraries一列举吗,搞怎么麻烦">3.听说你更新一个AndroidEveryday要花2个小时，不就几个libraries一列举吗,搞怎么麻烦</h2><p>&emsp;&emsp;这个要重点解释下，因为为了照顾国外开发者，同时国外很多优秀的文章的图片在国内访问也很慢。鉴于技术网络环境问题。所以我采取的是，将所有的图片都下载或者右键另存为本地资源后，做裁剪和压缩后上传到github或者markdown。有时一排要放两个图片，为了美观我需要将高度都定为同一个值(比如500px)，此时就要用ps或者美图秀秀这样的工具操作咯。其实1个小时不到写完本日的AndroidEveryday，但是要花30多分钟处理图片。同时还要将完成的AndroidEveryday系列Push到3个地方更新：</p>
<pre><code>1<span class="class">.gitHub</span>的<span class="tag">README</span><span class="class">.md</span>
2<span class="class">.gitbook</span>的内页<span class="class">.md</span>
3.个人博客
</code></pre><p>&emsp;&emsp;很多博客的英文原文网站如果不翻墙根本打不开，虽然有VPN，但是速度也不是很快。gitbook的速度即使在VPN下也慢如蜗牛。这种痛苦，作为搞技术的你也是应该懂的。</p>
<p>&emsp;&emsp;同时每周日都需有精心准备的专题策划(先透露下10月25日本周日的第一次“周日策划专题”是我们的Jake Wharton大神周刊，期待哦)。</p>
<pre><code>搜索优秀Library + 排版 + 关键信息整理 + 图片处理 + 更新 = <span class="number">2</span>小时！
</code></pre><p>&emsp;&emsp;所以木办法，精益求精，要做就做好，绝不敷衍！</p>
<h2 id="4-真的是天天更新吗，来源哪里">4.真的是天天更新吗，来源哪里</h2><p>&emsp;&emsp;对，没错，必须的。一方面是提醒自己要有责任心，说出来的话就要做到。另一方面是，一个人在一个领域耕耘7年，就能成为这个领域的专家，坚持不懈的学习很重要。这不仅是份能够养活自己的工作，而且是自己追求开源精神的重要过程。</p>
<p>&emsp;&emsp;来源：(暂时来源，不排除以后收集推荐的)</p>
<pre><code><span class="number">1.</span>自己每天浏览相关技术网站后收集；
<span class="number">2.</span>自己摆弄github search;
<span class="number">3.</span>项目中遇到问题后查询相关信息偶然发现;
</code></pre><h2 id="5-有些英文有些生硬，怕老外看的懂吗">5.有些英文有些生硬，怕老外看的懂吗</h2><p>&emsp;&emsp;说实话是有点担心，不过，英文就这水平，看的”小”懂，发音烂，口齿不清。呵呵，所以笨鸟必须天天飞。</p>
<h2 id="6-同事说：作为搞技术的，你其实文笔不错，说让你出书,你怎么看">6.同事说：作为搞技术的，你其实文笔不错，说让你出书,你怎么看</h2><p>&emsp;&emsp;呵呵，中国国内的一坨烂书，这里抄抄、那里抄抄，只会圈钱，误人子弟。我能力不够，不会出书。做人要对得起自己的良心，自己水平不够，绝不误人子弟，赚黑心钱。</p>
<h2 id="7-未来博客和Gitbook的发展和更新">7.未来博客和Gitbook的发展和更新</h2><p>&emsp;&emsp;首先每天都要更新AndroidEveryday系列.同时还有好几篇博文都欠债下来了。现在公司APP也在开发，比较忙，所以有时请谅解。其次本年一定完成所有的范式编程系列文章。久等了啊！</p>
<p>&emsp;&emsp;最后再次表达下本人的理念：</p>
<pre><code>取之于开源，必最终回归于开源，此谓之：大道！
</code></pre><p>&emsp;&emsp;下面是这三天的AndroidEveryday，算是Demo小样，博客中也雅俗共赏下咯，看看和github的排版有什么不同。</p>
          <div class="post-more-link text-center">
            <a class="btn" href="/2015/10/23/LB_D/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/10/23/ZT11_1/" itemprop="url">
                【正谈10月】Explore NoSql on Android
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-10-23T23:45:48+08:00" content="2015-10-23">
            2015-10-23
          </time>
        </span>

        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <h2 id="一-前言">一.前言</h2><p>D.Richard Hipp不曾想到在这一年他萌芽的轻量级数据库居然诞生在一条漂泊在大海的军舰上，这个诞生于2000年8月的Sqlite数据库由13万行C代码构成,轻量简洁稳定的优势特点,使它经过多年的发展成为Google&amp;Apple在移动端上探索数据库的核心主力，广泛而且大量的被使用。9年后,也就是2009年，NoSql形态数据库被逐渐推上历史的舞蹈核心，Mongodb在服务端架构数据库中大行其道，许多中小型数据库均开始由MySql转向更友好形态的Mongodb.而此时距离iphone1代发布已经过去了整整2年。<br>尽管如此，但在移动端领域NoSql形态数据库仍然还是处于萌芽起步阶段，在写这篇博客时我不经问自己:在Android上探索NoSql型数据库是否为时尚早?也许我们仍然需要时间来检验这个问题和它可能存在的标准答案！</p>
<h2 id="二-何为Nosql">二.何为Nosql</h2><p>泛指非关系型的数据库，关系数据库关注在关系上，NoSQL关注在存储上。<br>NoSQL数据库种类繁多，但是一个共同的特点都是去掉了关系数据库的关系型特性。数据之间无关系，容易扩展。<br>当前主流四种主要形态的NoSql型数据库：</p>
<ul>
<li><em>键值（key-value）比如：Oracle BDB</em></li>
<li><em>列存储数据库 比如：HBase</em></li>
<li><em>文档型数据库 比如：MongoDb</em></li>
<li><em>图形(Graph)数据库 比如：Infinite Graph</em></li>
</ul>
<p>主流的Nosql型数据库在Android端的探索主要是以key-value键值对的形式存在。这一类数据库主要会使用到一个哈希表，这个表中有一个特定的键和一个指针指向特定的数据。Key/value模型对于IT系统来说的优势在于简单、易部署。但是如果DBA只对部分值进行查询或更新的时候，Key/value就显得效率低下了。</p>
<p>使用场景：</p>
<ul>
<li><em>1.取代SP存储；</em></li>
<li><em>2.用于缓存场景.</em></li>
</ul>
          <div class="post-more-link text-center">
            <a class="btn" href="/2015/10/23/ZT11_1/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">&raquo;</a>
  </nav>


            </div>

            

            
        </div>

        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/avatar.jpg" alt="熊伟xiongwei" itemprop="image"/>
          <p class="site-author-name" itemprop="name">熊伟xiongwei</p>
        </div>
        <p class="site-description motion-element" itemprop="description">重新发现、定义并创造这个世界...</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">26</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/xiaomeixw" target="_blank">github</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.sabria.net/" target="_blank">anotherblog</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/1561605537" target="_blank">weibo</a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
        <div class="footer-inner">
            <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">熊伟xiongwei</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



        </div>
    </footer>

    <div class="back-to-top"></div>
</div>

<script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
  
  

  



  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.4"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.4"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.4" id="motion.global"></script>



  <script type="text/javascript" src="/js/search-toggle.js"></script>



<script type="text/javascript">
    $(document).ready(function () {
        if (CONFIG.sidebar === 'always') {
            displaySidebar();
        }
    });
</script>




  
  

  







<!-- lazyload -->
<script type="text/javascript" src="/js/lazyload.js"></script>
<script type="text/javascript">
    jQuery(function () {
        jQuery("#posts img").lazyload({
            placeholder: "/images/loading.gif",
            effect: "fadeIn"
        });
    });
</script>
</body>
</html>
