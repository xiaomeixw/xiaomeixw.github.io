<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
    

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.4"/>


    <meta name="description" content="重新发现、定义并创造这个世界..." />



  <meta name="keywords" content="Hexo,next" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.4" />


<meta name="description" content="#MK使用

粗体 (Ctrl+B) and 斜体 (Ctrl+I) 
引用 (Ctrl+Q) 
代码块 (Ctrl+K) 
标题 1, 2, 3 (Ctrl+1, Ctrl+2, Ctrl+3) 
列表 (Ctrl+U and Ctrl+Shift+O)">
<meta property="og:type" content="article">
<meta property="og:title" content="2015study">
<meta property="og:url" content="http://yoursite.com/2015/07/16/2015study/index.html">
<meta property="og:site_name" content="sabria">
<meta property="og:description" content="#MK使用

粗体 (Ctrl+B) and 斜体 (Ctrl+I) 
引用 (Ctrl+Q) 
代码块 (Ctrl+K) 
标题 1, 2, 3 (Ctrl+1, Ctrl+2, Ctrl+3) 
列表 (Ctrl+U and Ctrl+Shift+O)">
<meta property="og:image" content="http://i.imgur.com/yy6OMwg.png">
<meta property="og:image" content="http://i.imgur.com/xgpfJBa.png">
<meta property="og:image" content="http://i.imgur.com/ohbJo3b.png">
<meta property="og:image" content="http://i.imgur.com/F2CyMYw.png">
<meta property="og:image" content="http://i.imgur.com/zPVPbFs.png">
<meta property="og:image" content="http://i.imgur.com/XpNLTDE.png">
<meta property="og:image" content="http://i.imgur.com/r5B7mJp.png">
<meta property="og:image" content="http://i.imgur.com/p0HgKM3.png">
<meta property="og:image" content="http://i.imgur.com/hCLWHBN.png">
<meta property="og:updated_time" content="2015-07-30T05:33:40.599Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="2015study">
<meta name="twitter:description" content="#MK使用

粗体 (Ctrl+B) and 斜体 (Ctrl+I) 
引用 (Ctrl+Q) 
代码块 (Ctrl+K) 
标题 1, 2, 3 (Ctrl+1, Ctrl+2, Ctrl+3) 
列表 (Ctrl+U and Ctrl+Shift+O)">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'post'
  };
</script>

    <title> 2015study // sabria </title>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->




<div class="container one-column page-post-detail">
    <div class="headband"></div>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">sabria</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-tags"></i> <br />
            标签
          </a>
        </li>
      
    </ul>
  

  
</nav>


        </div>
    </header>

    <main id="main" class="main">
        <div class="main-inner">
            <div id="content" class="content">
                

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              2015study
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-07-16T00:50:17+08:00" content="2015-07-16">
            2015-07-16
          </time>
        </span>

        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        <span itemprop="articleBody"><p>#MK使用</p>
<ul>
<li><strong>粗体</strong> (<code>Ctrl+B</code>) and <em>斜体</em> (<code>Ctrl+I</code>) </li>
<li>引用 (<code>Ctrl+Q</code>) </li>
<li>代码块 (<code>Ctrl+K</code>) </li>
<li>标题 1, 2, 3 (<code>Ctrl+1</code>, <code>Ctrl+2</code>, <code>Ctrl+3</code>) </li>
<li>列表 (<code>Ctrl+U</code> and <code>Ctrl+Shift+O</code>) </li>
</ul>
<a id="more"></a>
<p>#1.基础性理解</p>
<p>###1.1 pagerAdapter遗漏点</p>
<pre><code>    <span class="number">1.1</span><span class="number">.1</span> pagerAdapter 传入的是对View的数据适配，FragmentPagerAdapter是对Fragment的数据适配；
    <span class="number">1.1</span><span class="number">.2</span> PagerAdapter方法：
    isViewFromObject:是否缓存
        <span class="keyword">return</span> <span class="literal">true</span>:表示为缓存View
        <span class="keyword">return</span> <span class="literal">false</span>:表示为不缓存View
例子：
        @<span class="function">Override
    <span class="keyword">public</span> boolean <span class="title">isViewFromObject</span><span class="params">(View arg0, Object arg1)</span> </span>{
            <span class="keyword">return</span> arg0 == arg1;
    }
----------------------------------------------------------    

    instantiateItem:初始化View
@<span class="function">Override
    <span class="keyword">public</span> Object <span class="title">instantiateItem</span><span class="params">(ViewGroup container, <span class="keyword">int</span> position)</span> </span>{
        ImageView iv = imageViewList.get(position);
        <span class="comment">// 1. 向ViewPager中添加一个view对象</span>
        container.addView(iv);

        <span class="comment">// 2. 返回当前添加的view对象</span>
        <span class="keyword">return</span> iv;
    }
----------------------------------------------------------
    destroyItem:销毁View
@<span class="function">Override
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyItem</span><span class="params">(ViewGroup container, <span class="keyword">int</span> position, Object object)</span> </span>{
        <span class="comment">//通过position或者obj都可以找到，注意这里一定不能用super,因为super里面就是在抛异常</span>
        container.removeView((View) object);
        <span class="comment">//container.removeView(imageViewList.get(position));</span>
    }
</code></pre><p>###1.2 视图树的观察者<br><strong>ViewTreeObserver</strong>：用来帮助监听某些View的某些变化；</p>
<p>当一个视图树的布局发生改变时，可以被ViewTreeObserver监听到， 这是一个注册监听视图树的观察者(observer)，在视图树的全局事件改变时得到通知。ViewTreeObserver不能直接实例化，而是通过getViewTreeObserver()获得。</p>
<p>我们在onCreate方法中取获取一个控件，比如ImageView的宽高view.getHeight()，但返回的是0，是因为onCreate方法执行完后,控件才被度量measure。<br>使用视图观察者就可以解决该问题：</p>
<pre><code>imageView.getViewTreeObserver<span class="params">()</span>.addOnGlobalLayoutListener<span class="params">(new     OnGlobalLayoutListener<span class="params">()</span> { 
        @Override   
    public void onGlobalLayout<span class="params">()</span> { 
                imageView.getViewTreeObserver<span class="params">()</span>.removeGlobalOnLayoutListener<span class="params">(this)</span>;   
           图片的高=imageView.getHeight<span class="params">()</span>；
        图片的宽=imageView.getWidth<span class="params">()</span>)</span>; 
    }   
});   
</code></pre><p>主要的几个监听：</p>
<p>1.用于监听 Touch 和非 Touch 模式的转换</p>
<pre><code><span class="tag">ViewTreeObserver</span><span class="class">.OnTouchModeChangeListener</span>
</code></pre><p>2.用于监听布局之类的变化，比如某个空间消失了</p>
<pre><code><span class="tag">ViewTreeObserver</span><span class="class">.OnGlobalLayoutListener</span>
</code></pre><p>3.用于在屏幕上画 View 之前，要做什么额外的工作</p>
<pre><code>ViewTreeObserver<span class="class">.OnPreDrawListener</span>  
</code></pre><p>4.用于监听焦点的变化</p>
<pre><code>ViewTreeObserver<span class="class">.OnGlobalFocusChangeListener</span> 
</code></pre><ul>
<li>原理：<br>  view绘制流程: measure -&gt; layout -&gt; draw<br>  监听mSelectPointView控件的layout过程</li>
<li>操作过程：<br>  1.获取观察者,监听全局layout绘制；<br>  2.实现onGlobalLayout，该方法会不断的执行多次；<br>  3.获取一个视图就删除掉；<br>  4.进行layout中需求的操作；</li>
</ul>
<pre><code><span class="comment">// 获得视图树的观察者, 监听全部布局的回调</span>

mSelectPointView.getViewTreeObserver<span class="params">()</span>.addOnGlobalLayoutListener<span class="params">(new OnGlobalLayoutListener<span class="params">()</span> {
    @Override
    public void onGlobalLayout<span class="params">()</span> {
        // 该方法会执行多次，为了性能：只执行一次, 把当前的事件从视图树的观察者中移除掉：
        //获取它的视图就删除掉
        mSelectPointView.getViewTreeObserver<span class="params">()</span>.removeGlobalOnLayoutListener<span class="params">(this)</span>;

        // 取出两个点之间的宽度
        basicWidth = llPointGroup.getChildAt<span class="params">(<span class="number">1</span>)</span>.getLeft<span class="params">()</span> - llPointGroup.getChildAt<span class="params">(<span class="number">0</span>)</span>.getLeft<span class="params">()</span>;
        // System.out.println<span class="params">(<span class="string">"点之间的宽度: "</span> + basicWidth)</span>;
    }
})</span>;
</code></pre><p>###1.3Viewpage的滑动监听<br>        mViewPager.setOnPageChangeListener(this);</p>
<ul>
<li><p>回调监听1：onPageScrolled  当页面正在滚动时<br>public void onPageScrolled(int position, float positionOffset,</p>
<pre><code><span class="keyword">int</span> positionOffsetPixels)
</code></pre><p>三个参数含义：position 当前选中的是哪个页面</p>
<pre><code>positionOffset  移动的比例    从<span class="number">0</span>-<span class="number">0.999999</span>  代表一个页面比如<span class="number">0</span>移动的比例
positionOffsetPixels 偏移像素
</code></pre><p>   @Override<br>   public void onPageScrolled(int position, float positionOffset,</p>
<pre><code><span class="keyword">int</span> positionOffsetPixels) {

<span class="comment">// 20 * (1 + 0.99) = 38</span>
<span class="keyword">int</span> leftMargin = (<span class="keyword">int</span>) (basicWidth * (position + positionOffset));

<span class="comment">//给红点设置位置</span>
RelativeLayout.LayoutParams <span class="keyword">params</span> =(android.widget.RelativeLayout.LayoutParams) mSelectPointView.getLayoutParams();
<span class="comment">//让点也不断的随着移动而移动，也就是不断的改变自己的leftMargin</span>
<span class="keyword">params</span>.leftMargin = leftMargin;
mSelectPointView.setLayoutParams(<span class="keyword">params</span>);
</code></pre><p>   }</p>
</li>
</ul>
<ul>
<li><p>回调监听2：onPageScrollStateChanged 当页面滚动状态改变</p>
</li>
<li><p>回调监听3：onPageSelected 当页面被选中</p>
<p>   @Override<br>   public void onPageSelected(int position) {</p>
<pre><code><span class="keyword">if</span><span class="params">(position == imageViewList.size<span class="params">()</span> - <span class="number">1</span>)</span> {
    btnStartExperience.setVisibility<span class="params">(View.VISIBLE)</span>;
} <span class="keyword">else</span> {
    btnStartExperience.setVisibility<span class="params">(View.GONE)</span>;
}
</code></pre><p>   }</p>
</li>
</ul>
<p>###1.4 SlidingMenu的使用</p>
<ul>
<li><p>使用步骤.</p>
<ol>
<li><p>修改activity的父类为: SlidingFragmentActivity</p>
</li>
<li><p>修改onCreate方法的修饰词, 修改为public</p>
</li>
<li><p>配置SlidingMenu的布局.</p>
<ul>
<li>左侧菜单布局</li>
<li>右侧菜单布局</li>
<li>主界面布局</li>
</ul>
</li>
<li><p>对slidingmenu进行参数配置.</p>
<ul>
<li>设置模式: 左右菜单都可以滑出来.</li>
<li>设置触摸模式: 整个屏幕都可以滑动.</li>
<li>设置主界面可以留在屏幕上的宽度.</li>
</ul>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>例子:</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">SlidingFragmentActivity</span> {</span>

    <span class="annotation">@Override</span>
    public void onCreate(<span class="type">Bundle</span> savedInstanceState) {
        <span class="keyword">super</span>.onCreate(savedInstanceState);

        <span class="comment">// 设置主界面布局</span>
        setContentView(<span class="type">R</span>.layout.activity_main);

        <span class="comment">// 设置左侧菜单布局</span>
        setBehindContentView(<span class="type">R</span>.layout.left_menu);

        <span class="comment">// 设置右侧菜单布局</span>
        <span class="type">SlidingMenu</span> slidingMenu = getSlidingMenu(); <span class="comment">// 获取菜单配置和控制对象</span>
        slidingMenu.setSecondaryMenu(<span class="type">R</span>.layout.right_menu); <span class="comment">// 右侧菜单.</span>

        <span class="comment">// 设置左右菜单都可用.</span>
        slidingMenu.setMode(<span class="type">SlidingMenu</span>.<span class="type">LEFT_RIGHT</span>);

        <span class="comment">// 设置整个屏幕都可以滑动出来菜单</span>
        slidingMenu.setTouchModeAbove(<span class="type">SlidingMenu</span>.<span class="type">TOUCHMODE_FULLSCREEN</span>);

        <span class="comment">// 设置主界面可以留在屏幕上的宽度</span>
        slidingMenu.setBehindOffset(<span class="number">200</span>);

    }
}
</code></pre></li>
</ul>
<p>###1.5 Fragment事务管理</p>
<ul>
<li>使用步骤.<ol>
<li>获取Fragment管理器对象<br> <code>FragmentManager fm = getSupportFragmentManager();</code></li>
<li>开启事物<br> <code>FragmentTransaction ft = fm.beginTransaction(); // 得到事物操作对象</code></li>
<li>替换布局<br> <code>ft.replace(R.id.fl_left_menu, new LeftMenuFragment(), LEFT_MENU_FRAGMENT_TAG);//左边布局</code><br><code>ft.replace(R.id.fl_main_content, new MainContentFragment(), MAIN_CONTENT_FRAGMENT_TAG);//右边布局</code></li>
</ol>
</li>
</ul>
<pre><code><span class="bullet">4. </span>提交
  <span class="code">`ft.commit();`</span>
</code></pre><p>###1.6 判断滑行到顶或者滑行到底</p>
<ul>
<li>判断ScrollView是否滑行到顶或者滑行到底</li>
</ul>
<p>方法一：自定义MyScrollView</p>
<pre><code><span class="annotation">@Override</span>
<span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onScrollChanged</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> oldl, <span class="keyword">int</span> oldt)</span> </span>{
    <span class="keyword">if</span> (t + getHeight() &gt;= computeVerticalScrollRange()) {
        <span class="comment">// ScrollView滑动到底部了</span>
    }

    <span class="keyword">if</span>(getScrollY() == <span class="number">0</span>){
        System.out.println(<span class="string">"滑动到顶部了....."</span>);
    }

}
</code></pre><p>方法二：监听onTouchListener</p>
<pre><code>mScrollView.setOnTouchListener(<span class="keyword">new</span> TouchListenerImpl());

<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TouchListenerImpl</span> <span class="keyword">implements</span> <span class="title">OnTouchListener</span></span>{
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View view, MotionEvent motionEvent)</span> </span>{
        <span class="keyword">switch</span> (motionEvent.getAction()) {
        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:

            <span class="keyword">break</span>;
        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:
             <span class="keyword">int</span> scrollY=view.getScrollY();
             <span class="keyword">int</span> height=view.getHeight();
             <span class="keyword">int</span> scrollViewMeasuredHeight=mScrollView.getChildAt(<span class="number">0</span>).getMeasuredHeight();
             <span class="keyword">if</span>(scrollY==<span class="number">0</span>){
                    System.out.println(<span class="string">"滑动到了顶端 view.getScrollY()="</span>+scrollY);
                }
             <span class="keyword">if</span>((scrollY+height)==scrollViewMeasuredHeight){
                    System.out.println(<span class="string">"滑动到了底部 scrollY="</span>+scrollY);
                }
            <span class="keyword">break</span>;

        <span class="keyword">default</span>:
            <span class="keyword">break</span>;
        }
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }

};
</code></pre><p>方法二注意事项:</p>
<ul>
<li><p>1 mScrollView.getChildAt(0).getMeasuredHeight()表示:</p>
<pre><code>ScrollView所占的高度.即ScrollView内容的高度.常常有一部分内容要滑动后才可见,这部分的高度也包含在了mScrollView.<span class="function"><span class="title">getChildAt</span><span class="params">(<span class="number">0</span>)</span></span>.<span class="function"><span class="title">getMeasuredHeight</span><span class="params">()</span></span>中
</code></pre></li>
<li><p>2 view.getScrollY表示:</p>
<pre><code>ScrollView顶端已经滑出去的高度
</code></pre></li>
<li><p>3 view.getHeight()表示:</p>
<pre><code>ScrollView的可见高度
</code></pre></li>
</ul>
<ul>
<li>判断ListView是否滑行到顶或者滑行到底<br>firstVisibleItem==0：顶部<br>visibleItemCount+firstVisibleItem==totalItemCount ：底部</li>
</ul>
<ul>
<li><p>判断ListView的第一个item是否完全显示:<br>(如果ListView加了padding属性的话，判断是否完全显示的时候就不能根据&gt;=0判断，而是应该加上paddingTop的高度)</p>
<pre><code><span class="keyword">if</span> <span class="params">(mListView.getChildCount<span class="params">()</span> &gt; <span class="number">0</span> &amp;&amp; mListView.getFirstVisiblePosition<span class="params">()</span> == <span class="number">0</span> &amp;&amp; mListView.getChildAt<span class="params">(<span class="number">0</span>)</span>.getTop<span class="params">()</span> &gt;= mListView.getPaddingTop<span class="params">()</span>)</span> {
    return <span class="literal">true</span>;
}
</code></pre></li>
<li><p>ListView当滑到顶部时把事件处理返回给父类(自定义ListView来处理)</p>
<p> @Override<br> public boolean dispatchTouchEvent(MotionEvent ev) {</p>
<pre><code><span class="comment">// 让父类不要拦截滑动，让我来处理滑动</span>
getParent().requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);
<span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">dispatchTouchEvent</span><span class="params">(ev)</span></span>;
</code></pre><p> }</p>
<p> @Override<br> public boolean onTouchEvent(MotionEvent ev) {</p>
<pre><code><span class="keyword">switch</span> (ev.getAction()) {
<span class="keyword">case</span> MotionEvent.ACTION_DOWN:
    downY = (<span class="keyword">int</span>) ev.getY();
    <span class="keyword">break</span>;
<span class="keyword">case</span> MotionEvent.ACTION_MOVE:
    <span class="keyword">int</span> moveY = (<span class="keyword">int</span>) ev.getY();
    <span class="keyword">int</span> diffY = moveY - downY;
    <span class="comment">//首先必须是上下滑动:diffY &gt; 0，其次必须是第一个item:getFirstVisiblePosition，最后第一个item的高度必须是完整展示的getChildAt(0).getTop() &gt;= 0</span>
    <span class="keyword">if</span>(getChildCount()&gt;<span class="number">0</span>){
        View first = getChildAt(<span class="number">0</span>);
        <span class="keyword">int</span> top = first.getTop();
        <span class="keyword">if</span> (diffY &gt; <span class="number">0</span> &amp;&amp; getFirstVisiblePosition() == <span class="number">0</span>&amp;&amp;top&gt;=getPaddingTop()) {
            getParent().requestDisallowInterceptTouchEvent(<span class="keyword">false</span>);
        }
    }
    <span class="keyword">break</span>;

<span class="keyword">default</span>:
    <span class="keyword">break</span>;
}
<span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">onTouchEvent</span><span class="params">(ev)</span></span>;
</code></pre><p> }</p>
</li>
</ul>
<p>###1.8 ListView的一些方法</p>
<ul>
<li><p>ListView.getChildCount()：</p>
<blockquote>
<p>返回的是这个listView当前显示出来的item数量，也就是在屏幕上可以看到的数量。</p>
</blockquote>
</li>
<li><p>ListView.getChildAt(int pos)</p>
<blockquote>
<p>返回的是这个listView当前显示出来的item中的第pos项，也就是说索引是从显示出来的第一项开始计算的，如果屏幕上方有n个item看不见，那么这个函数的返回值就是n</p>
</blockquote>
</li>
<li><p>ListView.getFirstVisiblePosition()</p>
<blockquote>
<p>返回值是当前可以看到的第一个item，在所有item中（包括看不到的）的位置。</p>
</blockquote>
</li>
<li><p>View.getTop()</p>
<blockquote>
<p>返回值是这个View相对于它的父控件的top值，对于item而言，如果item只有一半显示出来（下半部分），那么返回值应该是 - 这个item的高度</p>
</blockquote>
</li>
</ul>
<p>###1.7动态设置view的padding和margin值</p>
<ul>
<li><p>1.动态设置padding，拿ImageView为例：**</p>
<pre><code><span class="type">ImageView</span> imageView = <span class="keyword">new</span> <span class="type">ImageView</span>(<span class="type">Context</span> context);  
imageView.setPadding(<span class="keyword">left</span>,top,<span class="keyword">right</span>,bottom);  
</code></pre></li>
<li><p>2.动态设置margin拿LinearLayout里边放ImageVIew例</p>
<pre><code>LinearLayout.LayoutParams params = <span class="keyword">new</span> LinearLayout.LayoutParams(<span class="number">20</span>, <span class="number">20</span>);  
params.setMargins(<span class="number">20</span>, <span class="number">0</span>, <span class="number">20</span>, <span class="number">0</span>);  
imageView.setLayoutParams(params);  
</code></pre></li>
</ul>
<p>###1.9</p>
<p>创建Handler对象必须先初始化一个Looper , 否则会出现如下错误：<br>java.lang.RuntimeException: Can’t create handler inside thread that has not called Looper.prepare()</p>
<p>Activity在被创建的时候，框架会帮我们初始化一个Looper对象，因此在主线程中，我们不必去调用Looper.prepare()去初始化Looper对象。</p>
<p>在子线程里面显示一个Toast,Toast的show操作,需要通过windowmanager的 handler来处理,因此需要手动初始化Looper对象:</p>
<p>Looper.prepare();<br>Toast.makeText(getApplicationContext(), “备份完成”, 1).show();<br>Looper.loop();</p>
<p>#2 View的绘制机制</p>
<p>###2.1 View的绘制的3个流程</p>
<ul>
<li>measure：计算视图大小</li>
<li>layout ：视图摆放位置</li>
<li>draw ： 重绘视图<blockquote>
<p>View的绘制过程从ViewRootImpl.performTraversals()方法开始,该方法中会顺序执行“是否需要计算视图measure”—-》“是否需要摆放视图layout”—-》“是否需要重绘视图draw”；</p>
</blockquote>
</li>
</ul>
<p>源码中performTraversals() 方法依次执行三件事：</p>
<ul>
<li>performMeasure() , 内部是 mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); 测量 View 大小。（mView是 Window 最顶成的 View(DecorView) ,它是 FrameLayout 的子类）</li>
<li>performLayout() , 内部是 mView.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); 视图布局，确定 View 位置。</li>
<li>performDraw() , 内部是 draw(fullRedrawNeeded);  绘制界面。</li>
</ul>
<p>###2.2 Measure计算大小(宽高)</p>
<ul>
<li><p>performMeasure 方法里面会调用</p>
<pre><code><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>{
    mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);
}
</code></pre></li>
<li><p>该方法会走到measure方法中，而measure方法中会调用 </p>
<pre><code><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span></span>{
         onMeasure(widthMeasureSpec, heightMeasureSpec);
}
</code></pre></li>
<li><p>在这里所指的View都是指DecorView(视图树根View)，而 DecorView 是 FrameLayout 的子类。<br>所以这里的onMeasure会走 FrameLayout.onMeasure：</p>
<pre><code><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>{
    measureChildWithMargins(child, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec, <span class="number">0</span>); <span class="comment">// 调用该方法去测量每个子View</span>
}
</code></pre></li>
<li><p>该方法内部会走方法measureChildWithMargins计算每个子View的大小</p>
<pre><code><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">()</span> 
        child.<span class="title">measure</span><span class="params">(childWidthMeasureSpec, childHeightMeasureSpec)</span></span>;
}
</code></pre></li>
<li><p>那么每个child-view都会调用View的measure方法进行一次子view的测量。这里假设子view不是viewGroup了,会调用View.onMeasure()方法：</p>
<pre><code>protected void onMeasure<span class="params">(int widthMeasureSpec, int heightMeasureSpec)</span> {
    <span class="comment">// 如果不重写onMeasure方法，默认会调用getDefaultSize获取大小，下面会说getDefaultSize这个方法。</span>
        setMeasuredDimension<span class="params">(getDefaultSize<span class="params">(getSuggestedMinimumWidth<span class="params">()</span>, widthMeasureSpec)</span>,getDefaultSize<span class="params">(getSuggestedMinimumHeight<span class="params">()</span>, heightMeasureSpec)</span>)</span>;
}
</code></pre></li>
</ul>
<ul>
<li><p>这里getDefaultSize方法中会使用 MeasureSpec ，它用来指定size 和mode：</p>
<pre><code>public <span class="keyword">static</span> <span class="type">int</span> getDefaultSize(<span class="type">int</span> size, <span class="type">int</span> measureSpec) {
    <span class="type">int</span> <span class="literal">result</span> = size;
    // measureSpec值用于获取宽度(高度)的规格和大小，解析出对应的size和mode
    <span class="type">int</span> specMode = <span class="type">MeasureSpec</span>.getMode(measureSpec);
    <span class="type">int</span> specSize = <span class="type">MeasureSpec</span>.getSize(measureSpec);

    switch (specMode) {
            <span class="keyword">case</span> <span class="type">MeasureSpec</span>.<span class="type">UNSPECIFIED</span>:
                <span class="literal">result</span> = size;
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="type">MeasureSpec</span>.<span class="type">AT_MOST</span>:
           <span class="keyword">case</span> <span class="type">MeasureSpec</span>.<span class="type">EXACTLY</span>:
            <span class="literal">result</span> = specSize;
            <span class="keyword">break</span>;
            }
            <span class="keyword">return</span> <span class="literal">result</span>;
    }
</code></pre><p>这里特别要解释：</p>
<blockquote>
<pre><code>•MeasureSpec<span class="class">.EXACTLY</span> ：理解成MATCH_PARENT或者在布局中指定了宽高值，如layout:<span class="attribute">width</span>=<span class="string">'50dp'</span>
•MeasureSpec<span class="class">.AT_MOST</span> ：理解成WRAP_CONTENT,这是的值是父View可以允许的最大的值，只要不超过这个值都可以
•MeasureSpec<span class="class">.UNSPECIFIED</span> ： 设置为任意大小
</code></pre></blockquote>
</li>
<li><p>那么子View的onMeasure里面会调用setMeasuredDimension方法：</p>
<pre><code><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">setMeasuredDimension</span><span class="params">(<span class="keyword">int</span> measuredWidth, <span class="keyword">int</span> measuredHeight)</span> </span>{
        setMeasuredDimensionRaw(measuredWidth, measuredHeight);
}
</code></pre></li>
<li><p>最后的setMeasuredDimensionRaw</p>
<pre><code><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">setMeasuredDimensionRaw</span><span class="params">(<span class="keyword">int</span> measuredWidth, <span class="keyword">int</span> measuredHeight)</span> </span>{
    <span class="comment">// 赋值给mMeasuredWidth，getMeasuredWidth就会调用该值。</span>
    mMeasuredWidth = measuredWidth;
    mMeasuredHeight = measuredHeight;

    <span class="comment">// 这就是重写onMeasure方法时如果不调用setMeasuredDimension方法时为什么会报错的原因。</span>
        mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;
}
</code></pre></li>
</ul>
<p><img src="http://i.imgur.com/yy6OMwg.png" alt=""></p>
<p>这里简单总结一下上面的过程:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">performMeasure() &#123;</span><br><span class="line">	- <span class="number">1</span>.调用View.measure方法</span><br><span class="line">	mView.measure():</span><br><span class="line">		- <span class="number">2</span>.measure内部会调用onMeasure方法,但是因为这里mView是DecorView，所以会调用FrameLayout的onMeasure方法。</span><br><span class="line">	        onMeasure(FrameLayout)</span><br><span class="line">			- <span class="number">3</span>. 内部设置ViewGroup的宽高</span><br><span class="line">				setMeasuredDimension</span><br><span class="line">				并且对每个子View进行遍历测量</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">					<span class="keyword">final</span> View child = getChildAt(i);</span><br><span class="line">					- <span class="number">4</span>. 对每个子View调用measureChildWithMargins方法</span><br><span class="line">					measureChildWithMargins(child, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec, <span class="number">0</span>);	</span><br><span class="line">					    -<span class="number">5</span>. measureChildWithMargins内部调用子View的measure方法</span><br><span class="line">					        meausre</span><br><span class="line">							- <span class="number">6</span>. measure方法内部又调用onMeasure方法</span><br><span class="line">					            onMeasure(View)</span><br><span class="line">					            - <span class="number">7</span>. onMeasure方法内部调用setMeasuredDimension</span><br><span class="line">									setMeasuredDimension</span><br><span class="line">									- <span class="number">8</span>. setMeasuredDimension内部调用setMeasuredDimensionRaw</span><br><span class="line">									    setMeasuredDimensionRaw</span><br><span class="line">				&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>###2.3 Layout摆放视图</p>
<p>简单描述：</p>
<ul>
<li><p>performLayout中调用方法host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());会把测量的宽高大小设置进来</p>
</li>
<li><p>根View.layout方法会里面会调用onLayout(changed, l, t, r, b);</p>
</li>
<li><p>根view的onLayout方法中会去测量每个子类的layout  :  </p>
<blockquote>
<p>child.layout(childLeft, childTop, childLeft + width, childTop + height);</p>
</blockquote>
</li>
</ul>
<p><img src="http://i.imgur.com/xgpfJBa.png" alt=""></p>
<p>这里也总结一下<code>layout</code>的过程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performLayout</span><span class="params">(WindowManager.LayoutParams lp, <span class="keyword">int</span> desiredWindowWidth,</span><br><span class="line">		<span class="keyword">int</span> desiredWindowHeight)</span> </span>&#123;</span><br><span class="line">	- <span class="number">1</span>. host.layout</span><br><span class="line">	host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line">		-<span class="number">2</span>. layout方法会分别调用setFrame()和onLayout()方法</span><br><span class="line">			setFrame()</span><br><span class="line">			onLayout()</span><br><span class="line">			-<span class="number">3</span>. 因为host是mView也就是DecorView也就是FrameLayout的子类。FrameLayout的onLayout方法如下</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">					<span class="keyword">final</span> View child = getChildAt(i);</span><br><span class="line">					<span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">					    -<span class="number">4</span>. 遍历每个子View，并分别调用layout方法。</span><br><span class="line">						child.layout(childLeft, childTop, childLeft + width, childTop + height);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>###2.4 Draw 重绘视图</p>
<p>简单描述：</p>
<ul>
<li><p>performDraw 里面调用 draw(fullRedrawNeeded)开始draw了</p>
</li>
<li><p>draw方法中调用方法drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)</p>
</li>
<li><p>drawSoftwarem方法中调用方法根View.draw(canvas)–》也就是 FrameLayout.draw() </p>
</li>
<li><p>根View.draw 内部调用了 super.draw() ，而 根view属于ViewGroup ，VP没有重写该方法，所以直接看 View 的 draw() 方法；</p>
</li>
<li><p>View.draw() 方法中会执行draw的6个步骤</p>
<ul>
<li><ol>
<li>Draw the background  花背景</li>
</ol>
</li>
<li><ol>
<li>If necessary, save the canvas’ layers to prepare for fading</li>
</ol>
</li>
<li><ol>
<li>Draw view’s content, 调用onDraw方法绘制自身  ： <strong>onDraw(canvas)方法</strong></li>
</ol>
</li>
<li><ol>
<li>Draw children, 调用dispatchDraw方法绘制子View: <strong>dispatchDraw(canvas)方法</strong> </li>
</ol>
</li>
<li><ol>
<li>If necessary, draw the fading edges and restore layers</li>
</ol>
</li>
<li><ol>
<li>Draw decorations (scrollbars for instance) ： <strong>onDrawScrollBars(canvas)方法</strong></li>
</ol>
</li>
</ul>
</li>
<li><p>draw的6个步骤之三：执行view.onDraw(canvas)，是空方法。子类(比如Textview)具体的去实现</p>
</li>
<li><p>draw的6个步骤之四，绘制子view，里面有个方法drawChild(canvas, child, drawingTime)，这个方法里面走child.draw(canvas, this, drawingTime);</p>
</li>
</ul>
<p><img src="http://i.imgur.com/ohbJo3b.png" alt=""></p>
<p>这里也简单总结一下<code>draw</code>的过程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. ViewRootImpl.performDraw()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 2. ViewRootImpl.draw()</span></span><br><span class="line">	draw(fullRedrawNeeded);	</span><br><span class="line">		<span class="comment">// 3. ViewRootImpl.drawSoftware</span></span><br><span class="line">		drawSoftware</span><br><span class="line">			<span class="comment">// 4. 内部调用mView.draw,也就是FrameLayout.draw(). </span></span><br><span class="line">			mView.draw()(FrameLayout)</span><br><span class="line">				<span class="comment">// 5. FrameLayout.draw方法内部会调用super.draw方法，也就是View.draw方法.</span></span><br><span class="line">				<span class="keyword">super</span>.draw(canvas);</span><br><span class="line">					<span class="comment">// 6. View.draw方法内部会分别调用onDraw绘制自己以及dispatchDraw绘制子View.</span></span><br><span class="line">					onDraw</span><br><span class="line">					<span class="comment">// 绘制子View</span></span><br><span class="line">					dispatchDraw</span><br><span class="line">						<span class="comment">// 7. dispatchDraw方法内部会遍历所有子View.</span></span><br><span class="line">						<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childrenCount; i++) &#123;</span><br><span class="line">							<span class="comment">// 8. 对每个子View分别调用drawChild方法</span></span><br><span class="line">							drawChild()</span><br><span class="line">								<span class="comment">// 9. drawChild方法内部会对该子View调用draw方法，进行绘制。然后draw又会调用onDraw等，循环就开始了。 </span></span><br><span class="line">									child.draw()</span><br><span class="line">						&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>###2.5 重要API</p>
<p>onMeasure重要API：<br>    //1.根据传入的参数，分别获取测量模式和测量值 </p>
<pre><code><span class="keyword">int</span> height_mode = MeasureSpec.getMode(heightMeasureSpec);
<span class="keyword">int</span> height_size = MeasureSpec.getSize(heightMeasureSpec);

<span class="keyword">int</span> width_mode = MeasureSpec.getMode(widthMeasureSpec);
<span class="keyword">int</span> width_size = MeasureSpec.getSize(widthMeasureSpec);
</code></pre><p>#3 Touch事件的分发和消费机制</p>
<blockquote>
<p>Touch 事件相关的方法：</p>
<ol>
<li>dispatchTouchEvent(MotionEvent ev)：事件分发</li>
<li>onInterceptTouchEvent(MotionEvent ev)：事件拦截</li>
<li>onTouchEvent(MotionEvent ev)：事件响应</li>
</ol>
</blockquote>
<p><img src="http://i.imgur.com/F2CyMYw.png" alt=""><br>▐ 注明：View中应该是没有onInterceptTouchEvent的，只有继承GroupView才有</p>
<ul>
<li><p>分析</p>
<ol>
<li><p>ViewGroup(比如LinearLayout)和继承于ViewGroup的View(比如自定的一些布局)，均有三个事件的响应;</p>
<blockquote>
<pre><code><span class="keyword">new</span> LinearLayout(context).dispatchTouchEvent(<span class="keyword">event</span>);
<span class="keyword">new</span> LinearLayout(context).onInterceptTouchEvent(<span class="keyword">event</span>);
<span class="keyword">new</span> LinearLayout(context).onTouchEvent(<span class="keyword">event</span>);
</code></pre></blockquote>
</li>
<li><p>Activity没有onInterceptTouchEvent事件拦截</p>
</li>
<li><p>最小View(比如TextView)也是没有onInterceptTouchEvent事件拦截</p>
</li>
</ol>
</li>
</ul>
<blockquote>
<pre><code><span class="keyword">new</span> TextView(context).onTouchEvent(<span class="keyword">event</span>);
<span class="keyword">new</span> TextView(<span class="keyword">this</span>).dispatchTouchEvent(<span class="keyword">event</span>);
</code></pre></blockquote>
<p>##3.1 Touch 事件分析</p>
<p>###3.1.1▐ 事件分发：dispatchTouchEvent(MotionEvent ev)</p>
<p>public boolean dispatchTouchEvent(MotionEvent ev)</p>
<p><img src="http://i.imgur.com/zPVPbFs.png" alt=""></p>
<blockquote>
<p>Touch 事件发生时 Activity 的 dispatchTouchEvent(MotionEvent ev) 方法会以隧道方式（从根元素依次往下传递直到最内层子元素或在中间某一元素中由于某一条件停止传递）将事件传递给最外层 View 的 dispatchTouchEvent(MotionEvent ev) 方法，并由该 View 的 dispatchTouchEvent(MotionEvent ev) 方法对事件进行分发。dispatchTouchEvent 的事件分发逻辑如下：</p>
</blockquote>
<pre><code>如果 <span class="keyword">return</span> true，事件会分发给当前 <span class="keyword">View</span> 并由 dispatchTouchEvent 方法进行消费，同时事件会停止向下传递；

如果 <span class="keyword">return</span> false，事件分发分为两种情况：
    1.如果当前 <span class="keyword">View</span> 获取的事件直接来自 Activity，则会将事件返回给 Activity 的 onTouchEvent 进行消费；
    2.如果当前 <span class="keyword">View</span> 获取的事件来自外层父控件，则会将事件返回给父 <span class="keyword">View</span> 的  onTouchEvent 进行消费。

如果返回系统默认的 super.dispatchTouchEvent(ev)，事件会自动的分发给当前 <span class="keyword">View</span> 的 onInterceptTouchEvent 方法。
</code></pre><p>###3.1.2▐ 事件拦截：onInterceptTouchEvent(MotionEvent ev) </p>
<p>public boolean onInterceptTouchEvent(MotionEvent ev)</p>
<p><img src="http://i.imgur.com/XpNLTDE.png" alt=""></p>
<blockquote>
<p>在外层 View 的 dispatchTouchEvent(MotionEvent ev) 方法返回系统默认的 super.dispatchTouchEvent(ev) 情况下，事件会自动的分发给当前 View 的 onInterceptTouchEvent 方法。onInterceptTouchEvent 的事件拦截逻辑如下：</p>
</blockquote>
<pre><code>如果 <span class="keyword">on</span>InterceptTouchEvent 返回 true，则表示将事件进行拦截，并将拦截到的事件交由当前 View 的 <span class="keyword">on</span>TouchEvent 进行处理；

如果 <span class="keyword">on</span>InterceptTouchEvent 返回 false，则表示将事件放行，当前 View 上的事件会被传递到子 View 上，再由子 View 的 dispatchTouchEvent 来开始这个事件的分发；

如果 <span class="keyword">on</span>InterceptTouchEvent 返回 super.<span class="keyword">on</span>InterceptTouchEvent(ev)，事件默认会被拦截，并将拦截到的事件交由当前 View 的 <span class="keyword">on</span>TouchEvent 进行处理。
</code></pre><p>###3.1.3▐ 事件响应：onTouchEvent(MotionEvent ev)</p>
<p>public boolean onTouchEvent(MotionEvent ev)</p>
<p><img src="http://i.imgur.com/r5B7mJp.png" alt=""></p>
<blockquote>
<p>在 dispatchTouchEvent 返回 super.dispatchTouchEvent(ev) 并且 onInterceptTouchEvent 返回 true 或返回 super.onInterceptTouchEvent(ev) 的情况下 onTouchEvent 会被调用。onTouchEvent 的事件响应逻辑如下：</p>
</blockquote>
<pre><code>如果事件传递到当前 View 的 onTouchEvent 方法，而该方法返回了 <span class="literal">false</span>，那么这个事件会从当前 View 向上传递，并且都是由上层 View 的 onTouchEvent 来接收，如果传递到上面的 onTouchEvent 也返回 <span class="literal">false</span>，这个事件就会“消失”，而且接收不到下一次事件。

如果返回了 <span class="literal">true</span> 则会接收并消费该事件。

如果返回 <span class="keyword">super</span>.onTouchEvent(ev) 默认处理事件的逻辑和返回 <span class="literal">false</span> 时相同。
</code></pre><p>##3.2 事例分析</p>
<ul>
<li>事件类型分为  ACTION_DOWN,ACTION_UP,ACTION_MOVE,ACTION_POINTER_DOWN,ACTION_POINTER_UP,ACTION_CANCEL, 每个 一个完整的事件以ACTION_DOWN开始ACTION_UP结束，并且ACTION_CANCEL只能由代码引起.一般对于CANCEL的处理和UP的相同。</li>
</ul>
<blockquote>
<p>事件从Activity.dispatchTouchEveent()开始传递，只要没有停止拦截，就会从最上层(ViewGroup)开始一直往下传递，子View通过onTouchEvent()消费事件。(隧道式向下分发).</p>
<p>如果时间从上往下一直传递到最底层的子View，但是该View没有消费该事件，那么该事件会反序往上传递(从该View传递给自己的ViewGroup，然后再传给更上层的ViewGroup直至传递给Activity.onTouchEvent()). (冒泡式向上处理).</p>
</blockquote>
<p>注：图片上是点击View(最内层view)<br><img src="http://i.imgur.com/p0HgKM3.png" alt=""></p>
<pre><code><span class="comment">/**
 * 不带滑动的ViewPager
 * <span class="doctag">@author</span> xiongwei
 *
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoScrollViewPager</span> <span class="keyword">extends</span> <span class="title">ViewPager</span></span>{

    <span class="function"><span class="keyword">public</span> <span class="title">NoScrollViewPager</span><span class="params">(Context context)</span> </span>{
        <span class="keyword">super</span>(context);
    }

    <span class="function"><span class="keyword">public</span> <span class="title">NoScrollViewPager</span><span class="params">(Context context, AttributeSet attrs)</span> </span>{
        <span class="keyword">super</span>(context, attrs);
    }

    <span class="comment">/**
     * 返回true表示处理touch事件
     * 返回false表示不处理touch事件:即ViewPager不处理滑动事件
     */</span>
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent arg0)</span> </span>{
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }

    <span class="comment">/**
     * 返回true表示处理touch事件
     * 返回false表示不处理touch事件:即ViewPager不处理滑动事件
     */</span>
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent arg0)</span> </span>{
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }

}


<span class="comment">// 让父类不要拦截滑动，让我来处理滑动</span>
getParent().requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);
</code></pre><p>#4 Android手势处理</p>
<p>##4.1 手势交互的原理<br>在Android系统中，每一次手势交互都会依照以下顺序执行。</p>
<ol>
<li><p>接触接触屏一刹那，触发一个MotionEvent事件。</p>
</li>
<li><p>该事件被OnTouchListener监听，在其onTouch()方法里获得该MotionEvent对象。</p>
</li>
<li><p>通过GestureDetector（手势识别器）转发次MotionEvent对象至OnGestureListener。</p>
</li>
<li><p>OnGestureListener获得该对象，听根据该对象封装的的信息，做出合适的反馈。</p>
</li>
</ol>
<p>##4.2 MotionEvent、GestureDetector和OnGestureListener</p>
<blockquote>
<p>MotionEvent: 这个类用于封装手势、触摸笔、轨迹球等等的动作事件。其内部封装了两个重要的属性X和Y，这两个属性分别用于记录横轴和纵轴的坐标。</p>
<p>GestureDetector: 识别各种手势。</p>
<p>OnGestureListener: 这是一个手势交互的监听接口，其中提供了多个抽象方法，并根据GestureDetector的手势识别结果调用相对应的方法。</p>
</blockquote>
<p>##4.3回调函数</p>
<p>按下（onDown）： 刚刚手指接触到触摸屏的那一刹那，就是触的那一下。</p>
<p>抛掷（onFling）： 手指在触摸屏上迅速移动，并松开的动作。</p>
<p>长按（onLongPress）： 手指按在持续一段时间，并且没有松开。</p>
<p>滚动（onScroll）： 手指在触摸屏上滑动。</p>
<p>按住（onShowPress）： 手指按在触摸屏上，它的时间范围在按下起效，在长按之前。</p>
<p>抬起（onSingleTapUp）：手指离开触摸屏的那一刹那。</p>
<p>除了这些定义之外，鄙人也总结了一点算是经验的经验吧，在这里和大家分享一下。</p>
<p>任何手势动作都会先执行一次按下（onDown）动作。</p>
<p>长按（onLongPress）动作前一定会执行一次按住（onShowPress）动作。</p>
<p>按住（onShowPress）动作和按下（onDown）动作之后都会执行一次抬起（onSingleTapUp）动作。</p>
<p>长按（onLongPress）、滚动（onScroll）和抛掷（onFling）动作之后都不会执行抬起（onSingleTapUp）动作。</p>
<p>###4.4 如何使用</p>
<p>1.实现implements OnTouchListener, OnGestureListener</p>
<p>2.实现OnTouchListener的onTouch回调，此时让GestureDetector来处理用户手势</p>
<pre><code><span class="function"><span class="keyword">public</span> boolean <span class="title">onTouch</span>(<span class="params">View v, MotionEvent <span class="keyword">event</span></span>) </span>{
    <span class="comment">// 在onTouch()方法中，我们调用GestureDetector的onTouchEvent()方法，将捕捉到的MotionEvent交给 GestureDetector 来分析是否有合适的callback函数来处理用户的手势</span>
    detector.onTouchEvent(<span class="keyword">event</span>);
    <span class="keyword">return</span> <span class="keyword">true</span>;
}
</code></pre><p>3.实现OnGestureListener的6个回调<br>    最主要：onFling()、onScroll()和onLongPress()</p>
<p>onDown：用户轻触触摸屏，由1个MotionEvent ACTION_DOWN触发</p>
<p>onShowPress：用户轻触触摸屏，尚未松开或拖动，由一个1个MotionEvent ACTION_DOWN触发 ，注意和onDown()的区别，强调的是没有松开或者拖动的状态</p>
<p>onSingleTapUp：用户（轻触触摸屏后）松开，由一个1个MotionEvent ACTION_UP触发</p>
<p>onFling：用户按下触摸屏、快速移动后松开，由1个MotionEvent ACTION_DOWN, 多个ACTION_MOVE, 1个ACTION_UP触发</p>
<p>onLongPress:用户长按触摸屏，由多个MotionEvent ACTION_DOWN触发</p>
<p>onScroll:用户按下触摸屏，并拖动，由1个MotionEvent ACTION_DOWN, 多个ACTION_MOVE触发 </p>
<p>4.需要在onCreate中tv.setOnTouchListener(this);之后添加如下一句代码。<br>tv.setLongClickable(true);  才可以让onFling函数执行</p>
<p>###4.5 GestureDetector.SimpleOnGestureListener—类<br>用extends派生，里面的方法不用都实现，选择自己需要实现的</p>
<pre><code>mGestureDetector = <span class="keyword">new</span> <span class="type">GestureDetector</span>(<span class="keyword">new</span> simpleGestureListener()); 
tv.setOnTouchListener(<span class="keyword">this</span>);  
tv.setFocusable(<span class="literal">true</span>);     
tv.setClickable(<span class="literal">true</span>);     
tv.setLongClickable(<span class="literal">true</span>);  

<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">simpleGestureListener</span> <span class="keyword"><span class="keyword">extends</span></span>  <span class="title">GestureDetector</span>.<span class="title">SimpleOnGestureListener</span> {</span> 

} 
</code></pre><p>###4.6 判断左滑还是右滑</p>
<pre><code>final int FLING_MIN_DISTANCE = <span class="number">100</span>, FLING_MIN_VELOCITY = <span class="number">200</span>;    
<span class="comment">// 触发条件 ：     </span>
<span class="comment">// X轴的坐标位移大于FLING_MIN_DISTANCE，且移动速度大于FLING_MIN_VELOCITY个像素/秒     </span>

<span class="comment">// 参数解释：     </span>
<span class="comment">// e1：第1个ACTION_DOWN MotionEvent     </span>
<span class="comment">// e2：最后一个ACTION_MOVE MotionEvent     </span>
<span class="comment">// velocityX：X轴上的移动速度，像素/秒     </span>
<span class="comment">// velocityY：Y轴上的移动速度，像素/秒     </span>
public boolean onFling<span class="params">(MotionEvent e1, MotionEvent e2, float velocityX,  
        float velocityY)</span> {  
    <span class="keyword">if</span> <span class="params">(e1.getX<span class="params">()</span> - e2.getX<span class="params">()</span> &gt; FLING_MIN_DISTANCE    
            &amp;&amp; Math.abs<span class="params">(velocityX)</span> &gt; FLING_MIN_VELOCITY)</span> {    
        <span class="comment">// Fling left     </span>
        Log.i<span class="params">(<span class="string">"MyGesture"</span>, <span class="string">"Fling left"</span>)</span>;    
        Toast.makeText<span class="params">(MainActivity.this, <span class="string">"Fling Left"</span>, Toast.LENGTH_SHORT)</span>.show<span class="params">()</span>;    
    } <span class="keyword">else</span> <span class="keyword">if</span> <span class="params">(e2.getX<span class="params">()</span> - e1.getX<span class="params">()</span> &gt; FLING_MIN_DISTANCE    
            &amp;&amp; Math.abs<span class="params">(velocityX)</span> &gt; FLING_MIN_VELOCITY)</span> {    
        <span class="comment">// Fling right     </span>
        Log.i<span class="params">(<span class="string">"MyGesture"</span>, <span class="string">"Fling right"</span>)</span>;    
        Toast.makeText<span class="params">(MainActivity.this, <span class="string">"Fling Right"</span>, Toast.LENGTH_SHORT)</span>.show<span class="params">()</span>;    
    }    
    return <span class="literal">true</span>;  
} 
</code></pre><p>#5 ViewDragHelper的使用</p>
<p>SlidingPaneLayout和DrawerLayout(谷歌侧滑) 都是使用ViewDragHelper来处理拖动</p>
<p>ViewDragHelper实现用户复杂的手势处理，gesturedetector比较复杂实现的手势处理;</p>
<p>###5.1 基础说明</p>
<pre><code><span class="number">1</span><span class="class">.ViewDragHelper</span><span class="class">.Callback</span>是连接ViewDragHelper与view之间的桥梁（这个view一般是指拥子view的容器即parentView）；

<span class="number">2</span>.ViewDragHelper的实例是通过静态工厂方法创建的；

<span class="number">3</span>.你能够指定拖动的方向；

   <span class="number">4</span>.ViewDragHelper可以检测到是否触及到边缘；

   <span class="number">5</span>.ViewDragHelper并不是直接作用于要被拖动的View，而是使其控制的视图容器中的子View可以被拖动，如果要指定某个子view的行为，需要在Callback中想办法；

   <span class="number">6</span>.ViewDragHelper的本质其实是分析onInterceptTouchEvent和onTouchEvent的MotionEvent参数，然后根据分析的结果去改变一个容器中被拖动子View的位置（ 通过<span class="function"><span class="title">offsetTopAndBottom</span><span class="params">(int offset)</span></span>和<span class="function"><span class="title">offsetLeftAndRight</span><span class="params">(int offset)</span></span>方法 ），他能在触摸的时候判断当前拖动的是哪个子View；

   <span class="number">7</span>.虽然ViewDragHelper的实例方法 ViewDragHelper <span class="function"><span class="title">create</span><span class="params">(ViewGroup forParent, Callback cb)</span></span> 可以指定一个被ViewDragHelper处理拖动事件的对象 ，但ViewDragHelper类的设计决定了其适用于被包含在一个自定义ViewGroup之中，而不是对任意一个布局上的视图容器使用ViewDragHelper。
</code></pre><p>###5.2 用法</p>
<p>####1.ViewDragHelper的初始化</p>
<blockquote>
<pre><code>ViewDragHelper一般用在一个自定义ViewGroup的内部，比如下面自定义了一个继承于LinearLayout的DragLayout，DragLayout内部有一个子<span class="built_in">view</span> mDragView作为成员变量
</code></pre></blockquote>
<p>步骤一：继承ViewGroup,并初始化带回调函数的ViewDragHelper</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">DragLayout</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">LinearLayout</span> {</span>

    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ViewDragHelper</span> mDragHelper;
    <span class="keyword">private</span> <span class="type">View</span> mDragView;

    public <span class="type">DragLayout</span>(<span class="type">Context</span> context) {
        <span class="keyword">this</span>(context, <span class="literal">null</span>);
    }

    public <span class="type">DragLayout</span>(<span class="type">Context</span> context, <span class="type">AttributeSet</span> attrs) {
        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);
    }

    public <span class="type">DragLayout</span>(<span class="type">Context</span> context, <span class="type">AttributeSet</span> attrs, int defStyle) {
        <span class="keyword">super</span>(context, attrs, defStyle);
        <span class="comment">/**
         * 创建一个带有回调接口的ViewDragHelper
         * 参数1：this ViewDragHelper的拖动处理对象，必须为ViewGroup或实现view
         * 参数2：敏感度，参数越大越敏感。1.0f最名
         * 其中是敏感度参数参数越大越敏感。第一个参数为this，表示该类生成的对象，他是。
         */</span>
        mDragHelper = <span class="type">ViewDragHelper</span>.create(<span class="keyword">this</span>, <span class="number">1.0</span>f, <span class="keyword">new</span> <span class="type">DragHelperCallback</span>());
    }
}
</code></pre><p>步骤二：和gesturedetector一样，在onTouch中指定为mDragHelper来处理Touch事件</p>
<pre><code><span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>{
  mDragHelper.processTouchEvent(ev);
  <span class="keyword">return</span> <span class="keyword">true</span>;
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>{
  <span class="keyword">final</span> <span class="keyword">int</span> action = MotionEventCompat.getActionMasked(ev);
  <span class="keyword">if</span> (action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_UP) {
      mDragHelper.cancel();
      <span class="keyword">return</span> <span class="keyword">false</span>;
  }
  <span class="function"><span class="keyword">return</span> mDragHelper.<span class="title">shouldInterceptTouchEvent</span><span class="params">(ev)</span></span>;
}
</code></pre><p>####2.拖动行为的处理</p>
<p>#7 PTR的几种主流实现方式</p>
<p>继承ListView<br>继承LinearLayout<br>继承ViewGroup</p>
<p>###7.1 判断ListView、webview、gridview等是否滑动到顶或者底部</p>
<p>规定：</p>
<pre><code>public interface Pullable {
    /<span class="keyword">*</span><span class="keyword">*</span>
     <span class="keyword">*</span> 判断是否可以下拉，如果不需要下拉功能可以直接return false
     <span class="keyword">*</span> 
     <span class="keyword">*</span> <span class="comment">@return true如果可以下拉否则返回false</span>
     <span class="keyword">*</span>/
    boolean canPullDown();

    /<span class="keyword">*</span><span class="keyword">*</span>
     <span class="keyword">*</span> 判断是否可以上拉，如果不需要上拉功能可以直接return false
     <span class="keyword">*</span> 
     <span class="keyword">*</span> <span class="comment">@return true如果可以上拉否则返回false</span>
     <span class="keyword">*</span>/
    boolean canPullUp();
}
</code></pre><blockquote>
<p>ListView</p>
</blockquote>
<pre><code>public boolean canPullDown<span class="params">()</span>{
    <span class="keyword">if</span> <span class="params">(getCount<span class="params">()</span> == <span class="number">0</span>)</span>{
        <span class="comment">// 没有item的时候也可以下拉刷新</span>
        return <span class="literal">true</span>;
    } <span class="keyword">else</span> <span class="keyword">if</span> <span class="params">(getFirstVisiblePosition<span class="params">()</span> == <span class="number">0</span>&amp;&amp; getChildAt<span class="params">(<span class="number">0</span>)</span>.getTop<span class="params">()</span> &gt;= <span class="number">0</span>)</span>{
        <span class="comment">// 滑到ListView的顶部了</span>
        return <span class="literal">true</span>;
    } <span class="keyword">else</span>
        return <span class="literal">false</span>;
}


@Override
public boolean canPullUp<span class="params">()</span> {
    <span class="keyword">if</span> <span class="params">(getCount<span class="params">()</span> == <span class="number">0</span>)</span> {<span class="comment">// 没有item的时候也可以上拉加载</span>
        return <span class="literal">true</span>;
    } <span class="keyword">else</span> <span class="keyword">if</span> <span class="params">(getLastVisiblePosition<span class="params">()</span> == <span class="params">(getCount<span class="params">()</span> - <span class="number">1</span>)</span>)</span> {<span class="comment">// 滑到底部了</span>
        <span class="keyword">if</span> <span class="params">(getChildAt<span class="params">(getLastVisiblePosition<span class="params">()</span> - getFirstVisiblePosition<span class="params">()</span>)</span> != null
                &amp;&amp; getChildAt<span class="params">(getLastVisiblePosition<span class="params">()</span> - getFirstVisiblePosition<span class="params">()</span>)</span>.getBottom<span class="params">()</span> &lt;= getMeasuredHeight<span class="params">()</span>)</span>
            return <span class="literal">true</span>;
    }
    return <span class="literal">false</span>;
}
</code></pre><blockquote>
<p>GridView</p>
</blockquote>
<pre><code>@Override
public boolean canPullDown<span class="params">()</span> {
    <span class="keyword">if</span> <span class="params">(getCount<span class="params">()</span> == <span class="number">0</span>)</span> {
        <span class="comment">// 没有item的时候也可以下拉刷新</span>
        return <span class="literal">true</span>;
    } <span class="keyword">else</span> <span class="keyword">if</span> <span class="params">(getFirstVisiblePosition<span class="params">()</span> == <span class="number">0</span> &amp;&amp; getChildAt<span class="params">(<span class="number">0</span>)</span>.getTop<span class="params">()</span> &gt;= <span class="number">0</span>)</span> {
        <span class="comment">// 滑到顶部了</span>
        return <span class="literal">true</span>;
    } <span class="keyword">else</span>
        return <span class="literal">false</span>;
}


@Override
public boolean canPullUp<span class="params">()</span> {
    <span class="keyword">if</span> <span class="params">(getCount<span class="params">()</span> == <span class="number">0</span>)</span> {
        <span class="comment">// 没有item的时候也可以上拉加载</span>
        return <span class="literal">true</span>;
    } <span class="keyword">else</span> <span class="keyword">if</span> <span class="params">(getLastVisiblePosition<span class="params">()</span> == <span class="params">(getCount<span class="params">()</span> - <span class="number">1</span>)</span>)</span> {
        <span class="comment">// 滑到底部了</span>
        <span class="keyword">if</span> <span class="params">(getChildAt<span class="params">(getLastVisiblePosition<span class="params">()</span> - getFirstVisiblePosition<span class="params">()</span>)</span> != null
                &amp;&amp; getChildAt<span class="params">(getLastVisiblePosition<span class="params">()</span> - getFirstVisiblePosition<span class="params">()</span>)</span>.getBottom<span class="params">()</span> &lt;= getMeasuredHeight<span class="params">()</span>)</span>
            return <span class="literal">true</span>;
    }
    return <span class="literal">false</span>;
}
</code></pre><blockquote>
<p>ScrollView</p>
</blockquote>
<pre><code><span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">canPullDown</span><span class="params">()</span> </span>{
    <span class="keyword">if</span> (getScrollY() == <span class="number">0</span>)
        <span class="keyword">return</span> <span class="keyword">true</span>;
    <span class="keyword">else</span>
        <span class="keyword">return</span> <span class="keyword">false</span>;
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">canPullUp</span><span class="params">()</span> </span>{
    <span class="keyword">if</span> (getScrollY() &gt;= (getChildAt(<span class="number">0</span>).getHeight() - getMeasuredHeight()))
        <span class="keyword">return</span> <span class="keyword">true</span>;
    <span class="keyword">else</span>
        <span class="keyword">return</span> <span class="keyword">false</span>;
}
</code></pre><blockquote>
<p>WebView</p>
</blockquote>
<pre><code><span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">canPullDown</span><span class="params">()</span> </span>{
    <span class="keyword">if</span> (getScrollY() == <span class="number">0</span>)
        <span class="keyword">return</span> <span class="keyword">true</span>;
    <span class="keyword">else</span>
        <span class="keyword">return</span> <span class="keyword">false</span>;
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">canPullUp</span><span class="params">()</span> </span>{
    <span class="keyword">if</span> (getScrollY() &gt;= getContentHeight() * getScale() - getMeasuredHeight())
        <span class="keyword">return</span> <span class="keyword">true</span>;
    <span class="keyword">else</span>
        <span class="keyword">return</span> <span class="keyword">false</span>;
}
</code></pre><blockquote>
<p>ImageView</p>
</blockquote>
<pre><code><span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">canPullDown</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> <span class="keyword">true</span>;
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">canPullUp</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> <span class="keyword">true</span>;
}
</code></pre><blockquote>
<p>TextView</p>
</blockquote>
<pre><code><span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">canPullDown</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> <span class="keyword">true</span>;
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">canPullUp</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> <span class="keyword">true</span>;
}
</code></pre><blockquote>
<p>ExpandableListView</p>
</blockquote>
<pre><code>@Override
public boolean canPullDown<span class="params">()</span> {
    <span class="keyword">if</span> <span class="params">(getCount<span class="params">()</span> == <span class="number">0</span>)</span> {
        <span class="comment">// 没有item的时候也可以下拉刷新</span>
        return <span class="literal">true</span>;
    } <span class="keyword">else</span> <span class="keyword">if</span> <span class="params">(getFirstVisiblePosition<span class="params">()</span> == <span class="number">0</span> &amp;&amp; getChildAt<span class="params">(<span class="number">0</span>)</span>.getTop<span class="params">()</span> &gt;= <span class="number">0</span>)</span> {
        <span class="comment">// 滑到顶部了</span>
        return <span class="literal">true</span>;
    } <span class="keyword">else</span>
        return <span class="literal">false</span>;
}

@Override
public boolean canPullUp<span class="params">()</span> {
    <span class="keyword">if</span> <span class="params">(getCount<span class="params">()</span> == <span class="number">0</span>)</span> {
        <span class="comment">// 没有item的时候也可以上拉加载</span>
        return <span class="literal">true</span>;
    } <span class="keyword">else</span> <span class="keyword">if</span> <span class="params">(getLastVisiblePosition<span class="params">()</span> == <span class="params">(getCount<span class="params">()</span> - <span class="number">1</span>)</span>)</span> {
        <span class="comment">// 滑到底部了</span>
        <span class="keyword">if</span> <span class="params">(getChildAt<span class="params">(getLastVisiblePosition<span class="params">()</span> - getFirstVisiblePosition<span class="params">()</span>)</span> != null
                &amp;&amp; getChildAt<span class="params">(getLastVisiblePosition<span class="params">()</span> - getFirstVisiblePosition<span class="params">()</span>)</span>.getBottom<span class="params">()</span> &lt;= getMeasuredHeight<span class="params">()</span>)</span>
            return <span class="literal">true</span>;
    }
    return <span class="literal">false</span>;
}
</code></pre><p>#8 5.0Transition动画</p>
<p>Activity Transition 5.0使用<br>Activity Transition是Material Design中提供的一种动画效果。它通过运动和切换不同状态之间的元素来产生各种动画效果。</p>
<p>Activity Transition提供了两种Transition类型：</p>
<pre><code><span class="keyword">Enter</span>（进入）：进入一个Activity的效果
 <span class="keyword">Exit</span>（退出）：退出一个Activity的效果
</code></pre><p>而这每种类型又分为普通Transition和共享元素Transition：<br>普通Transition：</p>
<pre><code>-<span class="ruby"> explode：从场景的中心移入或移出
</span>-<span class="ruby"> slide：从场景的边缘移入或移出
</span>-<span class="ruby"> fade：调整透明度产生渐变效果</span>
</code></pre><p>Shared Elements Transition 共享元素转换：<br>它的作用就是共享两个acitivity种共同的元素，在Android 5.0下支持如下效果：<br>changeBounds - 改变目标视图的布局边界<br>changeClipBounds - 裁剪目标视图边界<br>changeTransform - 改变目标视图的缩放比例和旋转角度<br>changeImageTransform - 改变目标图片的大小和缩放比例</p>
<p>步骤一：设置允许使用transition，并且设置transition<br>xml：<br>首先，如果要使用transition需要先修改style文件，在继承了material主题的style.xml中添加如下属性：</p>
<pre><code><span class="variable">&lt;style type="text/css" name="myTheme" parent="android:Theme.Material"&gt;</span><span class="variable">&lt;!-- 允许使用transitions --&gt;</span><span class="variable">&lt;item name=android:windowContentTransitions&gt;</span>true<span class="variable">&lt;/item&gt;</span> <span class="variable">&lt;!-- 指定进入和退出transitions --&gt;</span><span class="variable">&lt;item name=android:windowEnterTransition&gt;</span>@transition/explode<span class="variable">&lt;/item&gt;</span><span class="variable">&lt;item name=android:windowExitTransition&gt;</span>@transition/explode<span class="variable">&lt;/item&gt;</span> <span class="variable">&lt;!-- 指定shared element transitions --&gt;</span><span class="variable">&lt;item name=android:windowSharedElementEnterTransition&gt;</span>@transition/change_image_transform<span class="variable">&lt;/item&gt;</span><span class="variable">&lt;item name=android:windowSharedElementExitTransition&gt;</span>@transition/change_image_transform<span class="variable">&lt;/item&gt;</span><span class="variable">&lt;/style&gt;</span>
</code></pre><p>下面再来看看如何定义transition动画：</p>
<pre><code><span class="tag">&lt;<span class="title">transitionset</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>&gt;</span><span class="tag">&lt;<span class="title">explode</span>&gt;</span><span class="tag">&lt;<span class="title">changebounds</span>&gt;</span><span class="tag">&lt;<span class="title">changetransform</span>&gt;</span><span class="tag">&lt;<span class="title">changeclipbounds</span>&gt;</span><span class="tag">&lt;<span class="title">changeimagetransform</span>&gt;</span><span class="tag">&lt;/<span class="title">changeimagetransform</span>&gt;</span><span class="tag">&lt;/<span class="title">changeclipbounds</span>&gt;</span><span class="tag">&lt;/<span class="title">changetransform</span>&gt;</span><span class="tag">&lt;/<span class="title">changebounds</span>&gt;</span><span class="tag">&lt;/<span class="title">explode</span>&gt;</span><span class="tag">&lt;/<span class="title">transitionset</span></span>
</code></pre><p>代码：在代码中同样可以完成对于transition的设置：</p>
<pre><code><span class="pi">// 允许使用transitionsgetWindow().requestFeature(Window.FEATURE_CONTENT_TRANSITIONS); //</span> 设置一个exit transitiongetWindow().setExitTransition(<span class="keyword">new</span> Explode());
</code></pre><p>可以通过如下方法在代码总设置transition效果：<br>     Window.setEnterTransition()：普通transition的进入效果 </p>
<pre><code>Window.<span class="function"><span class="title">setExitTransition</span><span class="params">()</span></span>：普通<span class="attribute">transition</span>的退出效果

Window.<span class="function"><span class="title">setSharedElementEnterTransition</span><span class="params">()</span></span>：共享元素<span class="attribute">transition</span>的进入效果

Window.<span class="function"><span class="title">setSharedElementExitTransition</span><span class="params">()</span></span>：共享元素<span class="attribute">transition</span>的退出效果
</code></pre><p>步骤二：启动Activity：</p>
<p>当你已经设置了允许使用Transition并设置了Transition动画，你就可以通过ActivityOptions.makeSceneTransitionAnimation()方法启动一个新的Activity来激活这个</p>
<p>启用普通的Transition：<br>startActivity(intent,              ActivityOptions.makeSceneTransitionAnimation(this).toBundle());</p>
<p>启用共享元素Transition：</p>
<p>启动shared element transition和普通的transition稍有不同<br>在所有需要共享视图的Activity中，使用android:transitionName属性对于需要共享的元素分配一个通用的名字。</p>
<pre><code><span class="type">Intent</span> <span class="type">intent</span> = new <span class="type">Intent</span>(this, Activity2.<span class="keyword">class</span>);// shareView: 需要共享的视图// shareName: 设置的android:transitionName=shareNameActivityOptions options = ActivityOptions.makeSceneTransitionAnimation(this, shareView, shareName);startActivity(<span class="type">intent</span>, options.toBundle());
</code></pre><p>如果有多个View需要共享，则通过Pair.create()方法创建多个匹配对然后传入ActivityOptions.makeSceneTransitionAnimation。代码如下： </p>
<pre><code>ActivityOptions options = ActivityOptions.makeSceneTransitionAnimation<span class="params">(this,Pair.create<span class="params">(view1, agreedName1)</span>,Pair.create<span class="params">(view2, agreedName2)</span>)</span>;
</code></pre><p>如果不想使用transition可以设置options bundle为null。<br>当需要结束当前Activity并回退这个动画时调用Activity.finishAfterTransition()方法</p>
<p>#9 Material Designer的低版本兼容</p>
<p>###9.1概念<br>Material Designer ：纸墨模式，将空间变得像纸张一样，而用户的手指就是毛笔.<br>包含：1.涟漪（Ripple）效果；2.动画贯穿；3.排版干净与优雅；</p>
<p>###9.2Theme<br>具体见链接：<br><a href="http://www.cnblogs.com/tianzhijiexian/p/4081562.html" title="http://www.cnblogs.com/tianzhijiexian/p/4081562.html" target="_blank" rel="external">http://www.cnblogs.com/tianzhijiexian/p/4081562.html</a></p>
<p>#10.实现自己的自定义View篇—ArcMenu</p>
<p>##10.1操作步骤</p>
<blockquote>
<p>1.需要明确自定义哪些属性；</p>
<p>2.需要明确自定义哪个类型的View</p>
<p>3.需要明确实现OnMeasure、onLayout、OnDraw函数</p>
</blockquote>
<p>###问题一的答案：<br>ArcMenu需要明确两个自定义的属性供使用者来处理</p>
<pre><code>属性一：ArcMenu出现的位置：比如它出现在左上角的位置；
属性二：ArcMenu半径的大小：半径越小，子<span class="property">item</span>越多时，每个<span class="property">item</span>的间距就越紧；
</code></pre><p>####10.1.1 实现问题一针对的问题：自定义属性操作步骤<br>1.attr.xml：</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="tag">&lt;<span class="title">resources</span>&gt;</span>
    <span class="comment">&lt;!-- 定义这两个属性 --&gt;</span>
    <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"postion"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">enum</span> <span class="attribute">name</span>=<span class="value">"left_top"</span> <span class="attribute">value</span>=<span class="value">"0"</span> /&gt;</span>
        <span class="tag">&lt;<span class="title">enum</span> <span class="attribute">name</span>=<span class="value">"left_bottom"</span> <span class="attribute">value</span>=<span class="value">"1"</span> /&gt;</span>
        <span class="tag">&lt;<span class="title">enum</span> <span class="attribute">name</span>=<span class="value">"right_top"</span> <span class="attribute">value</span>=<span class="value">"2"</span> /&gt;</span>
        <span class="tag">&lt;<span class="title">enum</span> <span class="attribute">name</span>=<span class="value">"right_bootom"</span> <span class="attribute">value</span>=<span class="value">"3"</span> /&gt;</span>
    <span class="tag">&lt;/<span class="title">attr</span>&gt;</span>
    <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"radius"</span> <span class="attribute">format</span>=<span class="value">"dimension"</span>&gt;</span><span class="tag">&lt;/<span class="title">attr</span>&gt;</span>

    <span class="comment">&lt;!-- 引用这两个属性 --&gt;</span>
    <span class="tag">&lt;<span class="title">declare-styleable</span> <span class="attribute">name</span>=<span class="value">"ArcMenu"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"postion"</span>&gt;</span><span class="tag">&lt;/<span class="title">attr</span>&gt;</span>
        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"radius"</span>&gt;</span><span class="tag">&lt;/<span class="title">attr</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">declare-styleable</span>&gt;</span>
<span class="tag">&lt;/<span class="title">resources</span>&gt;</span>
</code></pre><p>2.布局文件中引用：</p>
<p>2.1 命名控件：指定命名空间的名称为xw,该值为随意值 </p>
<pre><code><span class="label">xmlns:</span>xw=<span class="string">"http://schemas.android.com/apk/res/com.imooc.arcmenu"</span>
</code></pre><p>2.2 引用控件</p>
<pre><code>&lt;com<span class="class">.study</span><span class="class">.arcmenu</span><span class="class">.ArcMenu</span> /&gt;
</code></pre><p>3.自定义控件中获取xml中自定义的属性值：</p>
<pre><code><span class="comment">/**
 * 获取xml中自定义的属性值
 */</span>
<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init_type</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> </span>{
    TypedArray a = context.getTheme().obtainStyledAttributes(attrs, R.styleable.ArcMenu, defStyle, <span class="number">0</span>);
    <span class="comment">// 获取用户定义的属性位置,并赋值给成员变量</span>
    <span class="keyword">int</span> pos = a.getInt(R.styleable.ArcMenu_postion, POS_RIGHT_BOTTOM);
    <span class="keyword">switch</span> (pos) {
    <span class="keyword">case</span> POS_LEFT_TOP:
        mPosition = ARC_POSITION.LEFT_TOP;
        <span class="keyword">break</span>;

    <span class="keyword">case</span> POS_LEFT_BOTTOM:
        mPosition = ARC_POSITION.LEFT_BOOTOM;
        <span class="keyword">break</span>;

    <span class="keyword">case</span> POS_RIGHT_TOP:
        mPosition = ARC_POSITION.RIGHT_TOP;
        <span class="keyword">break</span>;

    <span class="keyword">case</span> POS_RIGHT_BOTTOM:
        mPosition = ARC_POSITION.RIGHT_BOOTOM;
        <span class="keyword">break</span>;

    }
    <span class="comment">// 获取用户定义的半径大小,并赋值给成员变量</span>
    mRadius = (<span class="keyword">int</span>) a.getDimension(R.styleable.ArcMenu_radius, TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, <span class="number">100</span>, getResources().getDisplayMetrics()));

    Log.e(<span class="string">"TAG"</span>, <span class="string">"position = "</span> + mPosition + <span class="string">" , radius =  "</span> + mRadius);

    a.recycle();<span class="comment">// 最后一定要回收</span>
}
</code></pre><p>####10.1.2 实现问题一针对的问题：根据属性我们究竟要实现那些成员变量、枚举、回调函数</p>
<p>要实现的成员变量：</p>
<blockquote>
<p>1.位置属性</p>
</blockquote>
<pre><code><span class="keyword">private</span> ARC_POSITION mPosition = ARC_POSITION.RIGHT_BOOTOM;<span class="comment">// 位置属性</span>
</code></pre><blockquote>
<p>2.半径属性</p>
</blockquote>
<pre><code><span class="keyword">private</span> <span class="keyword">int</span> mRadius = (<span class="keyword">int</span>) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, <span class="number">100</span>, getResources().getDisplayMetrics());<span class="comment">// 菜单半径，初始化为100dp</span>
</code></pre><blockquote>
<p>3.菜单开闭状态</p>
</blockquote>
<pre><code><span class="keyword">private</span> ARC_STATUS mStatus = ARC_STATUS.CLOSE;<span class="comment">// 菜单开闭状态</span>
</code></pre><blockquote>
<p>4.中间主按钮View</p>
</blockquote>
<pre><code><span class="keyword">private</span> View mCButton;<span class="comment">// 中间的那个主按钮</span>
</code></pre><p>要实现的枚举变量</p>
<blockquote>
<p>1.菜单位置的枚举类型</p>
</blockquote>
<pre><code>public <span class="class"><span class="keyword">enum</span> <span class="title">ARC_POSITION</span> </span>{
    LEFT_TOP, LEFT_BOOTOM, RIGHT_TOP, RIGHT_BOOTOM
}
</code></pre><blockquote>
<p>2.菜单状态的枚举类型</p>
</blockquote>
<pre><code>public <span class="class"><span class="keyword">enum</span> <span class="title">ARC_STATUS</span> </span>{
    OPEN, CLOSE
}
</code></pre><p>要实现的回调函数</p>
<blockquote>
<p>点击子菜单的回调函数</p>
</blockquote>
<pre><code><span class="comment">/**
 * 1.3.点击子菜单的回调接口
 */</span>
<span class="keyword">private</span> OnMenuItmeClickListener menuClickListener;

<span class="comment">// 对外暴露set方法</span>
<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMenuClickListener</span>(<span class="params">OnMenuItmeClickListener menuClickListener</span>) </span>{
    <span class="keyword">this</span>.menuClickListener = menuClickListener;
}

<span class="comment">//要实现的回调方法</span>
<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">OnMenuItmeClickListener</span> {
    <span class="comment">/**
     * @param view 要点击的View子菜单
     * @param position 要点击的位置
     */</span>
    <span class="function"><span class="keyword">void</span> <span class="title">onClick</span>(<span class="params">View view, <span class="keyword">int</span> position</span>)</span>;
}
</code></pre><h3 id="问题二的答案：要继承实现哪个">问题二的答案：要继承实现哪个</h3><p>继承于现有控件<br>    依托现有控件的方法，进行改装后实现，比如extend ListView实现上拉刷新下拉加载<br>继承于ViewGroup<br>    如果要自定的view需要有子View的概念，那么继承于ViewGroup<br>继承于View<br>    如果要自定的view不需要子View的概念，那么继承于View</p>
<p>这里要是实现的ArcMenu，里面包含一个主button和一组子item菜单，所以继承ViewGroup最好；</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">ArcMenu</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">ViewGroup</span></span>
</code></pre><p>继承ViewGrop必须实现三个默认参数(5.0API是4个参数)和onLayout</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="title">ArcMenu</span><span class="params">(Context context)</span> </span>{
    <span class="keyword">this</span>(context, <span class="keyword">null</span>);<span class="comment">//走两个构造参数</span>
}

<span class="function"><span class="keyword">public</span> <span class="title">ArcMenu</span><span class="params">(Context context, AttributeSet attrs)</span> </span>{
    <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);<span class="comment">//走三个构造参数</span>
}

<span class="function"><span class="keyword">public</span> <span class="title">ArcMenu</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> </span>{
    <span class="keyword">super</span>(context, attrs, defStyle);
    init_type(context, attrs, defStyle);<span class="comment">// 设置属性</span>
}
</code></pre><h3 id="问题三的答案：onMeasure、onLayout和onDraw方法的实现">问题三的答案：onMeasure、onLayout和onDraw方法的实现</h3><p>onMeasure测量宽高和模型<br>这里的ArcMenu因为是match_parent所以它的测量会相对简单</p>
<pre><code><span class="annotation">@Override</span>
<span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>{
    <span class="keyword">int</span> childCount = getChildCount();
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) {
        measureChild(getChildAt(i), widthMeasureSpec, heightMeasureSpec);
    }
    <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);
}
</code></pre><p>onLayout摆放位置<br>这里的onLayout是继承ViewGroup必须实现的方法</p>
<pre><code><span class="annotation">@Override</span>
<span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>{
    <span class="keyword">if</span> (changed) {
        layoutCButton();<span class="comment">//放置主button</span>
        layoutSonButton();<span class="comment">//放置子button</span>
    }
}
</code></pre><p>子Item的点击事件</p>
<pre><code><span class="comment">// item的点击事件处理</span>
    <span class="keyword">final</span> <span class="keyword">int</span> pos = i + <span class="number">1</span>;
    childView.setOnClickListener(<span class="keyword">new</span> OnClickListener() {
        <span class="annotation">@Override</span>
        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>{
            <span class="keyword">if</span> (menuClickListener != <span class="keyword">null</span>) {
                <span class="comment">// 回调用户自己实现</span>
                menuClickListener.onClick(childView, pos);
                <span class="comment">// 同时让点击的item做放大动画，其他的item做缩小动画</span>
                menuItemAnim(pos - <span class="number">1</span>);
                changeStaus();<span class="comment">// 这里要执行一个状态改变，因为点击一个子item后，所有子item消失，状态也就变化了</span>
            }
        }
    });
</code></pre><p>#11.</p>
<p>#12.</p>
<p>#13.</p>
<p>#14.EventBus 发布 / 订阅的事件总线</p>
<p>##15.1 EventBus解决的问题<br>1.Activity与Fragment的交互，Activity与Activity交互，Activity与View交互，Activtiy与Service交互等等…<br>2.极简化替代handler、AsynTask和接口回调的代码操作</p>
<p>##15.2 核心原理</p>
<blockquote>
<p>在register时，扫描类中复合命名规范的方法，存到一个map(map的键就是参数的Class类型)，然后post的时候，查找到匹配的方法，反射调用；</p>
</blockquote>
<p>比如Activity中：</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">NewUserCenterActivity</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">FragmentActivity</span>{</span>

    <span class="comment">// Handle scroll event from fragments</span>
    public void onEvent(<span class="type">Boolean</span> b) {
        <span class="type">System</span>.out.println(<span class="string">"onEvent"</span>);
        <span class="comment">//该方法会等待post执行后，执行</span>
        dragLayout.setTouchMode(b);
    }

    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> void onResume() {
        <span class="keyword">super</span>.onResume();
        <span class="comment">//注册,然后会扫描这个类中的以OnEvent命名的方法名，存储到Map集合，并等待post方法在任何地方调用</span>
        <span class="type">EventBus</span>.getDefault().register(<span class="keyword">this</span>);
    }

    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> void onPause() {
        <span class="keyword">super</span>.onPause();
        <span class="type">EventBus</span>.getDefault().unregister(<span class="keyword">this</span>);
    }

}
</code></pre><p>要与Activity交互的Fragment：</p>
<pre><code><span class="comment">//注意这里的代码</span>
    myPulltorefresh_listview.setOnScrollListener(<span class="keyword">new</span> OnScrollListener() {

        <span class="annotation">@Override</span>
        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onScrollStateChanged</span><span class="params">(AbsListView view, <span class="keyword">int</span> scrollState)</span> </span>{

        }

        <span class="annotation">@Override</span>
        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onScroll</span><span class="params">(AbsListView view, <span class="keyword">int</span> firstVisibleItem, <span class="keyword">int</span> visibleItemCount, <span class="keyword">int</span> totalItemCount)</span> </span>{
            Boolean attach=AttachUtil.isAdapterViewAttach(view);

            <span class="comment">//post，会寻找所有注册的OnEvent方法，根据参数来执行该OnEvent,这里的参数是Boolean，那么执行的就是 onEvent(Boolean b)---》根据参数的格式和类型来决定执行哪个OnEvent事件</span>
            EventBus.getDefault().post(attach);
        }
    });
</code></pre><p>注意：//postSticky会缓存最新的event事件，不管接收方是否消亡，载入时都会检测最新状态  </p>
<p>##15.3 API：</p>
<pre><code>EventBus.getDefault<span class="params">()</span>.register<span class="params">(this)</span>;<span class="comment">//订阅事件</span>
EventBus.getDefault<span class="params">()</span>.post<span class="params">(object)</span>;<span class="comment">//发布事件</span>
EventBus.getDefault<span class="params">()</span>.unregister<span class="params">(this)</span>;<span class="comment">//取消订阅</span>
</code></pre><p>##15.4 四个线程Event：<br>EventBus包含4个ThreadMode：PostThread，MainThread，BackgroundThread，Async</p>
<p>各自对应的onevent方法名：<br>onEventPostThread， onEventMainThread，onEventBackgroundThread，onEventAsync即可</p>
<p>具体什么区别呢？</p>
<p>onEventMainThread代表这个方法会在UI线程执行<br>onEventPostThread代表这个方法会在当前发布事件的线程执行<br>BackgroundThread这个方法，如果在非UI线程发布的事件，则直接执行，和发布在同一个线程中。如果在UI线程发布的事件，则加入后台任务队列，使用线程池一个接一个调用。<br>Async 加入后台任务队列，使用线程池调用，注意没有BackgroundThread中的一个接一个。</p>
<p>###15.5 问题以及它的解决方案<br>当发过来一个消息的时候，EventBus怎么知道要调哪个函数呢，就看哪个函数传进去的参数是这个类的实例，哪个是就调哪个。那如果有两个是呢，那两个都会被调用;</p>
<p>这样会导致性能问题，解决方案，通过建立一个参数类来解决这个问题</p>
<p>1.新建一个参数实例类：<br>    public class FirstEvent {</p>
<pre><code>    <span class="keyword">private</span> <span class="built_in">String</span> mMsg;
    <span class="keyword">public</span> FirstEvent(<span class="built_in">String</span> msg) {
        <span class="comment">// TODO Auto-generated constructor stub</span>
        mMsg = msg;
    }
    <span class="keyword">public</span> <span class="built_in">String</span> getMsg(){
        <span class="keyword">return</span> mMsg;
    }
}
</code></pre><p>2.Activity-Two发送事件时：post(new 实例类);<br>    btn_FirstEvent.setOnClickListener(new View.OnClickListener() {  </p>
<pre><code>    <span class="annotation">@Override</span>  
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>{  
        EventBus.getDefault().post(  
                <span class="keyword">new</span> FirstEvent(<span class="string">"FirstEvent btn clicked"</span>));  
    }  
});  
</code></pre><p>3.Activity-one注册和接受事件时：</p>
<pre><code>EventBus.getDefault().register(<span class="keyword">this</span>);<span class="comment">//注册</span>

<span class="comment">//指定onEventMainThread的参数为FirstEvent类型，那么这个方法执行的接受接受post(new FirstEvent)</span>
<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventMainThread</span>(<span class="params">FirstEvent <span class="keyword">event</span></span>) </span>{  
    Log.d(<span class="string">"harvic"</span>, <span class="string">"onEventMainThread收到了消息："</span> + <span class="keyword">event</span>.getMsg());  
}  

<span class="comment">//当发送FirstEvent时就不会执行这个onEvent事件</span>
<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventMainThread</span>(<span class="params">SecondEvent <span class="keyword">event</span></span>) </span>{  
    Log.d(<span class="string">"harvic"</span>, <span class="string">"onEventMainThread收到了消息："</span> + <span class="keyword">event</span>.getMsg());  
} 
</code></pre><p>如果是从另一个ActivityB给ActivityB传递event,最好使用onDestory注销<br>onCreate中register； onDestory中unregister;</p>
<p>#15.Fragment的处理</p>
<p>##15.1Fragment的产生<br>Fragment片段，专为对一个Activity的“某部分布局”进行不同“实现布局”(Fragment)的切换；</p>
<p>##15.2Fragment生命周期</p>
<p><img src="http://i.imgur.com/hCLWHBN.png" alt=""></p>
<p>onAttach(Activity)：当fragment被加入到activity时调用（可以获得所在的activity）</p>
<p>onCreateView(LayoutInflater, ViewGroup,Bundle)：当activity要得到fragment的layout时，调用此方法，fragment在其中创建自己的layout</p>
<p>onActivityCreated(Bundle)：当Activity的onCreate方法返回时调用</p>
<p>onDestoryView()：与onCreateView想对应，当该Fragment的视图被移除时调用</p>
<p>onDetach()：与onAttach相对应，当Fragment与Activity关联被取消时调用</p>
<pre><code>注意：除了<span class="keyword">on</span>CreateView，其他的所有方法如果你重写了，必须调用父类对于该方法的实现
</code></pre><p>所以Fragment的一般操作如下：调用顺序 </p>
<p>   建议Fragment中做出如下的处理： </p>
<blockquote>
<p>onAttach()：中getActivity();</p>
<p>onCreateView():加载布局和findViewById; </p>
<p>onActivityCreated():进行数据的获取与业务逻辑操作</p>
</blockquote>
<p>##15.3创建Fragment的API</p>
<p>创建Fragment的方法：</p>
<blockquote>
<p>1、XML布局中使用标签<fragment>：不能移除，而且这种方式在Activity创建的时候，就被创建出来了，灵活性差，仅仅作为简单的视图展示可以；</fragment></p>
<p>2、代码动态添加：可以实现不同Fragment之间的切换：FragmentManager实现activity运行时对fragment进行添加，移除，和替换。推荐的方式，可控性高，方便处理不同屏幕的适配。但布局中必须有一个视图容器去存放fragment。</p>
</blockquote>
<pre><code> &lt;FrameLayout  
    android:<span class="property">id</span>=<span class="string">"@+id/id_content"</span>  
    android:layout_width=<span class="string">"fill_parent"</span>  
    android:layout_height=<span class="string">"fill_parent"</span> /&gt;  

然后对这个FrameLayout进行切换处理
</code></pre><p>FragmentTransaction-API:</p>
<pre><code>FragmentTransaction transaction = fm.benginTransatcion<span class="params">()</span>;<span class="comment">//开启一个事务</span>

transaction.add<span class="params">()</span>;<span class="comment">//往Activity中添加一个Fragment</span>

transaction.remove<span class="params">()</span>;<span class="comment">//从Activity中移除一个Fragment，如果被移除的Fragment没有添加到回退栈（回退栈后面会详细说），这个Fragment实例将会被销毁。</span>

transaction.replace<span class="params">()</span>;<span class="comment">//使用另一个Fragment替换当前的，实际上就是remove()然后add()的合体~</span>

transaction.hide<span class="params">()</span>;<span class="comment">//隐藏当前的Fragment，仅仅是设为不可见，并不会销毁</span>

transaction.show<span class="params">()</span>;<span class="comment">//显示之前隐藏的Fragment</span>

detach<span class="params">()</span>;<span class="comment">//将此Fragment从Activity中分离，会销毁其布局，但不会销毁该实例</span>

attach<span class="params">()</span>;<span class="comment">//将从Activity中分离的Fragment，重新关联到该Activity，重新创建其视图层次</span>

transatcion.commit<span class="params">()</span>;<span class="comment">//提交一个事务</span>
</code></pre><p>在一个事务开启到提交可以进行多个的添加、移除、替换等操作。</p>
<p>UIManager:</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UIManager</span> </span>{

    <span class="comment">/**
     * 单例模式
     */</span>
    <span class="keyword">private</span> <span class="keyword">static</span> UIManager instance = <span class="keyword">new</span> UIManager();

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function">UIManager <span class="title">getInstance</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> instance;
    }
    <span class="function"><span class="keyword">private</span> <span class="title">UIManager</span><span class="params">()</span> </span>{
    }

    <span class="comment">/**
     * 切换界面
     * <span class="doctag">@param</span> target 要切换到的Fragment
     * <span class="doctag">@param</span> isAddStack 是否添加到返回键栈中
     * <span class="doctag">@param</span> bundle 两个fragment之间数据的传递
     * 
     */</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">changeFragment</span><span class="params">(Fragment <span class="keyword">target</span>,Boolean isAddStack,Bundle bundle)</span></span>{

        <span class="keyword">if</span>(bundle!=<span class="keyword">null</span>){
            <span class="comment">/**
             * 两个Fragment之间参数的传递
             */</span>
            <span class="keyword">target</span>.setArguments(bundle);
        }

        <span class="comment">//获取Fragment管理器</span>
        FragmentManager manager=GloableParams.MAIN.getSupportFragmentManager();
        FragmentTransaction transaction = manager.beginTransaction();
        <span class="comment">//Fragment切换动画:淡入淡出动画</span>
        transaction.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_FADE);
        <span class="comment">//替换---将无法使用find查找原先的</span>
        <span class="comment">// 第一参数：中间容器的id，第二个参数：添加的Fragment</span>
        <span class="comment">/**
         * 切换Fragment
         */</span>
        transaction.replace(R.id.ii_middle, <span class="keyword">target</span>);
        <span class="comment">/**
         * 是否放到返回栈中--返回键处理
         * true:不断按返回键时不断的将以前的Fragment不断的显示回来;
         */</span>
        <span class="keyword">if</span>(isAddStack){<span class="comment">//是否Add到回退栈内</span>
            transaction.addToBackStack(<span class="keyword">null</span>);
        }
        transaction.commit();
    }
}

<span class="comment">//使用</span>
<span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">addMore</span><span class="params">()</span> </span>{
    <span class="comment">//如果想在返回键见到，参数2设为true，一般我们处置为false</span>
    UIManager.getInstance().changeFragment(channelFragment, <span class="keyword">false</span>,<span class="keyword">null</span>);
}
</code></pre><p>##15.4 正确使用API<br>a、当切换到Fragment时，如果希望切回来后数据和面板状态仍然存在，可以使用hide和show，当然了不要使劲在那new实例，进行下非null判断。</p>
<blockquote>
<p>replace：    </p>
</blockquote>
<pre><code>FragmentManager fm = getFragmentManager<span class="params">()</span>;  
FragmentTransaction tx = fm.beginTransaction<span class="params">()</span>; 
  <span class="keyword">if</span> <span class="params">(mFriend == null)</span>{  
       mFriend = new FriendFragment<span class="params">()</span>;  
  }
transaction.replace<span class="params">(R.id.id_content, mFriend)</span>;   
transaction.addToBackStack<span class="params">()</span>;
transaction.commit<span class="params">()</span>; 
</code></pre><blockquote>
<p>hide：</p>
</blockquote>
<pre><code>FragmentThree fThree = new FragmentThree<span class="params">()</span>;  
FragmentManager fm = getFragmentManager<span class="params">()</span>;  
FragmentTransaction tx = fm.beginTransaction<span class="params">()</span>;  
tx.hide<span class="params">(fTwo)</span>;<span class="comment">//隐藏上一个 </span>
tx.add<span class="params">(R.id.id_content , fThree, <span class="string">"THREE"</span>)</span>; <span class="comment">//添加新的进去 </span>
tx.addToBackStack<span class="params">(null)</span>;  
tx.commit<span class="params">()</span>;  
</code></pre><p>b、不希望保留用户操作，你可以使用remove()，然后add()；或者使用replace()这个和remove,add是相同的效果。</p>
<p>c、remove和detach有一点细微的区别，在不考虑回退栈的情况下，remove会销毁整个Fragment实例，而detach则只是销 毁其视图结构，实例并不会被销毁。那么二者怎么取舍使用呢？如果你的当前Activity一直存在，那么在不希望保留用户操作的时候，你可以优先使用 detach。</p>
<p>##15.5 Fragment回退栈的管理</p>
<pre><code>FragmentTransaction.<span class="function"><span class="title">addToBackStack</span><span class="params">(String)</span></span>
</code></pre><p>##15.6 Fragment与Activity的交互</p>
<p>因为所有的Fragment都是依附于Activity的，所以通信起来并不复杂，大概归纳为：</p>
<p>a、如果你Activity中包含自己管理的Fragment的引用，可以通过引用直接访问所有的Fragment的public方法</p>
<p>b、如果Activity中未保存任何Fragment的引用，那么没关系，每个Fragment都有一个唯一的TAG或者ID,可以通过getFragmentManager.findFragmentByTag()或者findFragmentById()获得任何Fragment实例，然后进行操作。</p>
<p>c、在Fragment中可以通过getActivity得到当前绑定的Activity的实例，然后进行操作。</p>
<p>d、（推荐）在Fragment中定义回调接口listener，由Activity实现，然后在Fragment的onAttach获取到该Activity强转为listener，之后进行一些操作。</p>
<p>注：如果在Fragment中需要Context，可以通过调用getActivity(),如果该Context需要在Activity被销毁后还存在，则使用getActivity().getApplicationContext()。</p>
<p>定义接口的方法有两种表现模式：<br>方法一：FragmentOne不和任何Activity耦合，任何Activity都可以使用；并且我们声明了一个接口，来回调其点击事件，想要管理其点击事件的Activity实现此接口就即可。可以看到我们在onClick中首先判断了当前绑定的Activity是否实现了该接口，如果实现了则调用。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FragmentOne</span> <span class="keyword">extends</span> <span class="title">Fragment</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span> </span>{
    <span class="keyword">private</span> Button mBtn;

    <span class="comment">/**
     * 设置按钮点击的回调
     */</span>
    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FOneBtnClickListener</span> </span>{
        <span class="function"><span class="keyword">void</span> <span class="title">onFOneBtnClick</span><span class="params">()</span></span>;
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</span> </span>{
        View view = inflater.inflate(R.layout.fragment_one, container, <span class="keyword">false</span>);
        mBtn = (Button) view.findViewById(R.id.id_fragment_one_btn);
        mBtn.setOnClickListener(<span class="keyword">this</span>);
        <span class="keyword">return</span> view;
    }

    <span class="comment">/**
     * 交给宿主Activity处理，如果它希望处理
     */</span>
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>{
        <span class="keyword">if</span> (getActivity() <span class="keyword">instanceof</span> FOneBtnClickListener) {
            ((FOneBtnClickListener) getActivity()).onFOneBtnClick();
        }
    }

}
</code></pre><p>方法二：我们提供了setListener这样的方法，意味着Activity不仅需要实现该接口，还必须显示调用mFTwo.setfTwoBtnClickListener(this)。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FragmentTwo</span> <span class="keyword">extends</span> <span class="title">Fragment</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span> </span>{

    <span class="keyword">private</span> Button mBtn;

    <span class="comment">//设置接口回调</span>
    <span class="keyword">private</span> FTwoBtnClickListener fTwoBtnClickListener;
    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FTwoBtnClickListener</span> </span>{
        <span class="function"><span class="keyword">void</span> <span class="title">onFTwoBtnClick</span><span class="params">()</span></span>;
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setfTwoBtnClickListener</span><span class="params">(FTwoBtnClickListener fTwoBtnClickListener)</span> </span>{
        <span class="keyword">this</span>.fTwoBtnClickListener = fTwoBtnClickListener;
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</span> </span>{
        View view = inflater.inflate(R.layout.fragment_two, container, <span class="keyword">false</span>);
        mBtn = (Button) view.findViewById(R.id.id_fragment_two_btn);
        mBtn.setOnClickListener(<span class="keyword">this</span>);
        <span class="keyword">return</span> view;
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>{
        <span class="keyword">if</span> (fTwoBtnClickListener != <span class="keyword">null</span>) {
            <span class="comment">//子类去实现</span>
            fTwoBtnClickListener.onFTwoBtnClick();
        }
    }

}
</code></pre><p>Activity实现这些Fragment的回调</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">FOneBtnClickListener</span>,
        <span class="title">FTwoBtnClickListener</span></span>{

    <span class="keyword">private</span> FragmentOne mFOne;
    <span class="keyword">private</span> FragmentTwo mFTwo;
    <span class="keyword">private</span> FragmentThree mFThree;

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span>{
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        requestWindowFeature(Window.FEATURE_NO_TITLE);
        setContentView(R.layout.activity_main);

        mFOne = <span class="keyword">new</span> FragmentOne();
        FragmentManager fm = getFragmentManager();
        FragmentTransaction tx = fm.beginTransaction();
        tx.add(R.id.id_content, mFOne, <span class="string">"ONE"</span>);
        tx.commit();
    }

    <span class="comment">/**
     * FragmentOne 按钮点击时的回调
     */</span>
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFOneBtnClick</span><span class="params">()</span></span>{

        <span class="keyword">if</span> (mFTwo == <span class="keyword">null</span>){
            mFTwo = <span class="keyword">new</span> FragmentTwo();
            mFTwo.setfTwoBtnClickListener(<span class="keyword">this</span>);
        }
        FragmentManager fm = getFragmentManager();
        FragmentTransaction tx = fm.beginTransaction();
        tx.replace(R.id.id_content, mFTwo, <span class="string">"TWO"</span>);
        tx.addToBackStack(<span class="keyword">null</span>);
        tx.commit();
    }


    <span class="comment">/**
     * FragmentTwo 按钮点击时的回调
     */</span>
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFTwoBtnClick</span><span class="params">()</span></span>{
        <span class="keyword">if</span> (mFThree == <span class="keyword">null</span>){
            mFThree = <span class="keyword">new</span> FragmentThree();
        }
        FragmentManager fm = getFragmentManager();
        FragmentTransaction tx = fm.beginTransaction();
        tx.hide(mFTwo);
        tx.add(R.id.id_content, mFThree, <span class="string">"THREE"</span>);
        <span class="comment">// tx.replace(R.id.id_content, fThree, "THREE");</span>
        tx.addToBackStack(<span class="keyword">null</span>);
        tx.commit();
    }
}
</code></pre><p>##15.7 如何处理运行时配置发生变化<br>当屏幕旋转或者当你的应用被至于后台（例如用户点击了home），长时间没有返回的时候，你的应用也会被重新启动。这样会导致Fragment的重复创建，导致Fragment重叠的问题。</p>
<p>##15.8 解决Fragment的重复创建<br>在Activity的onCreate方法中对saveInstanceState进行判断，如果saveInstaceState==null时，再进行Fragment创建。现在无论进行多次旋转都只会有一个Fragment实例在Activity中。</p>
<pre><code><span class="keyword">if</span><span class="params">(savedInstanceState == null)</span>{
   mFOne = new FragmentOne<span class="params">()</span>;
   FragmentManager fm = getFragmentManager<span class="params">()</span>;
   FragmentTransaction tx = fm.beginTransaction<span class="params">()</span>;
   tx.add<span class="params">(R.id.id_content, mFOne, “ONE”)</span>;
   tx.commit<span class="params">()</span>;
}
</code></pre><p>##15.9 解决Fragment重叠的问题<br>在Activity中复写onSaveIndstanceState方法然后注释掉super.onSaveInstanceState()<br>这种方式不保存之前的Fragment状态，因此不会重叠。</p>
<pre><code><span class="annotation">@Override</span>
<span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle bundle)</span> </span>{
    <span class="comment">// do not call super.onSaveInstanceState()</span>
}
</code></pre><p>##15.10 如果Fragment发生重建，如何保持原本的数据？<br>和Activity类似，Fragment也有onSaveInstanceState的方法，在此方法中进行保存数据，然后在onCreate或者onCreateView或者onActivityCreated进行恢复都可以。</p>
<p>##15.11 Fragment状态的恢复</p>
<blockquote>
<p>a、onSaveInstanceState()和onRestoreInstanceState()<br>少量数据，可以通过onSaveInstanceState()和onRestoreInstanceState()进行保存与恢复。<br>Android会在销毁你的Activity之前调用onSaveInstanceState()方法，于是，你可以在此方法中存储关于应用状态的数据。然后你可以在onCreate()或onRestoreInstanceState()方法中恢复</p>
<p>b、Fragment<br>大量数据，使用Fragment保持需要恢复的对象</p>
<p>c、自已处理配置变化<br>注:getLastNonConfigurationInstance()已经被弃用，被上述方法二替代。</p>
</blockquote>
<p>###15.12 使用Fragment来保存对象、恢复数据</p>
<p>###15.13 FragmentPagerAdapter与FragmentStatePagerAdapter<br>主要区别在与对于fragment是否销毁</p>
<p>FragmentPagerAdapter：对于不再需要的fragment，选择调用detach方法，仅销毁视图，并不会销毁fragment实例。</p>
<p>FragmentStatePagerAdapter： 会销毁不再需要的fragment，当当前事务提交以后，会彻底的将fragmeng从当前Activity的FragmentManager中移 除，state标明，销毁时，会将其onSaveInstanceState(Bundle outState)中的bundle信息保存下来，当用户切换回来，可以通过该bundle恢复生成新的fragment，也就是说，你可以在 onSaveInstanceState(Bundle outState)方法中保存一些数据，在onCreate中进行恢复创建。</p>
<p>如上所说， 使用FragmentStatePagerAdapter当然更省内存，但是销毁新建也是需要时间的。一般情况下，如果你是制作主页面，就3、4个 Tab，那么可以选择使用FragmentPagerAdapter，如果你是用于ViewPager展示数量特别多的条目时，那么建议使用 FragmentStatePagerAdapter</p>
<p>###15.14 其它Fragment类型<br>DialogFragment<br>   显示一个浮动的对话框.<br>   用这个类来创建一个对话框,是使用在Activity类的对话框工具方法之外的一个好的选择,<br>   因为你可以将一个fragment对话框合并到activity管理的fragment back stack中,允许用户返回到一个之前曾被摒弃的fragment.</p>
<p>ListFragment<br>   显示一个由一个adapter(例如 SimpleCursorAdapter)管理的项目的列表, 类似于ListActivity.<br>   它提供一些方法来管理一个list view, 例如 onListItemClick()回调来处理点击事件.</p>
<p>PreferenceFragment<br>   显示一个Preference对象的层次结构的列表, 类似于PreferenceActivity.<br>   这在为你的应用创建一个”设置”activity时有用处.</p>
<p>#16.各版本动画API</p>
<p>###16.1 View Animations：<br>    @TargetApi(1)<br>    public class ViewAnimations {</p>
<pre><code>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">alpha</span><span class="params">(View view)</span> </span>{
            AlphaAnimation alphaAnimation = <span class="keyword">new</span> AlphaAnimation(<span class="number">0.0f</span>, <span class="number">1.0f</span>);
            alphaAnimation.setDuration(<span class="number">1000</span>); <span class="comment">// 1 second</span>
            view.startAnimation(alphaAnimation);
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(View view)</span> </span>{
            RotateAnimation rotateAnimation = <span class="keyword">new</span> RotateAnimation(<span class="number">90</span>, <span class="number">180</span>);
            rotateAnimation.setDuration(<span class="number">1000</span>); <span class="comment">// 1 second</span>
            view.startAnimation(rotateAnimation);
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scale</span><span class="params">(View view)</span> </span>{
            ScaleAnimation scaleAnimation = <span class="keyword">new</span> ScaleAnimation(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);
            scaleAnimation.setDuration(<span class="number">1000</span>); <span class="comment">// 1 second</span>
            view.startAnimation(scaleAnimation);
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">translate</span><span class="params">(View view)</span> </span>{
            TranslateAnimation translateAnimation = <span class="keyword">new</span> TranslateAnimation(<span class="number">0.0f</span>, <span class="number">100.0f</span>, <span class="number">0.0f</span>, <span class="number">100.0f</span>);
            translateAnimation.setDuration(<span class="number">1000</span>); <span class="comment">// 1 second</span>
            view.startAnimation(translateAnimation);
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">animationSet</span><span class="params">(View view)</span> </span>{
            ScaleAnimation scaleAnimation = <span class="keyword">new</span> ScaleAnimation(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);
            scaleAnimation.setDuration(<span class="number">1000</span>); <span class="comment">// 1 second</span>

            AlphaAnimation alphaAnimation = <span class="keyword">new</span> AlphaAnimation(<span class="number">0.0f</span>, <span class="number">1.0f</span>);
            alphaAnimation.setDuration(<span class="number">1000</span>); <span class="comment">// 1 second</span>

            AnimationSet animationSet = <span class="keyword">new</span> AnimationSet(<span class="literal">true</span>);
            animationSet.addAnimation(scaleAnimation);
            animationSet.addAnimation(alphaAnimation);
            animationSet.setFillAfter(<span class="literal">true</span>);

            view.startAnimation(animationSet);
    }
}
</code></pre><p>###16.2 Object Animator</p>
<p>@TargetApi(11)<br>    public class ObjectAnimator {</p>
<pre><code>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(View view)</span> </span>{

            PropertyValuesHolder rotateY = PropertyValuesHolder.ofFloat(View.ROTATION_Y, <span class="number">0</span>, <span class="number">90</span>);
            PropertyValuesHolder rotateX = PropertyValuesHolder.ofFloat(View.ROTATION_X, <span class="number">0</span>, <span class="number">90</span>);

            android.animation.ObjectAnimator animator = android.animation.ObjectAnimator.ofPropertyValuesHolder(view,
                            rotateX, rotateY);
            animator.setDuration(<span class="number">1000</span>); <span class="comment">// 1 second</span>
            animator.start();
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">alpha</span><span class="params">(View view)</span> </span>{

            PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat(View.ALPHA, <span class="number">0</span>, <span class="number">1</span>);

            android.animation.ObjectAnimator animator = android.animation.ObjectAnimator.ofPropertyValuesHolder(view,
                            alpha);
            animator.setDuration(<span class="number">1000</span>); <span class="comment">// 1 second</span>
            animator.start();
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scale</span><span class="params">(View view)</span> </span>{

            PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat(View.SCALE_Y, <span class="number">0</span>, <span class="number">1</span>);
            PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat(View.SCALE_X, <span class="number">0</span>, <span class="number">1</span>);

            android.animation.ObjectAnimator animator = android.animation.ObjectAnimator.ofPropertyValuesHolder(view,
                            scaleY, scaleX);
            animator.setDuration(<span class="number">1000</span>); <span class="comment">// 1 second</span>
            animator.start();
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">translate</span><span class="params">(View view)</span> </span>{

            PropertyValuesHolder translateX = PropertyValuesHolder.ofFloat(View.TRANSLATION_X, <span class="number">0</span>, <span class="number">100</span>);
            PropertyValuesHolder translateY = PropertyValuesHolder.ofFloat(View.TRANSLATION_Y, <span class="number">0</span>, <span class="number">100</span>);

            android.animation.ObjectAnimator animator = android.animation.ObjectAnimator.ofPropertyValuesHolder(view,
                            translateX, translateY);
            animator.setDuration(<span class="number">1000</span>); <span class="comment">// 1 second</span>
            animator.start();
    }
}
</code></pre><p>###16.3 Property Animations</p>
<pre><code>@TargetApi<span class="params">(<span class="number">12</span>)</span>
public class PropertyAnimations {
    public void <span class="built_in">rotate</span><span class="params">(View view)</span> {
            view.animate<span class="params">()</span>.rotationX<span class="params">(<span class="number">90</span>)</span>.rotationY<span class="params">(<span class="number">90</span>)</span>.start<span class="params">()</span>;
    }

    public void alpha<span class="params">(View view)</span> {
            view.animate<span class="params">()</span>.alpha<span class="params">(<span class="number">0</span>)</span>.start<span class="params">()</span>;
    }

    public void <span class="built_in">scale</span><span class="params">(View view)</span> {
            view.animate<span class="params">()</span>.scaleX<span class="params">(<span class="number">0</span>)</span>.scaleY<span class="params">(<span class="number">0</span>)</span>.start<span class="params">()</span>;
    }

    public void <span class="built_in">translate</span><span class="params">(View view)</span> {
            view.animate<span class="params">()</span>.translationX<span class="params">(<span class="number">100</span>)</span>.translationY<span class="params">(<span class="number">100</span>)</span>.start<span class="params">()</span>;
    }
}
</code></pre><p>#19 Volly框架</p>
<p>#18 TraceView使用</p>
<p>##18.1开启 TraceView<br>    Eclipse -&gt; DDMS -&gt; Start Method Profiling<br>    DDMS界面，点击左边Devices面板,选中要trace的进程，点击上面左起第6个按钮”Start method profiling”, 过段时间, 再次点击这个按钮”Stop method profiling”, TraceView就会自动弹出来了。</p>
<p>##18.2 TraceView数据分析</p>
<p>#19 属性动画</p>
<p>##19.1 为什么3.0后要使用属性动画<br>Animation 传统动画，交互效果不行，只有四种效果(位移旋转缩放透明度),本质是onDraw()不断重绘。动画移动后,点击事件还在原来的位子…</p>
<pre><code>TranslateAnimation translateAnimation = <span class="keyword">new</span> TranslateAnimation(<span class="number">0</span>, <span class="number">200</span>, <span class="number">0</span>, <span class="number">0</span>);
translateAnimation.setDuration(<span class="number">100</span>);
translateAnimation.setFillAfter(<span class="literal">true</span>);
imageview.startAnimation();
</code></pre><p>Animator 属性动画</p>
<pre><code>ObjectAnimator.ofFloat(imageview,<span class="string">"translationX"</span>,<span class="number">0f</span>,<span class="number">200f</span>).setDuration(<span class="number">1000</span>).start();
</code></pre><p>##19.2 ObjectAnimator</p>
<h3 id="单个动画效果：">单个动画效果：</h3><pre><code><span class="tag">ObjectAnimator</span><span class="class">.ofFloat</span>(动画对象,动画属性,<span class="tag">Float</span>具体参数);
</code></pre><p>常用属性如下：</p>
<pre><code>translationX<span class="string">\translationY</span>
rotation、rotationX<span class="string">\rotation、rotationY</span>
scaleX<span class="string">\scaleY</span>
X<span class="string">\Y</span>
alpha
</code></pre><p>常用的方法与类<br>    ValueAnimator<br>    ObjectAnimator<br>    //监听<br>    AnimatorUpdateListener<br>    AnimatorListenerAdapter<br>    //动画方案<br>    propertyValuesHolder<br>    AnimatorSet<br>    //<br>    TypeEvaluators<br>    //<br>    Interpolators</p>
<p>·比如向右平移200：</p>
<pre><code>ObjectAnimator.ofFloat(imageView,<span class="string">"translationX"</span>,<span class="number">0</span>,<span class="number">200F</span>).setDuration(<span class="number">1000</span>).start();
</code></pre><p>###多个动画的组合：<br>方法一：</p>
<pre><code>ObjectAnimator.ofFloat(imageview, <span class="string">"rotation"</span>, <span class="number">0f</span>, <span class="number">360f</span>).setDuration(<span class="number">1000</span>).start();
ObjectAnimator.ofFloat(imageview, <span class="string">"translationX"</span>, <span class="number">0f</span>, <span class="number">200f</span>).setDuration(<span class="number">1000</span>).start();
ObjectAnimator.ofFloat(imageview, <span class="string">"translationY"</span>, <span class="number">0f</span>, <span class="number">200f</span>).setDuration(<span class="number">1000</span>).setStartDelay(<span class="number">200</span>).start();
</code></pre><p>注：因为start是异步方法，所以这三个动画效果，是同时执行的</p>
<p>方法二：PropertyValuesHolder</p>
<pre><code>PropertyValuesHolder p1 = PropertyValuesHolder.ofFloat(<span class="string">"rotation"</span>, <span class="number">0f</span>, <span class="number">360f</span>);
PropertyValuesHolder p2 = PropertyValuesHolder.ofFloat(<span class="string">"translationX"</span>, <span class="number">0f</span>, <span class="number">200f</span>);
PropertyValuesHolder p3 = PropertyValuesHolder.ofFloat(<span class="string">"translationY"</span>, <span class="number">0f</span>, <span class="number">200f</span>);
ObjectAnimator.ofPropertyValuesHolder(imageview,p1,p2,p3).setDuration(<span class="number">1000</span>).start();
</code></pre><p>方法三：AnimatorSet</p>
<pre><code>AnimatorSet <span class="built_in">set</span> = <span class="keyword">new</span> AnimatorSet();
ObjectAnimator animator1 = ObjectAnimator.ofFloat(imageview, <span class="string">"rotation"</span>, <span class="number">0f</span>, <span class="number">360f</span>);
ObjectAnimator animator2 = ObjectAnimator.ofFloat(imageview, <span class="string">"translationX"</span>, <span class="number">0f</span>, <span class="number">200f</span>);
ObjectAnimator animator3 = ObjectAnimator.ofFloat(imageview, <span class="string">"translationY"</span>, <span class="number">0f</span>, <span class="number">200f</span>);
<span class="built_in">set</span>.playTogether(animator1,animator2,animator3);
<span class="built_in">set</span>.setDuration(<span class="number">1000</span>);
<span class="built_in">set</span>.start();
</code></pre><p>###动画的执行顺序<br>同时执行动画</p>
<pre><code><span class="operator"><span class="keyword">set</span>.playTogether(animator1,animator2,animator3);</span>
</code></pre><p>顺序执行动画</p>
<pre><code><span class="operator"><span class="keyword">set</span>.playSequentially(animator1,animator2,animator3);</span>
</code></pre><p>执行after or before  or with顺序</p>
<pre><code>//动画执行顺序 先同时执行2和3，然后1在2后执行
<span class="operator"><span class="keyword">set</span>.play(animator2).<span class="keyword">with</span>(animator3);</span>
<span class="operator"><span class="keyword">set</span>.play(animator1).<span class="keyword">after</span>(animator2);</span>
</code></pre><p>##动画的监听</p>
<p>方法一：</p>
<pre><code>ObjectAnimator anim = ObjectAnimator.ofFloat(imageview, <span class="string">"alphs"</span>, of, <span class="number">1</span>f);
    anim.setDuration(<span class="number">1000</span>);
    anim.addListener(<span class="keyword">new</span> Animator.AnimatorListener() {
        <span class="annotation">@Override</span>
        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animator animation)</span> </span>{

        }

        <span class="annotation">@Override</span>
        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span> </span>{

        }

        <span class="annotation">@Override</span>
        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onAnimationCancel</span><span class="params">(Animator animation)</span> </span>{

        }

        <span class="annotation">@Override</span>
        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onAnimationRepeat</span><span class="params">(Animator animation)</span> </span>{

        }
    });
    anim.start();
</code></pre><p>方法二：</p>
<pre><code>anim.addListener(<span class="keyword">new</span> AnimatorListenerAdapter() {
        <span class="annotation">@Override</span>
        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span> </span>{
            <span class="keyword">super</span>.onAnimationEnd(animation);
        }
    });
</code></pre><p>加速器<br>    anim.setInterpolator(new BounceInterpolator());</p>
<p>##19.3 ValueAnimator 数字发生器<br>ObjectAnimator继承于它</p>
<pre><code><span class="keyword">final</span> ValueAnimator valueAnim= ValueAnimator.ofInt(<span class="number">0</span>, <span class="number">100</span>);
    <span class="comment">//获取每一步调用获取的value值</span>
    valueAnim.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() {
        <span class="annotation">@Override</span>
        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>{
           Integer value= (Integer) valueAnim.getAnimatedValue();

        }
    });

<span class="comment">//使用ValueAnimator.ofObject</span>
ValueAnimator.ofObject(<span class="keyword">new</span> TypeEvaluator() {
        <span class="comment">//fraction 0-1</span>
        <span class="annotation">@Override</span>
        <span class="keyword">public</span> <span class="function">Object <span class="title">evaluate</span><span class="params">(<span class="keyword">float</span> fraction, Object startValue, Object endValue)</span> </span>{
            <span class="keyword">return</span> <span class="keyword">null</span>;
        }
    });
</code></pre><p>##19.4补充 左右上下抖动动画</p>
<pre><code><span class="comment">//tada方法实现了上下抖动。抖动的原理很简单，就是对view的x轴和y轴进行0.9倍到1.1倍的缩放，同时对view进行一定角度的上下旋转。</span>
<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ObjectAnimator <span class="title">tada</span><span class="params">(View view)</span> </span>{
    <span class="keyword">return</span> tada(view, <span class="number">1f</span>);
}

<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ObjectAnimator <span class="title">tada</span><span class="params">(View view, <span class="keyword">float</span> shakeFactor)</span> </span>{

    PropertyValuesHolder pvhScaleX = PropertyValuesHolder.ofKeyframe(View.SCALE_X,
            Keyframe.ofFloat(<span class="number">0f</span>, <span class="number">1f</span>),
            Keyframe.ofFloat(<span class="number">.1</span>f, <span class="number">.9</span>f),
            Keyframe.ofFloat(<span class="number">.2</span>f, <span class="number">.9</span>f),
            Keyframe.ofFloat(<span class="number">.3</span>f, <span class="number">1.1f</span>),
            Keyframe.ofFloat(<span class="number">.4</span>f, <span class="number">1.1f</span>),
            Keyframe.ofFloat(<span class="number">.5</span>f, <span class="number">1.1f</span>),
            Keyframe.ofFloat(<span class="number">.6</span>f, <span class="number">1.1f</span>),
            Keyframe.ofFloat(<span class="number">.7</span>f, <span class="number">1.1f</span>),
            Keyframe.ofFloat(<span class="number">.8</span>f, <span class="number">1.1f</span>),
            Keyframe.ofFloat(<span class="number">.9</span>f, <span class="number">1.1f</span>),
            Keyframe.ofFloat(<span class="number">1f</span>, <span class="number">1f</span>)
    );

    PropertyValuesHolder pvhScaleY = PropertyValuesHolder.ofKeyframe(View.SCALE_Y,
            Keyframe.ofFloat(<span class="number">0f</span>, <span class="number">1f</span>),
            Keyframe.ofFloat(<span class="number">.1</span>f, <span class="number">.9</span>f),
            Keyframe.ofFloat(<span class="number">.2</span>f, <span class="number">.9</span>f),
            Keyframe.ofFloat(<span class="number">.3</span>f, <span class="number">1.1f</span>),
            Keyframe.ofFloat(<span class="number">.4</span>f, <span class="number">1.1f</span>),
            Keyframe.ofFloat(<span class="number">.5</span>f, <span class="number">1.1f</span>),
            Keyframe.ofFloat(<span class="number">.6</span>f, <span class="number">1.1f</span>),
            Keyframe.ofFloat(<span class="number">.7</span>f, <span class="number">1.1f</span>),
            Keyframe.ofFloat(<span class="number">.8</span>f, <span class="number">1.1f</span>),
            Keyframe.ofFloat(<span class="number">.9</span>f, <span class="number">1.1f</span>),
            Keyframe.ofFloat(<span class="number">1f</span>, <span class="number">1f</span>)
    );

    PropertyValuesHolder pvhRotate = PropertyValuesHolder.ofKeyframe(View.ROTATION,
            Keyframe.ofFloat(<span class="number">0f</span>, <span class="number">0f</span>),
            Keyframe.ofFloat(<span class="number">.1</span>f, -<span class="number">3f</span> * shakeFactor),
            Keyframe.ofFloat(<span class="number">.2</span>f, -<span class="number">3f</span> * shakeFactor),
            Keyframe.ofFloat(<span class="number">.3</span>f, <span class="number">3f</span> * shakeFactor),
            Keyframe.ofFloat(<span class="number">.4</span>f, -<span class="number">3f</span> * shakeFactor),
            Keyframe.ofFloat(<span class="number">.5</span>f, <span class="number">3f</span> * shakeFactor),
            Keyframe.ofFloat(<span class="number">.6</span>f, -<span class="number">3f</span> * shakeFactor),
            Keyframe.ofFloat(<span class="number">.7</span>f, <span class="number">3f</span> * shakeFactor),
            Keyframe.ofFloat(<span class="number">.8</span>f, -<span class="number">3f</span> * shakeFactor),
            Keyframe.ofFloat(<span class="number">.9</span>f, <span class="number">3f</span> * shakeFactor),
            Keyframe.ofFloat(<span class="number">1f</span>, <span class="number">0</span>)
    );

    <span class="keyword">return</span> ObjectAnimator.ofPropertyValuesHolder(view, pvhScaleX, pvhScaleY, pvhRotate).
            setDuration(<span class="number">1000</span>);
}


<span class="comment">//上下nope方法实现了左右抖动。左右抖动的原理就是对view进行x轴的平移。</span>
<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ObjectAnimator <span class="title">nope</span><span class="params">(View view)</span> </span>{  
    <span class="keyword">int</span> delta = view.getResources().getDimensionPixelOffset(R.dimen.spacing_medium);  

    PropertyValuesHolder pvhTranslateX = PropertyValuesHolder.ofKeyframe(View.TRANSLATION_X,  
            Keyframe.ofFloat(<span class="number">0f</span>, <span class="number">0</span>),  
            Keyframe.ofFloat(<span class="number">.10</span>f, -delta),  
            Keyframe.ofFloat(<span class="number">.26</span>f, delta),  
            Keyframe.ofFloat(<span class="number">.42</span>f, -delta),  
            Keyframe.ofFloat(<span class="number">.58</span>f, delta),  
            Keyframe.ofFloat(<span class="number">.74</span>f, -delta),  
            Keyframe.ofFloat(<span class="number">.90</span>f, delta),  
            Keyframe.ofFloat(<span class="number">1f</span>, <span class="number">0f</span>)  
    );  

    <span class="keyword">return</span> ObjectAnimator.ofPropertyValuesHolder(view, pvhTranslateX).  
            setDuration(<span class="number">500</span>);  
}
</code></pre></span>
      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/07/30/第一次尝试搞逼格/" rel="prev">第一次尝试搞逼格</a>
            
          </div>

          <div class="post-nav-next post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


            </div>

            

            
              <div class="comments" id="comments">
                
              </div>
            
        </div>

        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/avatar.jpg" alt="熊伟(美丽神器APP)" itemprop="image"/>
          <p class="site-author-name" itemprop="name">熊伟(美丽神器APP)</p>
        </div>
        <p class="site-description motion-element" itemprop="description">重新发现、定义并创造这个世界...</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">4</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/xiaomeixw" target="_blank">github</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="jpxw007@gmail.com" target="_blank">gmail</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/1561605537" target="_blank">weibo</a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator"></div>
          <div class="post-toc">
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#问题二的答案：要继承实现哪个"><span class="nav-number">1.</span> <span class="nav-text">问题二的答案：要继承实现哪个</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#问题三的答案：onMeasure、onLayout和onDraw方法的实现"><span class="nav-number">2.</span> <span class="nav-text">问题三的答案：onMeasure、onLayout和onDraw方法的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单个动画效果："><span class="nav-number">3.</span> <span class="nav-text">单个动画效果：</span></a></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator"></div>
        </section>
      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
        <div class="footer-inner">
            <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2015</span>
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">熊伟(美丽神器APP)</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



        </div>
    </footer>

    <div class="back-to-top"></div>
</div>

<script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.4"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.4"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.4" id="motion.global"></script>



  <script type="text/javascript" src="/js/search-toggle.js"></script>


  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js?v=0.4.4" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 0.4 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    var $tocContent = $('.post-toc-content');
    if (isDesktop() && CONFIG.sidebar === 'post') {
      if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
        displaySidebar();
      }
    }
  });
</script>



<script type="text/javascript">
    $(document).ready(function () {
        if (CONFIG.sidebar === 'always') {
            displaySidebar();
        }
    });
</script>








<!-- lazyload -->
<script type="text/javascript" src="/js/lazyload.js"></script>
<script type="text/javascript">
    jQuery(function () {
        jQuery("#posts img").lazyload({
            placeholder: "/images/loading.gif",
            effect: "fadeIn"
        });
    });
</script>
</body>
</html>
